<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Veitor的技术点滴</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="php,CQRS,DDD,Event Sourcing,linux,Yii,kubernetes,golang,docker,互联网,化龙巷,常州">
<meta property="og:type" content="website">
<meta property="og:title" content="Veitor的技术点滴">
<meta property="og:url" content="http:&#x2F;&#x2F;www.veitor.net&#x2F;index.html">
<meta property="og:site_name" content="Veitor的技术点滴">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Veitor的技术点滴" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Veitor的技术点滴</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">PHP,DDD,CQRS,Event Sourcing,Kubernetes,Docker,Golang</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.veitor.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-593" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/06/593/" class="article-date">
  <time datetime="2019-05-06T05:41:00.000Z" itemprop="datePublished">2019-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/">程序与生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/593/">什么是SNI？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown--># SNI：在同一个IP地址上运行多个SSL证书

<p>什么是Server Name Indication(SNI)？SNI是SSL的重要组成部分，它允许多个网站存在同一个IP地址上，如果没有SNI，每个域名都需要有自己的一个IP才能安装SSL证书。然而，SNI解决了这个问题。</p>
<h1 id="为什么指定-Host-名称的方法无法再适用于-SSL-协议"><a href="#为什么指定-Host-名称的方法无法再适用于-SSL-协议" class="headerlink" title="为什么指定 Host 名称的方法无法再适用于 SSL 协议"></a>为什么指定 Host 名称的方法无法再适用于 SSL 协议</h1><p>大概在 2007 年以前，人们通过在 Header 里指明 Host 名称来解决这种同一 IP 上有多个网站的问题。</p>
<p>当客户端请求指定的网站时，在 HTTP Header 上指明要去的 Host 名称，然后服务端就会匹配 header 指定的网站，然后将请求发到那里去。</p>
<p>然而当 HTTPS 开始使用后，这一招不管用了。</p>
<p>因为 SSL 在客户端和服务端建立一个加密连接前，需要进行一次 SSL 握手。包含在 HTTP Header 里的域名只有在握手成功后才能被拿到，因此服务端无法知道该去连接同一 IP 上的哪个服务器。</p>
<h1 id="SNI-是什么"><a href="#SNI-是什么" class="headerlink" title="SNI 是什么"></a>SNI 是什么</h1><p>SNI（服务名称证明)是一个 SSL/TLS 协议的拓展，它允许在一个 IP 上有多个 SSL 证书。</p>
<p>SNI 是通过在 SSL 握手时插入 HTTP Header 实现这个功能的。因为服务端可以在握手时读到想要连接的 Host 名称，就可以连接到正确的网站。</p>
<p><img src="http://storage.veitor.net/2019/05/167870958.png" alt="handshake-diagram-thumb-500xauto-5789.png" title="handshake-diagram-thumb-500xauto-5789.png"></p>
<p>在 SNI 创造之前，每个你想加密的网站都必须有一个唯一的 IP 地址。你可能意识不到的是，这多么的浪费，甚至对 IPv4 IP 地址的消耗产生了非常严重的影响。</p>
<p>我们都知道 IPv4 定义的 IP 地址是有限的，它赋予使用 IP 协议进行通讯的电脑网络中的每一个设备一个地址。</p>
<p>一个 IPv4 的地址格式如下：</p>
<p><img src="http://storage.veitor.net/2019/05/1178067102.png" alt="ipv4-100629207-orig.png" title="ipv4-100629207-orig.png"></p>
<p>世界上大概有 40 亿个 IPv4 地址，迟早有一天这 40 亿个地址将都用完。但有了 SNI 以后，这个过程会慢很多，每个 IP 可以有多个服务器地址了。</p>
<p>最终所有的互联网将都使用 IPv 地址，这个版本下大概有 340 * 11^60 个地址，这个数字很大，大概可以够我们用很久了。</p>
<h1 id="SNI-的未来会怎样？"><a href="#SNI-的未来会怎样？" class="headerlink" title="SNI 的未来会怎样？"></a>SNI 的未来会怎样？</h1><p>SNI 最让人担心是它的可扩展性。起初，一些人认为 Web 浏览器和服务器得好久以后才会使用 SNI。</p>
<p>事实证明，这种担忧在很大程度上是毫无根据的。今天，根据 Akamai 统计，几乎 98% 的客户要求启用 HTTPS 的站点支持 SNI。</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>这篇文章讨论了这些点：</p>
<ul>
<li>什么是 SNI：Server Name Indication （服务端名称证明）允许在同一个 IP 地址上存在多个 SSL 证书</li>
<li>SNI 在 SSL 握手中插入 HTTP Header 从而让服务端觉得连接哪个网站</li>
<li>到 20171117 日为止，百分之 98 的用户要求 HTTPS 支持 SNI</li>
</ul>
<blockquote>
<p>翻译自<a href="https://www.thesslstore.com/blog/what-is-sni/" target="_blank" rel="noopener">https://www.thesslstore.com/blog/what-is-sni/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2019/05/06/593/" data-id="ck3heflp3001ky7sladujaqm1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-584" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/584/" class="article-date">
  <time datetime="2018-12-04T17:46:00.000Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/584/">微服务模式：Saga</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown--># 背景

<p>你已经应用了<a href="http://www.veitor.net/article/580.html">一个服务一个数据库</a>的模式，每个服务都有自己的数据库。但是一些事务需要跨服务，因此你需要一种机制来保证跨服务的数据一致性。假设你正在建设一个电子商城，客户有其信用额度。应用必须确保新订单不会超过该客户的可用额度限制。因为订单和客户信息在不同的数据库中，因此应用不能简单的使用ACID事务。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>如何处理跨服务的数据一致性问题？</p>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul>
<li>2PC不能用</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>将跨服务的事务实现为Saga。在Saga中每个本地事务更新数据库后并发布一个事件来触发下一个本地事务。如果一个本地事务因不符合业务规则而失败，则Saga将执行一系列修正事务，来撤销之前本地事务的修改。</p>
<p><img src="http://storage.veitor.net/2018/12/3652855247.jpg" alt="saga.jpg" title="saga.jpg"></p>
<p>实现Saga的两种方式：</p>
<ul>
<li>编排（Choreography）：每个本地事务发送领域事件来触发其他服务中的本地事务。</li>
<li>编制（Orchestration）：一个编制器（对象）告诉参与者该执行什么本地事务。</li>
</ul>
<h1 id="示例：基于编排的Saga模式"><a href="#示例：基于编排的Saga模式" class="headerlink" title="示例：基于编排的Saga模式"></a>示例：基于编排的Saga模式</h1><p><img src="http://storage.veitor.net/2018/12/2143801791.jpeg" alt="Saga_Choreography_Flow.001.jpeg" title="Saga_Choreography_Flow.001.jpeg"></p>
<p>使用基于编排Saga的电商程序在创建订单时包含以下步骤：</p>
<ol>
<li><code>订单服务</code>创建一个待确认状态的订单并且发布一个<code>OrderCreated</code>事件；</li>
<li><code>客户服务</code>接收到了该事件，并尝试去为该订单查询信用。它将发布一个<code>CreditReserved</code>事件或者<code>CreditLimitExcedded</code>事件。</li>
<li><code>订单服务</code>接收到事件后将改变订单状态为通过或取消。</li>
</ol>
<h1 id="示例：基于编制的Saga模式"><a href="#示例：基于编制的Saga模式" class="headerlink" title="示例：基于编制的Saga模式"></a>示例：基于编制的Saga模式</h1><p><img src="http://storage.veitor.net/2018/12/951589825.jpeg" alt="Saga_Orchestration_Flow.001.jpeg" title="Saga_Orchestration_Flow.001.jpeg"></p>
<p>使用基于编制Saga的电商程序在创建订单时包含以下步骤：</p>
<ol>
<li><code>订单服务</code>创建一个待确认状态的订单，同时创建了一个<code>CreateOrderSaga</code>；</li>
<li><code>CreateOrderSaga</code>发送一个<code>ReserveCredit</code>命令到客户服务；</li>
<li><code>客户服务</code>尝试为该订单查询信用并发送回复。</li>
<li><code>CreateOrderSaga</code>接受到回复后发送<code>ApproveOrder</code>或<code>RejectOrder</code>命令到订单服务；</li>
<li><code>订单服务</code>将订单状态修改为通过或取消。</li>
</ol>
<blockquote>
<p>基于编制的Saga又被称为<code>流程管理器(Process Manager)</code>，因为一个聚合状态的整个流程变化都由Saga来控制。如上步骤示例，可以看出Saga会对前一步骤创建出来的Event作出响应，所以基于编制的Saga流程管理又类似于Event Dispatcher，会分发和处理相应的领域事件。</p>
</blockquote>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>这模式有以下好处：</p>
<ul>
<li>它能让应用不使用分布式事务而实现跨服务的数据一致性。</li>
</ul>
<p>但也有以下缺点：</p>
<ul>
<li>编程模型会变得更复杂。开发者必须要设计修正事务来明确撤销之前在saga中做的改动。</li>
</ul>
<p>还有以下问题需要去解决：</p>
<ul>
<li>为了可靠性，一个服务必须以原子方式更新数据库和发布事件。它不能使用跨数据库和消息broker的分布式事务这种传统方式，相反，它必须使用下列模式中的一种。</li>
</ul>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li><p>一个服务一个数据库</p>
</li>
<li><p>以下模式是以原子更新状态和发布事件消息的：</p>
<ul>
<li>事件溯源（Event Sourcing）</li>
<li>应用事件（Application Event）</li>
</ul>
</li>
<li><p>一个基于编排的saga能使用聚合和领域事件发布事件。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/12/04/584/" data-id="ck3heflp0001gy7slhefkd497" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/" rel="tag">CQRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Sourcing/" rel="tag">Event Sourcing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-580" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/580/" class="article-date">
  <time datetime="2018-12-04T16:46:00.000Z" itemprop="datePublished">2018-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/580/">微服务模式：一个服务一个数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown--># 背景

<p>我们假设你正在使用微服务架构来开发一个在线商城应用。大多数服务需要用某种数据库来持久化数据，如：订单服务存储关于订单的数据，客户服务存储客户相关的数据。</p>
<p><img src="http://storage.veitor.net/2018/12/2942027767.png" alt="customersandorders.png" title="customersandorders.png"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>微服务中数据库架构是什么样的？</p>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><ul>
<li>服务之间必须松耦合，以使得每个服务可以独立开发、部署和扩展</li>
<li>一些业务事务必须保障跨多个服务的业务不变量。比如，<code>下单</code>这个用例将会验证新订单是否会超过顾客的信用额度限制。其他业务事务必须通过多个服务更新数据。</li>
<li>一些业务事务需要能查询分布在多个服务中的数据。比如，<code>查看可用的信用额度</code>必须要先查询客户再去查询其信用额度来计算下单的总额。</li>
<li>一些查询必须要join分布在多个服务中的数据。比如，查询某个地区的客户和他们的最近订单需要join客户服务数据和订单服务数据。</li>
<li>数据库必须能被复制和分库来实现扩展。见<a href="https://microservices.io/articles/scalecube.html" target="_blank" rel="noopener">伸缩立方(Scale Cube)</a></li>
<li>不同服务有不同数据存储要求。对于一些服务，关系数据库是一个好的选择。其他服务可能需要一个像MongoDB的NoSQL数据库，更适合存储复杂、无结构化的数据。</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>保持每个微服务的数据只对其服务访问，并且只能通过服务的API对外访问。一个服务的事务只涉及其对应的数据库。</p>
<p>下图展示了相关架构：</p>
<p><img src="http://storage.veitor.net/2018/12/2427239515.png" alt="databaseperservice.png" title="databaseperservice.png"></p>
<p>服务的数据库实际上是该服务实现的一部分，它不能被其它服务直接访问。</p>
<p>这有几种方式来保持服务的数据私有，你不需要为每个服务准备数据库。比如，如果你正在使用关系数据库，那么有这么几种选项：</p>
<ul>
<li>每个服务多个私有table：每个服务拥有一些只能被该服务访问的私有tables。</li>
<li>每个服务一个Schema：每个服务拥有一个只能被该服务访问的私有Schema。</li>
<li>每个服务一个Database：每个服务拥有一个Database Server。</li>
</ul>
<p>每个服务多个私有Table和每个服务一个Schema具有最低的开销，使用每个服务一个Schema更吸引人，因为这样会使得权限比较清晰。一些高吞吐量的服务可能需要他们自己的database server。</p>
<p>创建这种边界来使得模块化是一个好主意。这样以来你就可以为每个服务分配不同的数据库用户和数据库控制权限。如果没有这种边界，开发者将总会绕过服务的API来直接访问数据库获取数据。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>使用一个服务一个数据库有以下好处：</p>
<ul>
<li>确保服务之间松耦合，对一个服务数据库的更改不会影响到其他服务。</li>
<li>每个服务可以使用更适合的数据库类型。如做全文搜索的服务可以使用ElasticSearch。</li>
</ul>
<p>但也有以下缺点：</p>
<ul>
<li>实现跨多个服务的事务并不简单，由于CAP定理，最好避免分布式事务，而且许多流行数据库（如NoSQL）不支持分布式事务。最好的解决方案是使用Saga模式，当服务中的数据更新时发布一个事件，其他订阅了该事件的服务更新其数据来响应该事件。</li>
<li>实现在多个数据库join数据具有挑战性。</li>
<li>管理多个SQL和NoSQL数据库的复杂性。</li>
</ul>
<p>这也有几种方案：</p>
<ul>
<li>API组合：由应用程序实现join数据而不是数据库。假设一个服务要获取客户和他最近的订单，则先从客户服务获取该客户数据，再从订单服务查询获取该客户的最近订单信息。</li>
<li>命令查询职责分离(CQRS)：维护一个或多个来自其他服务的物化视图。服务订阅其他服务的事件，当其他服务发布事件时该服务再更新相关的物化视图。假设一个在线商城要实现查找特定区域的客户和他们最近的订单这个查询，只要通过维护一份join了客户信息和订单信息的物化视图就行了。该视图由该服务通过订阅客户服务和订单服务的事件来进行更新数据。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/12/04/580/" data-id="ck3heflow001dy7slgtmsh97w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/" rel="tag">CQRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ddd/" rel="tag">ddd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-577" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/577/" class="article-date">
  <time datetime="2018-12-04T00:11:00.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/577/">CQRS/ES架构下如何保证用户名的唯一性？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->CQRS/ES下，许多开发者不了解如何在系统中处理这样的场景：

<blockquote>
<p>在用户创建的时候，我们想要去验证用户名在数据库中是否是唯一的。我应该使用<code>Event Store</code>还是使用<code>读数据库</code>查询？我该在哪执行这个查询？</p>
</blockquote>
<p>这个问题是StackOverflow上与CQRS话题有关的最受关注的话题。因此在这篇文章中，我们将尝试针对这个问题寻找出最佳解决方案。</p>
<h1 id="方案1：在Command-Handler中使用Event-Store来验证"><a href="#方案1：在Command-Handler中使用Event-Store来验证" class="headerlink" title="方案1：在Command Handler中使用Event Store来验证"></a>方案1：在Command Handler中使用Event Store来验证</h1><p>我们假设在Command Handler中使用Event Store来对用户名进行验证。但是我们会有个问题，这样做会很低效，让我们来看一下为什么。想象一下你的聚合对象包含了100个事件，并且我们有将近5000个注册用户。每重构一遍这个聚合都需要先获取100个事件，则我们将获得100*5000 = 500000个事件，毫无疑问这个方案行不通。</p>
<h1 id="方案2：在Command-Handler中使用读数据库来验证"><a href="#方案2：在Command-Handler中使用读数据库来验证" class="headerlink" title="方案2：在Command Handler中使用读数据库来验证"></a>方案2：在Command Handler中使用读数据库来验证</h1><p>由于上述讨论Event Store不适合来做这项验证工作，那么我们使用<code>读数据库</code>在Command Handler中来验证。这样的验证查询非常简单：</p>
<pre><code>select * from user where username = :username;</code></pre><p>这看起来是一个好的办法，但还是有两点问题。首先，我们不应该在Command中使用Query，这违背了CQRS原则。其次，这方法不一定每次都能奏效，因为我们还需要处理两种数据库(<code>ES</code>和<code>读数据库</code>)之间的最终一致性问题。看一下下面的场景会发生什么问题：</p>
<p><img src="http://storage.veitor.net/2018/12/2253085505.png" alt="cqrs-diagram-1024x292.png" title="cqrs-diagram-1024x292.png"></p>
<p>假设有人创建了用户名为<code>TestUser</code>的帐号。他的command已经被发送到了command handler，并且一个对应的领域对象被创建出来，随后一个<code>UserCreatedEvent</code>事件被保存到Event Store中。该事件需要通过事件总线来同步到<code>读数据库</code>。但此时事件总线中正在处理另一个用户名同样是<code>TestUser</code>的帐号创建事件，并且通过<code>读数据库</code>查询该用户名是不存在的，因此这个事件可以被最终同步到<code>读数据库</code>中去。然而后一个事件如果也被事件总线同步的话，就无法保证用户名的唯一性了，所以我们还需要再考虑一下其他方案。</p>
<h1 id="方案3：客户端验证"><a href="#方案3：客户端验证" class="headerlink" title="方案3：客户端验证"></a>方案3：客户端验证</h1><p>这个方案是客户端验证。我们通过从客户端发起Http请求作为query去查询用户名是否已经存在，如果存在则可以给出提示给用户。如果不存在，则再发起一个创建用户的请求作为command来创建用户。这样看起来不错，但也存在缺陷。这仅仅是客户端验证，它也会因为最终一致性问题而失败，但我们可以大致遵循这个思路继续往下想。</p>
<h1 id="方案4：客户端验证-Saga模式"><a href="#方案4：客户端验证-Saga模式" class="headerlink" title="方案4：客户端验证+Saga模式"></a>方案4：客户端验证+Saga模式</h1><p>你可能会想，客户端验证方案刚才不是说过也会偶尔失败吗？为什么还要继续用，因为这个失败率比较低，并且我们将会在服务端也做个保障措施。我们知道Event Store的数据存储结构并不适合做这样的唯一性验证，所以我们就需要使用<code>读数据库</code>。但是我们也知道由于CQRS原因我们不能在command中使用query去查询<code>读数据库</code>。所以我们接下来这么做，我们给<code>读数据库</code>增加一个用户名唯一性约束，这样的话当插入一个已经存在的用户名帐号时会抛出一个异常。很好，但这有另一个问题！在对<code>读数据库</code>插入已经存在的用户名帐号前，我们已经在Event Store中存储了对应的事件。所以我们应该删掉那个事件，因为查询时抛出了异常？但是，要记住请不要删除事件！我们不能去做删除事件这样的操作，因为Event Sourcing的思想就是要记录下所有对象状态变化的完整历史。我们所需要去做的应该是去创建一个<code>UserCreationCanceledEvent</code>事件，并且在我们聚合中增加一些逻辑以使得这种创建失败情况下不再重新构建出聚合对象。这看起来似乎很有道理，但我们需要去创建合适的事件。怎么建？这正是Saga派上用场的时候了。我们考虑一下这样的时间序列图：</p>
<p><img src="http://storage.veitor.net/2018/12/4201905302.png" alt="sq-diagram-1024x730.png" title="sq-diagram-1024x730.png"></p>
<p>这图可能看起来较为复杂，实际上并不是。我们所需要理解的是Saga的职责。如果创建用户失败了，我们把这个创建用户事件传给Saga。随后，随后一个修正命令会被发往command bus去创建一个<code>UserCreationCanceledEvent</code>事件，然后该事件将被存储到Event Store中。就这些步骤就行了。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>我希望这篇文章能够帮到需要的人嗯。如果你有其他能保证用户名唯一性的好办法也可以在下面评论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/12/04/577/" data-id="ck3heflou001ay7sldc0n7op3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/" rel="tag">CQRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Sourcing/" rel="tag">Event Sourcing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Store/" rel="tag">Event Store</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ddd/" rel="tag">ddd</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-576" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/15/576/" class="article-date">
  <time datetime="2018-08-15T21:53:31.000Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/576/">编程中的hydration是什么意思</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->经常能看到在一些书本和文章中写到`hydration`，这一单词单独去翻译为“水合”、“水合作用”等，但放在文章中又似乎读不同，难以理解。

<p>通过查阅了更多的信息之后，<code>hydration</code>的大致意思基本了解了。</p>
<p>可以理解为对象提供水分，为什么对象呢？就是刚实例化的对象。并且我们最常见提到“水合”的地方就是刚从数据库或其他存储介质中取出数据填充到对象上。</p>
<p>那么这种一个已经在内存中实例化的对象，还没有包含任何数据，然后用数据（例如从数据库、网络、文件系统等获取的）填充到该对象内，这种行为成为<code>hydration</code>水合。</p>
<p>常见的一种水合方式就是序列化和反序列化了，如在PHP中对对象进行<code>serialize</code>和<code>unserialize</code>，此时的<code>反序列化==实例化+水合</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/08/15/576/" data-id="ck3heflos0018y7sl7o647znp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-573" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/573/" class="article-date">
  <time datetime="2018-08-02T17:01:35.000Z" itemprop="datePublished">2018-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/573/">单表继承（Single Table Inheritance）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->_将类的继承层次表示为单张数据表，这张表内含有每个类的所有字段_

<p><img src="http://storage.veitor.net/2018/08/2552666952.gif" alt="classInheritanceTableSketch.gif" title="classInheritanceTableSketch.gif"></p>
<p>关系数据库不支持继承，当对象映射到数据库时，我们必须考虑如何在关系数据表中良好的展示我们的对象继承结构。当对象映射到关系数据库时，在多张表中处理继承结构过程中，我们尝试着去尽量减少迅速增加的join查询。（参考<a href="http://www.veitor.net/article/571.html">类表查询</a>）。<code>单表继承</code>将所有类的继承结构的所有字段映射到了一张表中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/08/02/573/" data-id="ck3hefloq0015y7slh53o6j9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-571" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/571/" class="article-date">
  <time datetime="2018-08-02T16:52:44.000Z" itemprop="datePublished">2018-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/571/">类表继承（Class Table Inheritance）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->_表示类的继承层次结构，每个类都对应一张数据表_  
<p><img src="http://storage.veitor.net/2018/08/2165706583.gif" alt="classInheritanceTableSketch.gif" title="classInheritanceTableSketch.gif"></p>
<p>对象关系阻抗不匹配的一个显著方面是由于关系数据库不支持继承。你想要数据库结构能够清晰的映射到对象，并想要在继承结构中可以任意链接。<code>类表继承</code>通过使用一个数据表对应一个类的方式来实现这样的目的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/08/02/571/" data-id="ck3heflop0011y7sl2l8mcje5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-553" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/19/553/" class="article-date">
  <time datetime="2018-04-19T05:27:00.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/19/553/">[译]架构风格 - 《Domain-Driven Design in PHP》第2章</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->> 本篇博文由本博客(`http://www.veitor.net`)经原文翻译，转载请注明出处。

<p>为了能够构建一个复杂的应用程序，其中一个关键点就是需要有一个适合该程序的架构设计。领域驱动设计的一个优势就是它不受任何架构风格的约束。相反，我们可以自由的去为核心领域内的每一个限界上下文选择最合适的架构，为每一个领域问题提供多种架构选择。</p>
<p>例如，订单处理系统可以使用事件溯源(Event Sourcing)去追踪所有不同订单的操作；一个产品目录系统能够使用CQRS去将产品详情展示给不同客户端；一个内容管理系统能使用六边形架构(Hexagonal Architecture)来展示如博客、静态页等需求。</p>
<p>本章将介绍PHP相关的每种架构风格，从传统PHP代码演变为复杂的架构。请注意虽然还有很多其他现有的架构如Data Fabric和SOA，我们发现他们其中一些从PHP角度来介绍太过于复杂。</p>
<h2 id="曾经的美好时光"><a href="#曾经的美好时光" class="headerlink" title="曾经的美好时光"></a>曾经的美好时光</h2><p>在PHP4发布之前，该语言还不支持面向对象。那时，写程序的通用做法是使用过程式编程和全局状态。在PHP社区中像关注点分离(Separation of Concerns,SoC)和MVC这些概念还是比较陌生的。</p>
<p>下面的例子是以这种传统方式编写的应用程序，由许多与HTML代码混合的前端控制器组成。在这时，基础设施、UI和领域层代码混在一起：</p>
<pre><code>&lt;?php
include __DIR__ . &apos;/bootstrap.php&apos;;
$link = mysql_connect(&apos;localhost&apos;, &apos;a_username&apos;, &apos;4_p4ssw0rd&apos;);
if (!$link) {
    die(&apos;Could not connect: &apos; . mysql_error());
}
mysql_set_charset(&apos;utf8&apos;, $link);
mysql_select_db(&apos;my_database&apos;, $link);
$errormsg = null;
if (isset($_POST[&apos;submit&apos;] &amp;&amp; isValid($_POST[&apos;post&apos;])) {
    $post = getFrom($_POST[&apos;post&apos;]);
    mysql_query(&apos;START TRANSACTION&apos;, $link);
    $sql = sprintf(&quot;INSERT INTO posts (title, content) VALUES (&apos;%s&apos;,&apos;%s&apos;)&quot;, mysql_real_escape_string($post[&apos;title&apos;]), mysql_real_escape_string($post[&apos;content&apos;]));
    $result = mysql_query($sql, $link);
    if ($result) {
        mysql_query(&apos;COMMIT&apos;, $link);
    } else {
        mysql_query(&apos;ROLLBACK&apos;, $link);
        $errormsg = &apos;Post could not be created! :(&apos;;
    }
}
$result = mysql_query(&apos;SELECT id, title, content FROM posts&apos;, $link);
?&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;?php if (null !== $errormsg): ?&gt;
&lt;div class=&quot;alert error&quot;&gt;&lt;?php echo $errormsg; ?&gt;&lt;/div&gt;
&lt;?php
else: ?&gt;
&lt;div class=&quot;alert success&quot;&gt;
Bravo! Post was created successfully!
&lt;/div&gt;
&lt;?php
endif; ?&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;TITLE&lt;/th&gt;
&lt;th&gt;ACTIONS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php while ($post = mysql_fetch_assoc($result)): ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $post[&apos;id&apos;]; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $post[&apos;title&apos;]; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php editPostUrl($post[&apos;id&apos;]); ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php
endwhile; ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?php mysql_close($link); ?&gt;</code></pre><p>这种编码方式通常被称为第1章中提到的“大泥球”。然而，这种风格改进似乎是将网页头部和底部封装到各自的文件中，然后在该页面中再引入进来。这就避免了重复劳动并且能有效复用。</p>
<pre><code>&lt;?php
include __DIR__ . &apos;/bootstrap.php&apos;;
$link = mysql_connect(&apos;localhost&apos;, &apos;a_username&apos;, &apos;4_p4ssw0rd&apos;);
if (!$link) {
    die(&apos;Could not connect: &apos; . mysql_error());
}
mysql_set_charset(&apos;utf8&apos;, $link);
mysql_select_db(&apos;my_database&apos;, $link);
$errormsg = null;
if (isset($_POST[&apos;submit&apos;] &amp;&amp; isValid($_POST[&apos;post&apos;])) {
    $post = getFrom($_POST[&apos;post&apos;]);
    mysql_query(&apos;START TRANSACTION&apos;, $link);
    $sql = sprintf(&quot;INSERT INTO posts(title, content) VALUES(&apos;%s&apos;,&apos;%s&apos;)&quot;, mysql_real_escape_string($post[&apos;title&apos;]), mysql_real_escape_string($post[&apos;content&apos;]));
    $result = mysql_query($sql, $link);
    if ($result) {
        mysql_query(&apos;COMMIT&apos;, $link);
    } else {
        mysql_query(&apos;ROLLBACK&apos;, $link);
        $errormsg = &apos;Post could not be created! :(&apos;;
    }
    $result = mysql_query(&apos;SELECT id, title, content FROM posts&apos;, $link);
?&gt;
&lt;?php include __DIR__ . &apos;/header.php&apos;; ?&gt;
&lt;?php if (null !== $errormsg): ?&gt;
&lt;div class=&quot;alert error&quot;&gt;&lt;?php echo $errormsg; ?&gt;&lt;/div&gt;
&lt;?php
    else: ?&gt;
&lt;div class=&quot;alert success&quot;&gt;
Bravo! Post was created successfully!
&lt;/div&gt;
&lt;?php
    endif; ?&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;TITLE&lt;/th&gt;
&lt;th&gt;ACTIONS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;?php while ($post = mysql_fetch_assoc($result)): ?&gt;
&lt;tr&gt;
&lt;td&gt;&lt;?php echo $post[&apos;id&apos;]; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $post[&apos;title&apos;]; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php editPostUrl($post[&apos;id&apos;]); ?&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;?php
    endwhile; ?&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;?php include __DIR__ . &apos;/footer.php&apos;; ?&gt;</code></pre><p>如今，尽管这样非常的不推荐，但仍然有这种过程式编程的程序存在。这种架构风格的主要缺点就是没有做到关注点分离，用这种方式开发的程序在维护成本上比我们现在所知道并经过验证的架构高多了。</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>从代码可维护性和复用性角度来看，让代码更容易维护的最好方法就是分解概念，也就是为每个不同的关注点创建一个层。在我们前面的例子中，很容易形成不同的分层：一个用于封装数据访问和操作，另一个处理基础设施问题，还有最后一个负责前两者的协调调用。分层架构的一个基本规则就是每一层必须与其下一层紧密耦合，如下图所示：</p>
<p><img src="http://storage.veitor.net/2018/04/1535675639.jpg" alt="QQ截图20180419221418.jpg" title="QQ截图20180419221418.jpg"></p>
<p>分层架构真正寻求的是分离应用程序的不同组件。比如前一个例子，一篇博文的展现必须与这篇博文的概念实体完全分离。一个博文实体可以与多个展现相关联，而不是与特定的展现紧耦合。这通常被称为关注点分离(Separation of Concerns)。</p>
<p>另一个寻求相同目的的架构模式是MVC模式。它最初被认为广泛用于构建桌面GUI应用程序的，现在主要用于web应用程序，这要归功于像Symfony、Yii、CodeIgniter等这样的流行web框架。</p>
<h3 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h3><p>MVC架构模式将应用分成了3层，具体描述如下：</p>
<ul>
<li>模型(Model)：捕获和集中所有领域模型的行为。这一层独立于数据展示，来管理所有的数据、逻辑和业务规则。模型层被称为是MVC应用的灵魂与核心。</li>
<li>控制器(Controller)：协调其他层的交互，触发模型上的动作来更改模型的状态，并且刷新与该模型关联的展现。除此之外，控制器可以将消息发送到是视图层来更改指定模型的展示。</li>
<li>视图(View)：将模型层的不同展示表现出来，并且提供一个方式去改变模型状态。<br><img src="http://storage.veitor.net/2018/04/3390319868.jpg" alt="QQ截图20180419224352.jpg" title="QQ截图20180419224352.jpg"></li>
</ul>
<h3 id="分层架构示例"><a href="#分层架构示例" class="headerlink" title="分层架构示例"></a>分层架构示例</h3><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>继续前面的例子，我们提到不同关注点应该被分离。为了做到这一点，所有的层应该在我们杂乱的代码中进行确定。在这过程中，我们需要特别注意符合我们模型层的代码，其将成为我们应用的核心。</p>
<pre><code>&lt;?php
class Post {
    private $title;
    private $content;
    public static function writeNewFrom($title, $content) {
        return new static($title, $content);
    }
    private function __construct($title, $content) {
        $this-&gt;setTitle($title);
        $this-&gt;setContent($content);
    }
    private function setTitle($title) {
        if (empty($title)) {
            throw new RuntimeException(&apos;Title cannot be empty&apos;);
        }
        $this-&gt;title = $title;
    }
    private function setContent($content) {
        if (empty($content)) {
            throw new RuntimeException(&apos;Content cannot be empty&apos;);
        }
        $this-&gt;content = $content;
    }
}
class PostRepository {
    private $db;
    public function __construct() {
        $this-&gt;db = new PDO(
            &apos;mysql:host=localhost;dbname=my_database&apos;,
            &apos;a_username&apos;,
            &apos;4_p4ssw0rd&apos;,
            [
                PDO::MYSQL_ATTR_INIT_COMMAND =&gt;
                                &apos;SET NAMES utf8mb4&apos;
            ]
        );
    }
    public function add(Post $post) {
        $this-&gt;db-&gt;beginTransaction();
        try {
            $stm = $this-&gt;db-&gt;prepare(
                  &apos;INSERT INTO posts (title, content) VALUES (?, ?)&apos;
            );
            $stm-&gt;execute([
                $post-&gt;title(),
                $post-&gt;content()
            ]);
            $this-&gt;db-&gt;commit();
        } catch (Exception $e) {
            $this-&gt;db-&gt;rollback();
            throw new UnableToCreatePostException($e);
        }
    }
}</code></pre><p>模型层现在已经由<code>Post</code>类和<code>PostRepository</code>类来定义。<code>Post</code>类代表一篇博文，<code>PostRepository</code>类代表整个博文的集合。另外，模型内部还需要另一个层（协调和编排领域模型行为的层）。进入应用层(Application Layer)：</p>
<pre><code>&lt;?php
class PostService {
    public function createPost($title, $content) {
        $post = Post::writeNewFrom($title, $content);
        (new PostRepository())-&gt;add($post);
        return $post;
    }
}</code></pre><p><code>PostService</code>类是所谓的应用服务(Application Service)，它的目的是协调和编排领域行为。换句话说，Application Service是让事情发生的东西，它是领域模型的直接客户端。没有其他对象类型能够直接与模型层的内部层进行交流。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图层可以同时从模型层或者控制器层发送和接收消息。它的主要目的是在UI层面将模型展示给用户，而且每次模型更新它都将刷新UI展示。一般来说，视图层接收一个对象（通常是数据转换对象,Data Transfer Object,DTO）而不是模型层的实例对象，从而将收集到所需的信息成功展示。对于PHP，这有一些模板引擎能够很好的帮助将模型展示与模型和控制器分离，目前较流行的是<code>Twig</code>。让我们看一下使用Twig的视图层是怎么样的。</p>
<blockquote>
<p>使用DTO而不是模型实例？<br>这是一个旧的活跃话题。为什么是创建一个DTO而不是直接将模型实例对象给视图层？主要原因和简要的回答还是：关注点分离。让视图检查和使用模型实例将导致视图层和模型层的紧耦合。事实上，模型层的一个改动可能将影响所有使用该模型实例的视图。</p>
</blockquote>
<pre><code>{% extends "base.html.twig" %} {% block content %} {% if errormsg is defined %}
    <div class="alert error">{ { errormsg }}</div>
    {% else %}
    <div class="alert success">
      Bravo! Post was created successfully!
    </div>
    {% endif %}
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>TITLE</th>
          <th>ACTIONS</th>
        </tr>
      </thead>
      <tbody>
        {% for post in posts %}
        <tr>
          <td>{ { post.id }}</td>
          <td>{ { post.title }}</td>
          <td><a href="{ { editPostUrl(post.id) }}">Edit Post</a></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
    {% endblock %}</code></pre><p>大多数时间，当模型触发更改状态时，它也会通知相关的视图刷新UI。在典型的web场景中，由于客户端和服务端的特性，模型和其展示在同步变化时有些困难。在这类环境中，一些javascript定义的交互需要来维持这种同步变化，所以像下面的几个javascript的MVC框架近几年开始流行起来：</p>
<ul>
<li>AngularJS</li>
<li>Ember.ks</li>
<li>Marionette.js</li>
<li>React</li>
</ul>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>控制器负责组织和协调视图和模型，它从视图层接收信息并触发模型的行为来做一些需要的操作。此外，它还发送信息到视图层以展示模型。这两个操作都由应用层来执行，应用层负责编排、组织和封装领域行为。</p>
<p>就PHP中的web程序而言，控制器通常会被理解成一组class类来实现其目的。它们接收HTTP请求并返回一个HTTP响应。</p>
<pre><code>&lt;?php
class PostsController {
    public function updateAction(Request $request) {
        if ($request-&gt;request-&gt;has(&apos;submit&apos;) &amp;&amp; Validator::validate($request-&gt;request-&gt;post)) {
            $postService = new PostService();
            try {
                $postService-&gt;createPost($request-&gt;request-&gt;get(&apos;title&apos;), $request-&gt;request-&gt;get(&apos;content&apos;));
                $this-&gt;addFlash(&apos;notice&apos;, &apos;Post has been created successfully!&apos;);
            }
            catch(Exception $e) {
                $this-&gt;addFlash(&apos;error&apos;, &apos;Unable to create the post!&apos;);
            }
        }
        return $this-&gt;render(&apos;posts/update-result.html.twig&apos;);
    }
}</code></pre><h3 id="反转依赖：六边形架构"><a href="#反转依赖：六边形架构" class="headerlink" title="反转依赖：六边形架构"></a>反转依赖：六边形架构</h3><p>遵循分层架构的基本规则，在实现包含基础设施的领域接口(interface)时会存在风险。</p>
<p>例如，在MVC中，前一个例子中的PostRepository类应该放在领域模型中。但是，直接将基础设施细节部分放在领域中会违反关注点分离原则，这是有问题的；很难去避免违反分层架构的基本规则，那将导致领域过多的了解到技术实现的部分，使得代码难以测试。</p>
<h4 id="依赖倒置原则（The-Dependency-Inversion-Principle，DIP）"><a href="#依赖倒置原则（The-Dependency-Inversion-Principle，DIP）" class="headerlink" title="依赖倒置原则（The Dependency Inversion Principle，DIP）"></a>依赖倒置原则（The Dependency Inversion Principle，DIP）</h4><p>我们如何去处理刚才的问题？由于领域模型层依赖于具体的基础设施实现，所以可以通过将基础设施层放到其他三个层之上，这样就用上了依赖倒置原则。</p>
<blockquote>
<p>依赖倒置原则<br>高级模块不应该依赖于低级模块，两者都应该依赖于抽象。<br>抽象不应该依赖于细节，细节也不应该依赖于抽象。</p>
</blockquote>
<p>通过使用依赖倒置原则，架构体系将发生改变，基础设施层（可称之为低级模块）现在依赖于视图UI层，应用层和领域层（这些是高级模块）。依赖性已经被倒置过来。</p>
<p>但什么是六边形架构？六边形架构（也称之为端口和适配器）由Alistair Cockburn在他的<a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank" rel="noopener">《六边形架构》</a>一书中定义。六边形架构将应用程序描述为六边形，其中每一个边都代表带有一个或多个适配器的端口（译者注：原文单词为Port），一个端口是一个带有可插入适配器的连接器，该连接器将外部输入信息转换成应用程序可以理解的内部信息。就DIP而言，一个端口将是一个高级模块，一个适配器将是一个低级模块。此外，如果应用程序需要将消息发送到外部，将使用带有适配器的端口来发送，并将信息转换为外部可理解的内容。因此，六边形架构在应用中提出了对称性的概念，这也是架构体系发生改变的主要原因。该架构通常被表示为六边形，因为谈论顶层和底层将不再具有意义，而是主要谈论外部和内部。</p>
<h4 id="应用六边形架构"><a href="#应用六边形架构" class="headerlink" title="应用六边形架构"></a>应用六边形架构</h4><p>继续使用博客的例子，我们需要的第一个概念是外部与应用程序交流的端口。在这种情况下，我们将使用HTTP端口和对应的适配器，外部将使用该端口给应用程序发送信息。博客示例使用数据库来存储所有博客文章的集合，为了允许应用程序能从数据库检索文章，需要这么一个端口：</p>
<pre><code>interface PostRepository
{
  public function byId(PostId $id);
  public function add(Post $post);
}</code></pre><p>这个接口(interface)告诉了我们一个端口，应用程序将通过该端口获取博文信息，并且将该端口放置在了领域层，现在需要一个该端口的适配器。适配器负责使用特定技术来检索博文。</p>
<pre><code>&lt;?php
class PDOPostRepository implements PostRepository {
    private $db;
    public function __construct(PDO $db) {
        $this-&gt;db = $db;
    }
    public function byId(PostId $id) {
        $stm = $this-&gt;db-&gt;prepare(&apos;SELECT * FROM posts WHERE id = ?&apos;);
        $stm-&gt;execute([$id-&gt;id() ]);
        return recreateFrom($stm-&gt;fetch());
    }
    public function add(Post $post) {
        $stm = $this-&gt;db-&gt;prepare(&apos;INSERT INTO posts (title, content) VALUES (?, ?)&apos;);
        $stm-&gt;execute([$post-&gt;title(), $post-&gt;content(), ]);
    }
}</code></pre><p>一旦我们有了端口和对应的适配器，最后一步就是重构PostService来使用它们。通过依赖注入可以轻松的获得到：</p>
<pre><code>&lt;?php
class PostService {
    private $postRepository;
    public function __construct(PostRepositor $postRepository) {
        $this-&gt;postRepository = $postRepository;
    }
    public function createPost($title, $content) {
        $post = Post::writeNewFrom($title, $content);
        $this-&gt;postRepository-&gt;add($post);
        return $post;
    }
}</code></pre><p>这只是六边形架构的一个简单例子，这是一个灵活的架构，可以促进关注点的分离。由于通过端口，内部应用程序可以与外部通信，因此六边形架构还促进了对称性。从现在开始，我们将使用这个架构作为基础架构，来继续解释CQRS和事件溯源。</p>
<p>关于更多该架构的示例，你可以查看附录（译者注：暂无链接，后期会添加上）。有关更详细的示例，你应该跳到第11章应用程序(Application Service)，这一章解释了事务性和其他横切关注点等高级话题。</p>
<h3 id="命令查询责任分离（Command-Query-Responsibility-Segregation，CQRS）"><a href="#命令查询责任分离（Command-Query-Responsibility-Segregation，CQRS）" class="headerlink" title="命令查询责任分离（Command Query Responsibility Segregation，CQRS）"></a>命令查询责任分离（Command Query Responsibility Segregation，CQRS）</h3><p>六边形架构是一个很好的基础架构，但是也有一些局限性。例如，复杂的用户UI界面可能需要以多种形式来展示聚合信息（第8章，聚合），或者需要从多个聚合获取数据。在这种情况下，我们可能在仓储类中有很多finder方法（可能与UI界面一样多）。或者我们可能决定将这种复杂性的东西放到应用服务中，使用复杂结构来从多个聚合聚集所需要的数据。以下是一个示例：</p>
<pre><code>&lt;?php
interface PostRepository
{
    public function save(Post $post);
    public function byId(PostId $id);
    public function all();
    public function byCategory(CategoryId $categoryId);
    public function byTag(TagId $tagId);
    public function withComments(PostId $id);
    public function groupedByMonth();
// ...
}</code></pre><p>当这些技术被滥用时，UI视图的构建会变的相当痛苦。我们是让应用服务直接返回领域模型实例还是返回一类DTO？对此该做一些权衡。如果是后者，我们避免领域模型与基础设施代码（web控制器、命令行控制器等）的紧密耦合。</p>
<p>幸运的是，我们还有另一种方法。如果有多个并且不同的视图，我们将其从领域模型中去除，并看做是基础设施问题。命令查询分离(CQS)是一个基于设计原则的可选项，由Bertrand Meyer定义的，并且这催生了一个新的架构模式，称之为命令查询责任分离(CQRS)，由Greg Young定义。</p>
<blockquote>
<p>命令查询分离（Command Query Separation, CQS）<br>这个设计原则规定，每个方法应该是执行操作的命令，或者是一个返回数据给调用者的查询。不能同时是这两种。</p>
</blockquote>
<p>CQRS寻求一个更严格的关注点分离，将模型分为了两部分：</p>
<ul>
<li>_写模型_：也被称为_命令模型_，它负责写入并对真正的领域行为负责。</li>
<li>_读模型_：它负责在应用中的读取内容，并将这些内容认为是领域模型外的。</li>
</ul>
<p>每当有人触发写模型的命令时，就会执行写入数据的操作。此外，这还将触发读模型的更新，为了在读模型上展示最新的更改。</p>
<p>严格的分离将导致另一个问题：最终一致性。读模型的一致性受写模型命令的影响，换句话说，读模型是最终一致性。也就是当每一次的写模型执行一个命令，它将根据最新的更改拉起一个过程来负责更新读模型，这就将有一段时间内，用户UI界面是展示的旧的信息，这经常发生，因为我们受当前技术的限制。</p>
<p>思考一下web应用的缓存系统，每当数据库更新了新的信息，缓存里的数据可能还是旧的，所以每当数据更新，将有一个更新缓存的过程，缓存系统是最终一致性的。</p>
<p>这一类过程用CQRS术语来说就是写模型投影，或者叫投影。我们将写模型投影到读模型上，这个过程可以是同步的也可以是异步的，取决于你的需求。这将归功于另一个有用的战术设计模式——领域事件(Domain Events)，本书稍后将做详细解释。写模型投影的基础是收集所有已经发布的领域事件，并使用来自这些事件中的信息去更新读模型。</p>
<h4 id="写模型"><a href="#写模型" class="headerlink" title="写模型"></a>写模型</h4><p>这是领域行为真正的持有者。继续我们的例子，Repository接口将被简化为：</p>
<pre><code>&lt;?php
interface PostRepository
{
    public function save(Post $post);
    public function byId(PostId $id);
}</code></pre><p><code>byId</code>方法负责通过id加载聚合以便能操作该聚合，除了这个方法之外，现在PostRepository类已经从所有的读取问题中解放出来了。一旦这个完成了，所有的查询方法也从Post模型中剥离了出来，只留下了命令方法，这意味着我们有效的摆脱了所有关于获取Post获取数据的方法。相反的，通过订阅领域事件，当事件发生时将会触发写模型投影。</p>
<pre><code>&lt;?php
class AggregateRoot
{
    private $recordedEvents = [];
    protected function recordApplyAndPublishThat(DomainEvent $domainEvent)
    {
        $this-&gt;recordThat($domainEvent);
        $this-&gt;applyThat($domainEvent);
        $this-&gt;publishThat($domainEvent);
    }
    protected function recordThat(DomainEvent $domainEvent)
    {
        $this-&gt;recordedEvents[] = $domainEvent;
    }
    protected function applyThat(DomainEvent $domainEvent)
    {
        $modifier = &apos;apply&apos; . get_class($domainEvent);
        $this-&gt;{$modifier}($domainEvent);
    }
    protected function publishThat(DomainEvent $domainEvent)
    {
        DomainEventPublisher::getInstance()-&gt;publish($domainEvent);
    }
    public function recordedEvents()
    {
        return $this-&gt;recordedEvents;
    }
    public function clearEvents()
    {
        $this-&gt;recordedEvents = [];
    }
}
class Post extends AggregateRoot
{
    private $id;
    private $title;
    private $content;
    private $published = false;
    private $categories;
    private function __construct(PostId $id)
    {
        $this-&gt;id = $id;
        $this-&gt;categories = new Collection();
    }
    public static function writeNewFrom($title, $content)
    {
        $postId = PostId::create();
        $post = new static($postId);
        $post-&gt;recordApplyAndPublishThat(new PostWasCreated($postId, $title, $content));
    }
    public function publish()
    {
        $this-&gt;recordApplyAndPublishThat(new PostWasPublished($this-&gt;id));
    }
    public function categorizeIn(CategoryId $categoryId)
    {
        $this-&gt;recordApplyAndPublishThat(new PostWasCategorized($this-&gt;id, $categoryId));
    }
    public function changeContentFor($newContent)
    {
        $this-&gt;recordApplyAndPublishThat(new PostContentWasChanged($this-&gt;id, $newContent));
    }
    public function changeTitleFor($newTitle)
    {
        $this-&gt;recordApplyAndPublishThat(new PostTitleWasChanged($this-&gt;id, $newTitle));
    }
}</code></pre><p>所有触发状态改变的动作都是通过领域事件来实现的，对于每一个发布的领域事件，都有一个方法来反映出状态的改变。</p>
<pre><code>&lt;?php
class Post extends AggregateRoot
{
    // ...
    protected function applyPostWasCreated(PostWasCreated $event)
    {
        $this-&gt;id = $event-&gt;id();
        $this-&gt;title = $event-&gt;title();
        $this-&gt;content = $event-&gt;content();
    }
    protected function applyPostWasPublished(PostWasPublished $event)
    {
        $this-&gt;published = true;
    }
    protected function applyPostWasCategorized(PostWasCategorized $event)
    {
        $this-&gt;categories-&gt;add($event-&gt;categoryId());
    }
    protected function applyPostContentWasChanged(PostContentWasChanged $event)
    {
        $this-&gt;content = $event-&gt;content();
    }
    protected function applyPostTitleWasChanged(PostTitleWasChanged $event)
    {
        $this-&gt;title = $event-&gt;title();
    }
}</code></pre><h4 id="读模型"><a href="#读模型" class="headerlink" title="读模型"></a>读模型</h4><p>读模型也被称为查询模型，是脱离领域的反规范化(<a href="https://searchdatabase.techtarget.com.cn/whatis/7-22567/" target="_blank" rel="noopener">denormalized</a>)的数据模型。事实上，对于CQRS，所有的读取问题都被视为报告过程，一个基础设施问题。一般来说，当使用CQRS，读取模型需要满足UI界面的需求和视图混合的复杂度。在根据关系数据库定义读模型的情况下，最简单的方法是在数据库表和UI视图之间设置一对一的关系，其他写入的地方会发布领域事件，触发使用写入模型投影来更新数据表和UI视图。</p>
<pre><code>-- 带有评论的单篇博文的视图的定义
-- Definition of a UI view of a single post with its comments
CREATE TABLE single_post_with_comments (
    id INTEGER NOT NULL,
    post_id INTEGER NOT NULL,
    post_title VARCHAR(100) NOT NULL,
    post_content TEXT NOT NULL,
    post_created_at DATETIME NOT NULL,
    comment_content TEXT NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
-- Set up some data
INSERT INTO single_post_with_comments VALUES
    (1, 1, &quot;Layered&quot; , &quot;Some content&quot;, NOW(), &quot;A comment&quot;),
    (2, 1, &quot;Layered&quot; , &quot;Some content&quot;, NOW(), &quot;The comment&quot;),
    (3, 2, &quot;Hexagonal&quot; , &quot;Some content&quot;, NOW(), &quot;No comment&quot;),
    (4, 2, &quot;Hexagonal&quot;, &quot;Some content&quot;, NOW(), &quot;All comments&quot;),
    (5, 3, &quot;CQRS&quot;, &quot;Some content&quot;, NOW(), &quot;This comment&quot;),
    (6, 3, &quot;CQRS&quot;, &quot;Some content&quot;, NOW(), &quot;That comment&quot;);
-- Query it
SELECT * FROM single_post_with_comments WHERE post_id = 1;</code></pre><p>这种结构风格的一个重要特征是，由于应用程序的状态被写模型处理了，所以使用读模型完全是一次性的。这意味着读模型能被需要时使用写模型投影来移除和重建。</p>
<p>在这里，我们可以博客程序中看到一些可能的视图示例：</p>
<pre><code>SELECT * FROM
    posts_grouped_by_month_and_year
ORDER BY month DESC,year ASC;
SELECT * FROM
    posts_by_tags
WHERE tag = &quot;ddd&quot;;
SELECT * FROM
    posts_by_author
WHERE author_id = 1;</code></pre><p>需要重点指出的是，CQRS不会强制将读模型的定义与其实现限制为关系数据库。它完全取决于你程序的需求，可以是使用关系数据库、面向文档的数据库、key-value键值对数据库以及任何适合你程序的数据库。继续博客程序，我们将使用Elasticsearch（一个面向文档的数据库）来实现读模型。</p>
<pre><code>&lt;?php
class PostsController {
    public function listAction() {
        $client = new ElasticsearchClientBuilder::create()-&gt;build();
        $response = $client-&gt;search([&apos;index&apos; =&gt; &apos;blog-engine&apos;, &apos;type&apos; =&gt; &apos;posts&apos;, &apos;body&apos; =&gt; [&apos;sort&apos; =&gt; [&apos;created_at&apos; =&gt; [&apos;order&apos; =&gt; &apos;desc&apos;]]]]);
        return [&apos;posts&apos; =&gt; $response];
    }
}</code></pre><p>读模型的代码已经针对Elasticsearch单个索引彻底的简化了。</p>
<p>这表明了读模型不需要一个对象关系映射器(ORM)，但是，写模型可能会从对象关系映射器的使用中获得好处，因为这将允许你根据程序的需求来组织和构建读模型。</p>
<h4 id="同步写模型和读模型"><a href="#同步写模型和读模型" class="headerlink" title="同步写模型和读模型"></a>同步写模型和读模型</h4><p>棘手的部分来了，我们怎么将读模型和写模型同步？我们已经说过，我们将使用获取的领域事件来完成同步。对于每一个获取的领域事件，一个特定的投影将被执行。所以领域事件和投影之间存在一对一的关系。</p>
<p>让我们看一个配置投影的例子，以便更好的理解。首先，我们需要为投影定义一个骨架：</p>
<pre><code>&lt;?php
interface Projection
{
    public function listensTo();
    public function project($event);
}</code></pre><p>因此为<code>PostWasCreated</code>事件定义一个Elasticsearch投影将像这样简单：</p>
<pre><code>&lt;?php
namespace InfrastructureProjectionElasticsearch;
use ElasticsearchClient;
use PostWasCreated;
class PostWasCreatedProjection implements Projection {
    private $client;
    public function __construct(Client $client) {
        $this-&gt;client = $client;
    }
    public function listensTo() {
        return PostWasCreated::class;
    }
    public function project($event) {
        $this-&gt;client-&gt;index([&apos;index&apos; =&gt; &apos;posts&apos;, &apos;type&apos; =&gt; &apos;post&apos;, &apos;id&apos; =&gt; $event-&gt;getPostId(), &apos;body&apos; =&gt; [&apos;content&apos; =&gt; $event-&gt;getPostContent(),
        // ...
        ]]);
    }
}</code></pre><p>投影器的实现是一种专门的领域事件监听器，它和默认的领域事件监听器的区别在于，投影器对一组领域事件作出反应，而不是只对一个领域事件作出反应。</p>
<pre><code>&lt;?php
namespace InfrastructureProjection;
class Projector {
    private $projections = [];
    public function register(array $projections) {
        foreach ($projections as $projection) {
            $this-&gt;projections[$projection-&gt;eventType() ] = $projection;
        }
    }
    public function project(array $events) {
        foreach ($events as $event) {
            if (isset($this-&gt;projections[get_class($event) ])) {
                $this-&gt;projections[get_class($event) ]-&gt;project($event);
            }
        }
    }
}</code></pre><p>以下代码展示了投影器和事件之间的流程：</p>
<pre><code>&lt;?php
$client = new ElasticsearchClientBuilder::create()-&gt;build();
$projector = new Projector();
$projector-&gt;register([new InfrastructureProjectionElasticsearchPostWasCreatedProjection($client), new InfrastructureProjectionElasticsearchPostWasPublishedProjection($client), new InfrastructureProjectionElasticsearchPostWasCategorizedProjection($client), new InfrastructureProjectionElasticsearchPostContentWasChangedProjection($client), new InfrastructureProjectionElasticsearchPostTitleWasChangedProjection($client), ]);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>这个代码是同步的，但是如果需要也可以成为异步。通过在视图层展示一些提示信息来让用户了解这些没有同步更新的数据。</p>
<p>对于下一个例子，我们将使结合ReactPHP来使用amqplib PHP扩展：</p>
<pre><code>&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Declare a new exchange
$ex = new AMQPExchange($ch);
$ex-&gt;setName(&apos;events&apos;);
$ex-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
// Create a producer that will send any waiting messages every half a
second $producer = new GosComponentReactAMQPProducer($ex, $loop, 0.5);
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$projector = new AsyncProjector($producer, $serializer);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>为使该代码能运行，我们需要一个异步投影器。这有一个简单的实现：</p>
<pre><code>&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Declare a new exchange
$ex = new AMQPExchange($ch);
$ex-&gt;setName(&apos;events&apos;);
$ex-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
// Create a producer that will send any waiting messages every half a
second $producer = new GosComponentReactAMQPProducer($ex, $loop, 0.5);
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$projector = new AsyncProjector($producer, $serializer);
$events = [new PostWasCreated( /* ... */
), new PostWasPublished( /* ... */
), new PostWasCategorized( /* ... */
), new PostContentWasChanged( /* ... */
), new PostTitleWasChanged( /* ... */
), ];
$projector-&gt;project($event);</code></pre><p>而RabbitMQ事件消费者的代码像这样：</p>
<pre><code>&lt;?php
// Connect to an AMQP broker
$cnn = new AMQPConnection();
$cnn-&gt;connect();
// Create a channel
$ch = new AMQPChannel($cnn);
// Create a new queue
$queue = new AMQPQueue($ch);
$queue-&gt;setName(&apos;events&apos;);
$queue-&gt;declare();
// Create an event loop
$loop = ReactEventLoopFactory::create();
$serializer = JMSSerializerSerializerBuilder::create()-&gt;build();
$client = new ElasticsearchClientBuilder::create()-&gt;build();
$projector = new Projector();
$projector-&gt;register([new InfrastructureProjectionElasticsearchPostWasCreatedProjection($client), new InfrastructureProjectionElasticsearchPostWasPublishedProjection($client), new InfrastructureProjectionElasticsearchPostWasCategorizedProjection($client), new InfrastructureProjectionElasticsearchPostContentWasChangedProjection($client), new InfrastructureProjectionElasticsearchPostTitleWasChangedProjection($client), ]);
// Create a consumer
$consumer = new GosComponentReactAMQPConsumer($queue, $loop, 0.5, 10);
// Check for messages every half a second and consume up to 10 at a time.
$consumer-&gt;on(&apos;consume&apos;, function ($envelope, $queue) use($projector, $serializer) {
    $event = $serializer-&gt;unserialize($envelope-&gt;getBody(), &apos;json&apos;);
    $projector-&gt;project($event);
});
$loop-&gt;run();</code></pre><p>从现在开始，所有需要的Repository消费一个投影器实例，并使得Repository调用投影过程：</p>
<pre><code>&lt;?php
class DoctrinePostRepository implements PostRepository {
    private $em;
    private $projector;
    public function __construct(EntityManager $em, Projector $projector) {
        $this-&gt;em = $em;
        $this-&gt;projector = $projector;
    }
    public function save(Post $post) {
        $this-&gt;em-&gt;transactional(function (EntityManager $em) use($post) {
            $em-&gt;persist($post);
            foreach ($post-&gt;recordedEvents() as $event) {
                $em-&gt;persist($event);
            }
        });
        $this-&gt;projector-&gt;project($post-&gt;recordedEvents());
    }
    public function byId(PostId $id) {
        return $this-&gt;em-&gt;find($id);
    }
}</code></pre><p>Post实例和记录的事件在同一个事务中被触发和持久化，这确保了不会有事件丢失，如果事务执行成功，我们将这些事件投影到读模型。因此，写模型和读模型之间不会不一致。</p>
<blockquote>
<p>使用ORM还是不使用ORM？<br>在实现CQRS时最常见的一个问题是：是否真的需要使用ORM？我们坚信在写模型中使用ORM是非常好的，并且具有使用工具的所有有点，这有助于我们使用关系数据库的情况下节省大量的工作。但是我们不应该忘记，我们仍然需要在关系数据库中持久化和检索写模型的状态。</p>
</blockquote>
<h2 id="事件溯源"><a href="#事件溯源" class="headerlink" title="事件溯源"></a>事件溯源</h2><p>CQRS是一个强大而灵活的架构，在收集和保存领域事件（在聚合操作中发生的）方面有一个额外的好处，可以让你详细的了解领域中发生的事情。因为领域事件描述了过去所发生的事情，这在领域中是具有重要意义的，所以领域事件是战术模式的关键点之一，</p>
<blockquote>
<p>小心记录太多的事件<br>越来越多的事件意味着在领域中大量使用事件，这很可能是由业务来激发的。但作为一个经验法则，记住保持简单为好。</p>
</blockquote>
<p>通过使用CQRS，我们能够记录领域层中发生的所有相关事件。领域模型的状态可以通过之前记录的事件来重现。我们只要一个工具以一致的方式来存储这些事件，所以我们需要一个事件仓库。</p>
<blockquote>
<p>事件溯源背后的基本思想是，将聚合的状态表示为事件的顺序变化。</p>
</blockquote>
<p>使用CQRS，我们部分实现了以下功能：Post实体通过领域事件来更改其状态，由于之前已经解释过了，通过将对象映射到关系数据库的方式，Post实体已被持久化。</p>
<p>离事件溯源更近一步，如果我们使用一张数据表来存储所有博客文章的状态，另一张表存储所有文章的评论等。使用事件溯源让我们使用单个表：存储所有由聚合发布的领域事件，单一的做追加。是的，你没看错，一张数据表。</p>
<p>有了这样的模型，像ORM这样的工具不再需要了。唯一需要的工具是一个简单的数据库抽象层，通过它可以追加事件进去：</p>
<pre><code>&lt;?php
interface EventSourcedAggregateRoot {
    public static function reconstitute(EventStream $events);
}
class Post extends AggregateRoot implements EventSourcedAggregateRoot {
    public static function reconstitute(EventStream $history) {
        $post = new static ($history-&gt;getAggregateId());
        foreach ($events as $event) {
            $post-&gt;applyThat($event);
        }
        return $post;
    }
}</code></pre><p>现在Post聚合有一个方法，当给定一组事件时（换句话说，一个事件流），他能够在保存之前，一步一步的重现状态直到成为当前状态。下一步将构建PostRepository端口的适配器，该端口将从Post聚合提取所有发布的事件，并将它们追加到存储事件的表中，这就是我们所说的事件仓库：</p>
<pre><code>&lt;?php
class EventStorePostRepository implements PostRepository {
    private $eventStore;
    private $projector;
    public function __construct($eventStore, $projector) {
        $this-&gt;eventStore = $eventStore;
        $this-&gt;projector = $projector;
    }
    public function save(Post $post) {
        $events = $post-&gt;recordedEvents();
        $this-&gt;eventStore-&gt;append(new EventStream($post-&gt;id(), $events));
        $post-&gt;clearEvents();
        $this-&gt;projector-&gt;project($events);
    }
}</code></pre><p>这是当我们使用事件仓库来保存Post聚合发布的所有事件时的实现，现在我们需要一个方式去从事件历史中恢复一个聚合。由Post聚合实现的一个方法，来从事件中重建一个博客文章状态：</p>
<pre><code>&lt;?php
class EventStorePostRepository implements PostRepository {
    public function byId(PostId $id) {
        return Post::reconstitute($this-&gt;eventStore-&gt;getEventsFor($id));
    }
}</code></pre><p>事件仓库是负责保存和恢复事件流所有责任的主力。其公开API有两个简单的方法组成：它们是<code>append</code>和<code>getEventsFrom</code>，前者将事件流追加到事件仓库中，后者加载事件流来重建聚合。</p>
<p>我们可以使用键值对形式实现去存储所有事件：</p>
<pre><code>&lt;?php
class EventStore {
    private $redis;
    private $serializer;
    public function __construct($redis, $serializer) {
        $this-&gt;redis = $redis;
        $this-&gt;serializer = $serializer;
    }
    public function append(EventStream $eventstream) {
        foreach ($eventstream as $event) {
            $data = $this-&gt;serializer-&gt;serialize($event, &apos;json&apos;);
            $date = (new DateTimeImmutable())-&gt;format(&apos;YmdHis&apos;);
            $this-&gt;redis-&gt;rpush(&apos;events:&apos; . $event-&gt;getAggregateId(), $this-&gt;serializer-&gt;serialize([&apos;type&apos; =&gt; get_class($event), &apos;created_on&apos; =&gt; $date, &apos;data&apos; =&gt; $data], &apos;json&apos;));
        }
    }
    public function getEventsFor($id) {
        $serializedEvents = $this-&gt;redis-&gt;lrange(&apos;events:&apos; . $id, 0, -1);
        $eventStream = [];
        foreach ($serializedEvents as $serializedEvent) {
            $eventData = $this-&gt;serializerdeserialize($serializedEvent, &apos;array&apos;, &apos;json&apos;);
            $eventStream[] = $this-&gt;serializer-&gt;deserialize($eventData[&apos;data&apos;], $eventData[&apos;type&apos;], &apos;json&apos;);
        }
        return new EventStream($id, $eventStream);
    }
}</code></pre><p>这个事件仓库的实现是基于Redis的，使用前缀将事件追加到列表中：另外，在持久化事件之前，我们提取一些元数据，像事件类名或创建日期等，因为稍后会派上用场。</p>
<p>显然，就性能而言，聚合总是要经历一遍事件历史才能达到最终的状态，这代价是非常昂贵的。事件流如果包含数百甚至上千事件更是如此。处理这种情况的最佳方法是从聚合中获取快照，并且仅重现快照之后发生的事件流中的事件。快照只是在任何特定时刻聚合状态的简单序列化形式，它可以基于聚合事件流的事件数量，也可以基于时间。采用第一种方法，每触发n个事件（如每隔50、100或200个事件）就会记录一张快照，第二种方法是每隔n秒记录一次快照。</p>
<p>我们将使用第一种记录快照的方式，在事件的元数据中，我们存储了一个额外的字段——version，该字段表示我们开始重现聚合历史的开始位置。</p>
<pre><code>&lt;?php
class SnapshotRepository {
    public function byId($id) {
        $key = &apos;snapshots:&apos; . $id;
        $metadata = $this-&gt;serializer-&gt;unserialize($this-&gt;redis-&gt;get($key));
        if (null === $metadata) {
            return;
        }
        return new Snapshot($metadata[&apos;version&apos;], $this-&gt;serializer-&gt;unserialize($metadata[&apos;snapshot&apos;][&apos;data&apos;], $metadata[&apos;snapshot&apos;][&apos;type&apos;], &apos;json&apos;));
    }
    public function save($id, Snapshot $snapshot) {
        $key = &apos;snapshots:&apos; . $id;
        $aggregate = $snapshot-&gt;aggregate();
        $snapshot = [&apos;version&apos; =&gt; $snapshot-&gt;version(), &apos;snapshot&apos; =&gt; [&apos;type&apos; =&gt; get_class($aggregate), &apos;data&apos; =&gt; $this-&gt;serializer-&gt;serialize($aggregate, &apos;json&apos;) ]];
        $this-&gt;redis-&gt;set($key, $snapshot);
    }
}</code></pre><p>现在我们需要重构EventStore类，以便开始使用SnapshotRepository类在可接受的性能时间内去加载聚合。</p>
<pre><code>&lt;?php
class EventStorePostRepository implements PostRepository {
    public function byId(PostId $id) {
        $snapshot = $this-&gt;snapshotRepository-&gt;byId($id);
        if (null === $snapshot) {
            return Post::reconstitute($this-&gt;eventStore-&gt;getEventsFrom($id));
        }
        $post = $snapshot-&gt;aggregate();
        $post-&gt;replay($this-&gt;eventStore-&gt;fromVersion($id, $snapshot-&gt;version()));
        return $post;
    }
}</code></pre><p>我们只需要定期进行记录聚合的快照，我们可以通过负责异步或同步监听事件仓库的进程来执行快照的记录。以下是一个演示聚合快照实施的简单示例：</p>
<pre><code>&lt;?php
class EventStorePostRepository implements PostRepository {
    public function save(Post $post) {
        $id = $post-&gt;id();
        $events = $post-&gt;recordedEvents();
        $post-&gt;clearEvents();
        $this-&gt;eventStore-&gt;append(new EventStream($id, $events));
        $countOfEvents = $this-&gt;eventStore-&gt;countEventsFor($id);
        $version = $countOfEvents / 100;
        if (!$this-&gt;snapshotRepository-&gt;has($post-&gt;id(), $version)) {
            $this-&gt;snapshotRepository-&gt;save($id, new Snapshot($post, $version));
        }
        $this-&gt;projector-&gt;project($events);
    }
}</code></pre><blockquote>
<p>使用ORM还是不使用ORM？<br>从这种架构风格的用例我们可以清楚的看到，使用ORM来持久和获取事件会过度设计。即使我们使用关系数据库来存储事件，我们也只需从数据库中持久化和获取事件。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于可选的架构风格有很多，因此你可能会对于本章节的内容感到困惑。你需要在众多选择中去权衡优缺点，来做出正确的选择。有一点很清楚：大泥球的方式不应该选择，因为代码会很快烂掉。分层架构是一个更好的选择，但是它也存在一些缺点，如各层之间的紧耦合。可以说，最均衡的选择是六边形架构，因为它可以用作基础架构，并且可以促进程序内部和外部高度解耦和对称性。这是我们为大多数场景下推荐的选择。</p>
<p>我们也看到CQRS和事件溯源是相对灵活的架构，可以帮助你应对复杂性。CQRS和事件溯源都有自己的定位，但也不要让这个因素来分散你的注意你。因为它们都有一些开销，你应该有一个来使用它们的技术理由。这些架构确实非常有用，可以在CQRS的Repository仓储的finder方法的数量上和事件溯源触发的事件数量上得到启发。如果finder方法开始增加，并且仓储变得难以维护，那么是时候考虑CQRS，以便拆分读写问题。如果每个聚合的事件数量趋于增长，并且业务对更细粒度的信息关注，那么可以考虑的一个选择是事件溯源。</p>
<p>从Brian Foote和Joseph Yoder论文中提取的：大泥球（BIG BALL OF MUD）是一个杂乱的结构、蔓延无序的、胶带似的、下水管道似的、意大利面条似的代码丛林。（译者注：只可意会）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/04/19/553/" data-id="ck3heflvg00day7sldr5qeu5f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ddd/" rel="tag">ddd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" rel="tag">领域驱动设计</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-551" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/02/551/" class="article-date">
  <time datetime="2018-04-02T22:46:14.000Z" itemprop="datePublished">2018-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/02/551/">记一次Safari中无法跨域设置cookie的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->问题重现步骤：  
<p>有两个不同域名的页面a.com/a.php和b.com/a.php两个域名，其中b.com/a.php会在其<code>b.com</code>下设置cookie，a.com/a.php页面中通过<code>iframe</code>或<code>script src</code>等方式嵌入b.com/a.php页面。保持b.com下的cookie为空，正常chrome等浏览器访问a.com/a.php时，嵌入的b.com/a.php可以正常对<code>b.com</code>域名下设置cookie，而safari中设置不了。</p>
<p>一开始以为是自己在b.com页面中设置cookie方式有问题，对cookie的name、value、expire、path、secure、httponly等都检查了好多次都没找出原因。并且当时会出现偶尔可以设置偶尔不可以设置的现象，后来逐一条件排查下来是要在b.com域名下cookie清空的条件下会产生这问题，如果b.com下有任意的一个或多个cookie项，那么safari就能正常写进去。</p>
<p>我主要是在iphone上进行的测试，后经查也有人反馈在pc上的safari也有这问题，那最后基本可以定位这问题的原因了。<br>试过通过在b.com下设置各种cors header头，加各种P3P header均没有效果。<br>这估计还是因为safari的cookie策略导致的。。最后。。只能根据问题现象，使用很屎的中转办法了，提前在b.com下设置任意一个cookie来确保该域名下至少有cookie，后续才能设置成功。</p>
<p>查找过的相关文章：<br><a href="https://blog.csdn.net/zhx19920405/article/details/51417250" target="_blank" rel="noopener">https://blog.csdn.net/zhx19920405/article/details/51417250</a><br><a href="https://stackoverflow.com/questions/32713992/safari-does-not-allowed-cross-domain-cookies-in-iframe" target="_blank" rel="noopener">https://stackoverflow.com/questions/32713992/safari-does-not-allowed-cross-domain-cookies-in-iframe</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2018/04/02/551/" data-id="ck3heflom000yy7sl8lb8bw36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iphone/" rel="tag">iphone</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/safari/" rel="tag">safari</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-547" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/23/547/" class="article-date">
  <time datetime="2015-12-23T06:18:00.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>►<a class="article-category-link" href="/categories/PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/23/547/">设计模式笔记：第二个设计模式原则——优先选择组合而非继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!--markdown-->![QQ截图20151223224240.jpg](http://storage.veitor.net/2015/12/3282518938.jpg "QQ截图20151223224240.jpg")

<p>有些OOP程序员认为对象重用、扩展就等同于使用继承。一个类可以有大量属性和方法，通过继承这个类，我们增加新属性和方法，就能轻松的进行扩展，因为无需再重新编写代码。不过最后对于紧密绑定的对象，一味的使用继承方式来扩展会导致这么一个问题，那就是<strong>过度继承</strong>。</p>
<p>所以这里要讲的就是第二个设计模式原则：<strong>应当优先选择对象组合而不是类继承</strong></p>
<p>那么对象组合与继承有什么区别呢？这个说法并不是要完全消除继承。实际上，这个表示开发程序时如果有机会使用组合，就应当优先使用组合而不是继承。这样一来，子类就不会因为继承到大量不用的属性和方法而变得过度膨胀。</p>
<p>下面通过一个简单例子来说明一下，首先看使用继承的代码，父类是一个简单的类，包含两个方法来完成加法和除法：</p>
<pre><code>class DoMath
{
    private $sum;
    private $quotient;
    public function simpleAdd($first, $second)
    {
        $this-&gt;sum = ($first+$second);
        return $this-&gt;sum;
    }
    public function simpleDivide($dividend, $divisor)
    {
        $this-&gt;quotient = ($dividend/$divisor);
        return $this-&gt;quotient;
    }
}</code></pre><p>子类用于增加文本功能，一个方法是将数字转换为字符串，另一个方法是建立一个格式化输出。这个类通过继承DoMath的方式扩展了所有功能：</p>
<pre><code>class InheritMath extends DoMath
{
    private $textOut;
    private $fullFace;
    public function numToText($num)
    {
        $this-&gt;textOut = (string)$num;
        return $this-&gt;textOut;
    }
    public function addFace($face, $msg)
    {
        $this-&gt;fullFace = &quot;&lt;strong&gt;&quot; . $face . &quot;&lt;/strong&gt;&quot; . $msg;
        return $fullFace;
    }
}</code></pre><p>最后实例化InheritMath类，使用实例化的对象不仅能够使用DoMath类中的所有功能，还能使用InheritMath类中新增的功能：</p>
<pre><code>$family = new InheritMath();
$added = $family-&gt;simpleAdd(40,60);
$divided = $family-&gt;simpleDivide($added, 25);
$textNum = $family-&gt;numToText($divided);
$output = $family-&gt;addFace(&quot;Your results&quot;,$textNum);
echo $output;
//输出结果
Your results:4</code></pre><p>接着再来看一下组合使用的代码，其中一个类依然是上面例子中的DoMath，另一个类是：</p>
<pre><code>class DoText
{
    private $textOut;
    private $fullFace;
    public function numToText($num)
    {
        $this-&gt;textOut = (string)$num;
        return $this-&gt;textOut;
    }
    public function addFace($face, $msg)
    {
        $this-&gt;fullFace = &quot;&lt;strong&gt;&quot; . $face . &quot;&lt;/strong&gt;&quot; . $msg;
        return $fullFace;
    }
}</code></pre><p>这个DoText类与InheritMath类很相似，它们的区别仅仅就是一个继承了DoMath类，一个没有继承。</p>
<p>然后通过组合方式来使用这两个类：</p>
<pre><code>$math = new DoMath();
$text = new DoText();
$added = $math-&gt;simpleAdd(40,60);
$divided = $math-&gt;simpleDivide($added, 25);
$textNum = $text-&gt;numToText($divided);
$output = $text-&gt;addFace(&quot;Your results&quot;,$textNum);
echo $output;
//输出结果
Your results:4</code></pre><p>结果完全相同，不过这么做需要多包含一个类，并且多实例化一个类。看起来继承似乎更胜一筹，不过在较大的程序中，组合可以避免维护多个继承层次上的各个子类，而且还可以避免可能导致的错误。比如，父类的一个改变会逐级乡下传递到子类的实现，这可能会影响子类使用，如果继承过深，那么继承那么多的子类都可能要去进行相应的修改，那将是一个蛋疼的事情啊。</p>
<p>所以说，不是不能使用继承，而是尽量优先选择组合，并且使用继承的话，要尽量避免过度继承，要使用浅继承。主要还是避免类之间的紧密绑定。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.veitor.net/2015/12/23/547/" data-id="ck3heflok000wy7sl3c1l57dv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/PHP/">PHP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/PHP/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/">程序与生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JS/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/PHP/">PHP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/PHP/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/">程序与生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/">程序与生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/">程序与生活</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACID/" rel="tag">ACID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASCII/" rel="tag">ASCII</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CQRS/" rel="tag">CQRS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DNS/" rel="tag">DNS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Sourcing/" rel="tag">Event Sourcing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Store/" rel="tag">Event Store</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PDO/" rel="tag">PDO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVN/" rel="tag">SVN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/URL/" rel="tag">URL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UTF-8/" rel="tag">UTF-8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/" rel="tag">Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yii/" rel="tag">Yii</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crypt/" rel="tag">crypt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csrf/" rel="tag">csrf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ddd/" rel="tag">ddd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flash/" rel="tag">flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google/" rel="tag">google</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iphone/" rel="tag">iphone</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pear/" rel="tag">pear</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/" rel="tag">pip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/retina/" rel="tag">retina</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/safari/" rel="tag">safari</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session/" rel="tag">session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/" rel="tag">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unicode/" rel="tag">unicode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xhprof/" rel="tag">xhprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xss/" rel="tag">xss</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6/" rel="tag">事件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%98%E9%85%B7/" rel="tag">优酷</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%93%E9%AA%8C/" rel="tag">体验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A0%E5%AF%86/" rel="tag">加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%A0%81/" rel="tag">原码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E7%A0%81/" rel="tag">反码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" rel="tag">响应式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">存储引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%88%E6%9D%83/" rel="tag">授权</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF/" rel="tag">模板</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A0%81/" rel="tag">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" rel="tag">自适应</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8F%9C%E5%8D%95/" rel="tag">菜单</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A5%E7%A0%81/" rel="tag">补码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%84%E8%8C%83/" rel="tag">规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A4%E8%AF%81/" rel="tag">认证</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD/" rel="tag">负载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E5%BE%84/" rel="tag">路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%82%E9%85%8D/" rel="tag">适配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E7%BE%A4/" rel="tag">集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/" rel="tag">预加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" rel="tag">领域驱动设计</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACID/" style="font-size: 10px;">ACID</a> <a href="/tags/ASCII/" style="font-size: 10px;">ASCII</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/CQRS/" style="font-size: 12.86px;">CQRS</a> <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/Event-Sourcing/" style="font-size: 11.43px;">Event Sourcing</a> <a href="/tags/Event-Store/" style="font-size: 10px;">Event Store</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Linux/" style="font-size: 14.29px;">Linux</a> <a href="/tags/PDO/" style="font-size: 10px;">PDO</a> <a href="/tags/PHP/" style="font-size: 20px;">PHP</a> <a href="/tags/SVN/" style="font-size: 11.43px;">SVN</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/URL/" style="font-size: 10px;">URL</a> <a href="/tags/UTF-8/" style="font-size: 10px;">UTF-8</a> <a href="/tags/Unix/" style="font-size: 10px;">Unix</a> <a href="/tags/Yii/" style="font-size: 17.14px;">Yii</a> <a href="/tags/crypt/" style="font-size: 10px;">crypt</a> <a href="/tags/csrf/" style="font-size: 10px;">csrf</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/ddd/" style="font-size: 12.86px;">ddd</a> <a href="/tags/flash/" style="font-size: 10px;">flash</a> <a href="/tags/google/" style="font-size: 10px;">google</a> <a href="/tags/iphone/" style="font-size: 10px;">iphone</a> <a href="/tags/mysql/" style="font-size: 18.57px;">mysql</a> <a href="/tags/pear/" style="font-size: 10px;">pear</a> <a href="/tags/pip/" style="font-size: 10px;">pip</a> <a href="/tags/python/" style="font-size: 12.86px;">python</a> <a href="/tags/retina/" style="font-size: 10px;">retina</a> <a href="/tags/safari/" style="font-size: 10px;">safari</a> <a href="/tags/session/" style="font-size: 10px;">session</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/unicode/" style="font-size: 10px;">unicode</a> <a href="/tags/xhprof/" style="font-size: 10px;">xhprof</a> <a href="/tags/xss/" style="font-size: 10px;">xss</a> <a href="/tags/%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">事件</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 12.86px;">事务</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 10px;">人工智能</a> <a href="/tags/%E4%BC%98%E9%85%B7/" style="font-size: 10px;">优酷</a> <a href="/tags/%E4%BD%93%E9%AA%8C/" style="font-size: 10px;">体验</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.71px;">前端</a> <a href="/tags/%E5%8A%A0%E5%AF%86/" style="font-size: 10px;">加密</a> <a href="/tags/%E5%8E%9F%E7%A0%81/" style="font-size: 10px;">原码</a> <a href="/tags/%E5%8F%8D%E7%A0%81/" style="font-size: 10px;">反码</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">后端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" style="font-size: 11.43px;">响应式</a> <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" style="font-size: 10px;">存储引擎</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 11.43px;">微服务</a> <a href="/tags/%E6%8E%88%E6%9D%83/" style="font-size: 10px;">授权</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">数学</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 10px;">模板</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size: 11.43px;">编码</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" style="font-size: 11.43px;">自适应</a> <a href="/tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="/tags/%E8%8F%9C%E5%8D%95/" style="font-size: 10px;">菜单</a> <a href="/tags/%E8%A1%A5%E7%A0%81/" style="font-size: 10px;">补码</a> <a href="/tags/%E8%A7%84%E8%8C%83/" style="font-size: 10px;">规范</a> <a href="/tags/%E8%AE%A4%E8%AF%81/" style="font-size: 10px;">认证</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.86px;">设计模式</a> <a href="/tags/%E8%B4%9F%E8%BD%BD/" style="font-size: 10px;">负载</a> <a href="/tags/%E8%B7%AF%E5%BE%84/" style="font-size: 10px;">路径</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 17.14px;">转载</a> <a href="/tags/%E8%BF%90%E7%BB%B4/" style="font-size: 10px;">运维</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">进程</a> <a href="/tags/%E9%80%82%E9%85%8D/" style="font-size: 10px;">适配</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">集群</a> <a href="/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/" style="font-size: 10px;">预加载</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">领域驱动设计</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/06/593/">什么是SNI？</a>
          </li>
        
          <li>
            <a href="/2018/12/04/584/">微服务模式：Saga</a>
          </li>
        
          <li>
            <a href="/2018/12/04/580/">微服务模式：一个服务一个数据库</a>
          </li>
        
          <li>
            <a href="/2018/12/04/577/">CQRS/ES架构下如何保证用户名的唯一性？</a>
          </li>
        
          <li>
            <a href="/2018/08/15/576/">编程中的hydration是什么意思</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Veitor<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>