<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.veitor.net","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"codeblock":{"theme":{"light":"default","dark":"default"},"prism":{"light":"prism-tomorrow.min","dark":"prism-tomorrow.min"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
<meta property="og:type" content="website">
<meta property="og:title" content="Veitor的技术博客">
<meta property="og:url" content="http://www.veitor.net/page/7/index.html">
<meta property="og:site_name" content="Veitor的技术博客">
<meta property="og:description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Veitor">
<meta property="article:tag" content="php,CQRS,DDD,Event Sourcing,linux,Yii,kubernetes,golang,docker">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.veitor.net/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Veitor的技术博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?c422d42123239fdefb0180ed522d050a"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-core.min.js" integrity="sha256-bKrTFt2ZHyT4AE4LnBnAVctYKf9l6XP77kBvltgbjn4=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/7.2.0/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Veitor的技术博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Veitor"
      src="/avatar.jpg">
  <p class="site-author-name" itemprop="name">Veitor</p>
  <div class="site-description" itemprop="description">关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/veitor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;veitor" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/veitor" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;veitor" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Veitor_424" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Veitor_424" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/congurence-operations-and-their-basic-properties/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/congurence-operations-and-their-basic-properties/" class="post-title-link" itemprop="url">同余运算及其基本性质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-10-28 05:05:34" itemprop="dateCreated datePublished" datetime="2014-10-28T05:05:34+08:00">2014-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>     100除以7的余数是2，意思就是说把100个东西七个七个分成一组的话最后还剩2个。余数有一个严格的定义：假如被除数是a，除数是b（假设它们 均为正整数），那么我们总能够找到一个小于b的自然数r和一个整数m，使得a&#x3D;bm+r。这个r就是a除以b的余数，m被称作商。我们经常用mod来表示 取余，a除以b余r就写成a mod b &#x3D; r。</p>
<p>    如果两个数a和b之差能被m整除，那么我们就说a和b对模数m同余（关于m同余）。比 如，100-60除以8正好除尽，我们就说100和60对于模数8同余。它的另一层含义就是说，100和60除以8的余数相同。a和b对m同余，我们记作 a≡b(mod m)。比如，刚才的例子可以写成100≡60(mod 8)。你会发现这种记号到处都在用，比如和数论相关的书中就经常把a mod 3 &#x3D; 1写作a≡1(mod 3)。</p>
<p>    之所以把同余当作一种运算，是因为同余满足运算的诸多性质。比如，同余满足等价关系。具体地说，它满足自反性（一个数永远和自己同余）、对称性（a和b同余，b和a也就同余）和传递性（a和b同余，b和c同余可以推出a和c同余）。这三个性质都是显然的。</p>
<p>     同余运算里还有稍微复杂一些的性质。比如，同余运算和整数加减法一样满足“等量加等量，其和不变”。小学我们就知道，等式两边可以同时加上一个相等的数。例 如，a&#x3D;b可以推出a+100&#x3D;b+100。这样的性质在同余运算中也有：对于同一个模数m，如果a和b同余，x和y同余，那么a+x和b+y也同余。在 我看来，这个结论几乎是显然的。当然，我们也可以严格证明这个定理。这个定理对减法同样有效。 <strong>性质：如果a≡b(mod m)，x≡y(mod m)，则a+x≡b+y(mod m)。</strong> 证 明：条件告诉我们，可以找到p和q使得a-mp &#x3D; b-mq，也存在r和s使得x-mr &#x3D; y-ms。于是a-mp + x-mr &#x3D; b-mq + y-ms，即a+x-m(p+r) &#x3D; b+y-m(q+s)，这就告诉我们a+x和b+y除以m的余数相同。 容易想到，两个同余式对应相乘，同余式两边仍然相等： <strong>如果a≡b(mod m)，x≡y(mod m)，则ax≡by(mod m)。</strong> 证明：条件告诉我们，a-mp &#x3D; b-mq，x-mr &#x3D; y-ms。于是(a-mp)(x-mr) &#x3D; (b-mq)(y-ms)，等式两边分别展开后必然是ax-m(…) &#x3D; by-m(…)的形式，这就说明ax≡by(mod m)。 现在你知道为什么有的题要 叫你“输出答案mod xxxxx的结果”了吧，那是为了避免高精度运算，因为这里的结论告诉我们在运算过程中边算边mod和算完后再mod的结果一样。假如a是一个很大的数， 令b&#x3D;a mod m，那么(a * 100) mod m和(b * 100) mod m的结果是完全一样的，这相当于是在a≡b (mod m)的两边同时乘以100。这些结论其实都很显然，因为同余运算只关心余数（不关心“整的部分”），完全可以每一次运算后都只保留余数。因此，整个运算过 程中参与运算的数都不超过m，避免了高精度的出现。 在证明**<em>Fermat小定理</em>**时，我们用到了这样一个定理： <strong>如果ac≡bc(mod m)，且c和m互质，则a≡b(mod m)</strong> （就是说同余式两边可以同时除以一个和模数互质的数）。 证明：条件告诉我们，ac-mp &#x3D; bc-mq，移项可得ac-bc &#x3D; mp-mq，也就是说(a-b)c &#x3D; m(p-q)。这表明，(a-b)c里需要含有因子m，但c和m互质，因此只有可能是a-b被m整除，也即a≡b(mod m)。</p>
<p>  原文地址：<a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/236">http://www.matrix67.com/blog/archives/236</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/Mysql-transaction-and-isolation-level/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/Mysql-transaction-and-isolation-level/" class="post-title-link" itemprop="url">Mysql事务以及隔离级别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-09-22 14:20:55" itemprop="dateCreated datePublished" datetime="2014-09-22T14:20:55+08:00">2014-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据库事务概念"><a href="#数据库事务概念" class="headerlink" title="数据库事务概念"></a>数据库事务概念</h1><p>数据库事务必须同时满足 4 个特性：原子性（Atomic）、一致性（Consistency）、隔离性（Isolation）和持久性（Durabiliy），简称为ACID。下面是对每个特性的说明。</p>
<ul>
<li>原子性：表示组成一个事务的多个数据库操作要么全部成功、要么全部失败。</li>
<li>一致性：事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据不会被破坏。如从A账户转账100元到B账户，不管操作成功与否，A和B的存款总额是不变的。</li>
<li>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准确地说，并非要求做到完全无干扰，数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。</li>
<li>持久性：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证能够通过某种机制恢复数据。</li>
</ul>
<p>其实这四个特性，原子性是最终目的。  </p>
<h1 id="数据并发的问题"><a href="#数据并发的问题" class="headerlink" title="数据并发的问题"></a>数据并发的问题</h1><p>一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题可以归结为5类，包括3类数据读问题（ 脏读、 不可重复读和 幻象读）以及2类数据更新问题（ 第一类丢失更新和 第二类丢失更新）。下面，我们分别通过实例讲解引发问题的场景。</p>
<h2 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h2><p>A事务读取B事务尚未提交的更改数据，并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读到的数据根本是不被承认的。来看取款事务和转账事务并发时引发的脏读场景： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_B8Se.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_B8Se.jpg" alt="15150645_B8Se"></a>   在这个场景中，B希望取款500元而后又撤销了动作，而A往相同的账户中转账100元，就因为A事务读取了B事务尚未提交的数据，因而造成账户白白丢失了500元。在Oracle数据库中，不会发生脏读的情况。</p>
<h2 id="不可重复读（unrepeatable-read）"><a href="#不可重复读（unrepeatable-read）" class="headerlink" title="不可重复读（unrepeatable read）"></a>不可重复读（unrepeatable read）</h2><p>不可重复读是指 A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_B8Se1.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_B8Se1.jpg" alt="15150645_B8Se"></a>   在同一事务中，T4时间点和T7时间点读取账户存款余额不一样。</p>
<h2 id="幻象读（phantom-read）"><a href="#幻象读（phantom-read）" class="headerlink" title="幻象读（phantom read）"></a>幻象读（phantom read）</h2><p>A事务读取B事务提交的新增数据，这时A事务将出现幻象读的问题。幻象读一般发生在计算统计数据的事务中，举一个例子，假设银行系统在同一个事务中，两次统计存款账户的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时，两次统计的总金额将不一致： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw.jpg" alt="15150645_d6yw"></a>   如果新增数据刚好满足事务的查询条件，这个新数据就进入了事务的视野，因而产生了两个统计不一致的情况。 幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（更改或删除），为了避免这两种情况，采取的对策是不同的，防止读取到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化，而防止读取到新增数据，则往往需要添加表级锁——将整个表锁定，防止新增数据（Oracle使用多版本数据的方式实现）。</p>
<h2 id="第一类丢失更新"><a href="#第一类丢失更新" class="headerlink" title="第一类丢失更新"></a>第一类丢失更新</h2><p>A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw1.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw1.jpg" alt="15150645_d6yw"></a> A事务在撤销时，“不小心”将B事务已经转入账户的金额给抹去了。</p>
<h2 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h2><p>A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw2.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw2.jpg" alt="15150645_d6yw"></a>   上面的例子里由于支票转账事务覆盖了取款事务对存款余额所做的更新，导致银行最后损失了100元，相反如果转账事务先提交，那么用户账户将损失100元。</p>
<h1 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h1><p>尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因此数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源添加上适合的锁。此外数据库还会维护这些锁，当一个资源上的锁数目太多时，自动进行锁升级以提高系统的运行性能，而这一过程对用户来说完全是透明的。 ANSI&#x2F;ISO SQL 92标准定义了4个等级的事务隔离级别： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/09/15150645_d6yw3.jpg"><img data-src="http://storage.veitor.net/uploads/2014/09/15150645_d6yw3.jpg" alt="15150645_d6yw"></a>   事务的隔离级别和数据库并发性是对立的，两者此增彼长。一般来说，使用READ UNCOMMITED隔离级别的数据库拥有最高的并发性和吞吐量，而使用SERIALIZABLE隔离级别的数据库并发性最低。 Mysql的默认隔离级别时Repeatable Read，即可重复读。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/using-Insert-to-update-data-in-batches-in-Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/using-Insert-to-update-data-in-batches-in-Mysql/" class="post-title-link" itemprop="url">Mysql中使用Insert批量更新数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-09-09 09:00:37" itemprop="dateCreated datePublished" datetime="2014-09-09T09:00:37+08:00">2014-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们知道当插入多条数据的时候insert支持多条语句：</p>
<p>INSERT INTO t_member (id, name, email) VALUES<br>    (1, ‘nick’, ‘<a href="mailto:&#110;&#105;&#x63;&#107;&#64;&#49;&#x32;&#54;&#46;&#x63;&#x6f;&#x6d;">&#110;&#105;&#x63;&#107;&#64;&#49;&#x32;&#54;&#46;&#x63;&#x6f;&#x6d;</a>‘),<br>    (4, ‘angel’,‘<a href="mailto:&#x61;&#110;&#x67;&#101;&#108;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;">&#x61;&#110;&#x67;&#101;&#108;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a>‘),<br>    (7, ‘brank’,‘<a href="mailto:&#x62;&#x61;&#x31;&#57;&#56;&#x40;&#49;&#x32;&#54;&#46;&#x63;&#x6f;&#x6d;">&#x62;&#x61;&#x31;&#57;&#56;&#x40;&#49;&#x32;&#54;&#46;&#x63;&#x6f;&#x6d;</a>‘);</p>
<p>  但是对于更新记录，由于update语法不支持一次更新多条记录，只能一条一条执行：</p>
<p>UPDATE t_member SET name&#x3D;’nick’, email&#x3D;‘<a href="mailto:&#x6e;&#105;&#x63;&#x6b;&#64;&#x31;&#50;&#x36;&#46;&#99;&#x6f;&#109;">&#x6e;&#105;&#x63;&#x6b;&#64;&#x31;&#50;&#x36;&#46;&#99;&#x6f;&#109;</a>‘ WHERE id&#x3D;1;<br>UPDATE t_member SET name&#x3D;’angel’, email&#x3D;‘<a href="mailto:&#x61;&#110;&#x67;&#x65;&#x6c;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;">&#x61;&#110;&#x67;&#x65;&#x6c;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;</a>‘ WHERE id&#x3D;4;<br>UPDATE t_member SET name&#x3D;’brank’, email&#x3D;‘<a href="mailto:&#98;&#97;&#x31;&#x39;&#56;&#x40;&#x31;&#50;&#54;&#x2e;&#99;&#x6f;&#x6d;">&#98;&#97;&#x31;&#x39;&#56;&#x40;&#x31;&#50;&#54;&#x2e;&#99;&#x6f;&#x6d;</a>‘ WHERE id&#x3D;7;</p>
<p>这里问题就出现了，倘若这个update list非常大时(譬如说5000条)，这个执行率可想而知。 这就要介绍一下在MySql中INSERT语法具有一个条件DUPLICATE KEY UPDATE，这个语法和适合用在需要判断记录是否存在，不存在则插入存在则更新的记录。 具体的语法可以参见：<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.0/en/insert.html">http://dev.mysql.com/doc/refman/5.0/en/insert.html</a> 基于上面这种情况，针对更新记录，仍然使用insert语句，不过限制主键重复时，更新字段。如下：</p>
<p>INSERT INTO t_member (id, name, email) VALUES<br>    (1, ‘nick’, ‘<a href="mailto:&#x6e;&#105;&#x63;&#x6b;&#x40;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;">&#x6e;&#105;&#x63;&#x6b;&#x40;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#x6d;</a>‘),<br>    (4, ‘angel’,‘<a href="mailto:&#x61;&#110;&#103;&#101;&#x6c;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#x61;&#110;&#103;&#101;&#x6c;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a>‘),<br>    (7, ‘brank’,‘<a href="mailto:&#x62;&#97;&#49;&#x39;&#56;&#x40;&#49;&#50;&#54;&#46;&#x63;&#x6f;&#109;">&#x62;&#97;&#49;&#x39;&#56;&#x40;&#49;&#50;&#54;&#46;&#x63;&#x6f;&#109;</a>‘)<br>ON DUPLICATE KEY UPDATE name&#x3D;VALUES(name), email&#x3D;VALUES(email);</p>
<p>注意：ON DUPLICATE KEY UPDATE只是MySQL的特有语法，并不是SQL标准语法！ 原文地址：<a target="_blank" rel="noopener" href="http://www.crackedzone.com/mysql-muti-sql-not-sugguest-update.html">http://www.crackedzone.com/mysql-muti-sql-not-sugguest-update.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/SVN-branch-and-merge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/SVN-branch-and-merge/" class="post-title-link" itemprop="url">SVN分支与合并透析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-09-05 05:30:52" itemprop="dateCreated datePublished" datetime="2014-09-05T05:30:52+08:00">2014-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">经验分享</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>1.创建分支的意义</strong> 创 建分支的意义，比如我们在一个基础平台上进行开发，每个技术小组负责一个子项目，而基础平台也是有可能会继续更改的，这个时候，如果不创建分支，子项目之 间会相互影响，影响最大的就是后期的测试和版本发布，子项目A已经结束，但测试却受到正在进行的子项目B的影响，测试通不过，就别说版本发布了。所以，我 们需要从目前的项目（主干trunk）中创建分支（branch），隔离子项目间的相互影响。 <strong>2.svn创建分支原理</strong> 在 svn中，创建分支，实际上就是一个版本拷贝(对应copy to…注意：绝不是简单在客户端上copy一个目录，而是svn仓库中copy，文件版本号会增加。），两边做任何修改发生的版本变化，是一套机制。 举例：目前主干版本是100，分支版本是101，主干中增加一个文件，版本为102，分支中再增加一个文件，版本就为103了。两边的版本号是一套，不会 重复。 <strong>3.svn创建分支的方法</strong> <strong>TortoiseSVN：</strong>右键点击工程目录-&gt;TortoiseSVN-&gt;Branch&#x2F;tag..菜单，From WC at Url自动为工程svn url，比如<a target="_blank" rel="noopener" href="https://localhost:8443/svn/fbysss/prj1/trunk">https://localhost:8443/svn/fbysss/prj1/trunk</a>，to Url填写<a target="_blank" rel="noopener" href="https://localhost:8443/svn/fbysss/prj1">https://localhost:8443/svn/fbysss/prj1/branches/branch1</a>。点OK按钮，分支就创建好了。 <strong>Subclipse：</strong>Team-&gt;Branch&#x2F;tag..，跟上面类似. <strong>SVN命令模式：</strong>svn copy trunk_path  branch_path  -m ‘描述’ 举例：svn copy <a target="_blank" rel="noopener" href="https://localhost:8443/svn/fbysss/prj1/trunk">https://localhost:8443/svn/fbysss/prj1</a><a target="_blank" rel="noopener" href="https://localhost:8443/svn/fbysss/prj1">&#x2F;trunk </a> <a target="_blank" rel="noopener" href="https://localhost:8443/svn/fbysss/prj1">https://localhost:8443/svn/fbysss/prj1/branches/branch1</a> -m “第一个分支” <strong>注意一点：</strong>trunk和branch不能互为子目录，否则就乱套了。 <strong>4.分支合并</strong> <strong>1）从分支合并到主干</strong> 分支开发结束之后，往往需要合并回主干去测试、发布，但分支和主干可能有很多冲突的地方，在合并时经常需要手工解决。 <strong>被操作对象：</strong>主干 <strong>From****：</strong>主干的打出分支时的版本 <strong>To：</strong>分支的Head版本（最新版本）   怎么理解这个From和To呢?似乎跟我们的想当然不太一样：因为我们理解，把分支合并到主干，肯定是From分支，To主干。怎么搞反了呢？ 实际上，<strong>Svn****认为，我们要合并的，是从主干的某个版本开始，到分支的某个版本结束。两边的版本号实际上是一套系统，不会有重复。</strong>我们从TortoiseSVN Help中也能找到证据：</p>
<p>If you are using this method to merge a feature branch back to trunk, you need to ……..<br>In the From: field enter the full folder URL of the trunk. This may sound wrong, but remember that the trunk is the start point to which you want to add the branch changes. You may also click … to browse the repository.<br>In the To: field enter the full folder URL of the feature branch.</p>
<p>  <strong>2）从主干合并到分支</strong> 试想这样的情况：一个项目里面，要独立出来一个子项目，需要单独发布版本，用到了基础框架代码，而基础框架在主干中不断修改完善，这就需要从主干合并到分支。 <strong>被操作对象：</strong>分支 <strong>From：</strong>分支的第一个版本（最旧版本） <strong>To：</strong>主干的Head版本（最新版本） 相当于从分支的第一个版本开始一直到主干最后一个版本结束合并之后，替换分支。 <strong>3）从分支合并到分支</strong> 有 这样的需求：一个项目中有很多分支，这些分支需要分期上线，有多个工作并行，但每一期之间不能相互影响，这就可以打出几个tag（也是分支），从主干 copy而来。其他主干根据排期分别合并到这些tag中来。比如有prjTag1和prjTag2，model1、model2需要合并到prjTag1 中，model3、model4需要合并到prjTag2中。拿prjTag1举例： 在prjTag1的work copy中，merge   <strong>From****：</strong>主干的打出分支时的版本 <strong>To：</strong>分支的Head版本（最新版本） <strong>注意：</strong>From不是本Tag的某个版本，而是之前主干打出分支时的版本，最终Merge到prjTag1的work copy，而prjTag1是找不到当初打分支时的版本的。 原文地址：<a target="_blank" rel="noopener" href="http://blog.csdn.net/fbysss/article/details/5437157">http://blog.csdn.net/fbysss/article/details/5437157</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/how-websites-fit-Retina-screens/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/how-websites-fit-Retina-screens/" class="post-title-link" itemprop="url">网站如何适配Retina屏幕</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-08-28 00:37:21" itemprop="dateCreated datePublished" datetime="2014-08-28T00:37:21+08:00">2014-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>随着2012年苹果发布第一款Retina Macbook Pro（以下简称RMBP），Retina屏幕开始进入笔记本行业。两年过去了，RMBP的市场占有率越来越高，且获得了一大批设计师朋友的青睐，网站对于Retina屏幕的适配越来越重要。 如果大家对于Retina适配的重要性不是特别清楚，请看我的两个截图： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/08/QQ20140827-1@2x.jpg"><img data-src="http://storage.veitor.net/uploads/2014/08/QQ20140827-1@2x.jpg" alt="QQ20140827-1@2x"></a> 上图是Google的首页LOGO，我们对比下图SOSO的LOGO： <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/08/QQ20140827-2@2x.jpg"><img data-src="http://storage.veitor.net/uploads/2014/08/QQ20140827-2@2x.jpg" alt="QQ20140827-2@2x"></a> 如果大家还是看不出来，请自行访问这两个网站或者下载附件的截图对比。 那么说完了重要性，适配Retina的原理又是什么呢？我们知道，当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保 真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情 形。换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。（摘自《走向视网膜（Retina）的Web时代》） 那么，解决方法相信大家也都听过，就是通过手动制图或以编程的方式制作两种不同的图形，一张是普通屏幕的图片，另外一种是Retina屏幕的图形，而且Retina屏幕下的图片是普通屏幕的两倍像素。 原理虽然简单，在现实中要实现就不仅仅如此，需综合考虑加载速度，浏览器适配等多方面因素，本文就是教大家如何对Retina的屏幕进行适配。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="1-直接加载2倍大小的图片。"><a href="#1-直接加载2倍大小的图片。" class="headerlink" title="1.直接加载2倍大小的图片。"></a><strong>1.直接加载2倍大小的图片。</strong></h3><p>假如要显示的图片大小为200px*300px，你准备的实际图片大小应该为400px*600px，并且使用以下代码控制即可：</p>
<img data-src="pic.png" height="200px" width="300px" />

<p>这种方法就解决了Retina显示不清楚的问题，但是在普通屏幕下，这种图片要经过浏览器的压缩，在IE6和IE7上有十分差得显示效果，同时，两倍大小的图片势必会导致页面加载时间加长，用户体验下降，此时，我们可以通过Retina.js（<a target="_blank" rel="noopener" href="http://retinajs.com/">http://retinajs.com/</a>）文件解决：</p>
<pre><code>&lt;img class=&quot;pic&quot; src=&quot;pic.png&quot; height=&quot;200px&quot; width=&quot;300px&quot;/&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function () &#123;
if (window.devicePixelRatio &gt; 1) &#123;
var images = $(&quot;img.pic&quot;);
images.each(function(i) &#123;
var x1 = $(this).attr(&#39;src&#39;);
var x2 = x1.replace(/(.*)(.w+)/, &quot;$1@2x$2&quot;);
$(this).attr(&#39;src&#39;, x2);
&#125;);
&#125;
&#125;);
&lt;/script&gt;
</code></pre>
<p> </p>
<h3 id="2-Image-set控制"><a href="#2-Image-set控制" class="headerlink" title="2.Image-set控制"></a>2.Image-set控制</h3><p>假如要显示的图片大小为200px*300px，你准备的图片应有两张：一张大小为200px*300px，命名为pic.png；另一张大小为 400px*600px，命名为<a href="mailto:&#x70;&#105;&#x63;&#64;&#x32;&#120;&#46;&#x70;&#110;&#x67;">&#x70;&#105;&#x63;&#64;&#x32;&#120;&#46;&#x70;&#110;&#x67;</a>（@2x是Retina图标的标准命名方式），然后使用以下css代码控制：</p>
<pre><code>#logo &#123;
background: url(pic.png) 0 0 no-repeat;
background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x);
background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x);
background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);
&#125;
</code></pre>
<p>或者使用HTML代码控制亦可：</p>
<img data-src="pic.png" srcset="pic@2x.png 2x" />

<p> </p>
<h3 id="3-使用-media控制"><a href="#3-使用-media控制" class="headerlink" title="3.使用@media控制"></a>3.使用@media控制</h3><p>实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下：</p>
<pre><code>@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
       only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */
       only screen and (-o-min-device-pixel-ratio: 3/2),
       only screen and (min-device-pixel-ratio: 1.5) &#123;
#logo &#123;
background-image: url(pic@2x.png);
background-size: 100px auto;
&#125;
&#125;
</code></pre>
<p>使用这个的确定就是IE6、7、8不支持@media，所以无效。但是如果你只是支持苹果的RMBP的话，不存在兼容问题，因为MacOS X上压根没有IE！哈哈哈！ <strong>OK，本文到这里就结束了，介绍了上面的三个办法大家可以各有取舍的使用吧~</strong> 附件：<a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/08/76757.1946.zip">附件</a> 原文地址：<a target="_blank" rel="noopener" href="http://www.ui.cn/project.php?id=24556">http://www.ui.cn/project.php?id=24556</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/wget-command-in-Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/wget-command-in-Linux/" class="post-title-link" itemprop="url">Linux操作系统之wget命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-08-22 02:50:53" itemprop="dateCreated datePublished" datetime="2014-08-22T02:50:53+08:00">2014-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Linux系统中的wget是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。 wget 可 以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时 候，wget 遵循Robot Exclusion标准(&#x2F;robots.txt). wget可以在下载的同时，将链接转换成指向本地文件，以方便离线 浏览。 wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 1．命令格式： wget [参数] [URL地址] 2．命令功能： 用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget虽然功能强大，但是使用起来还是比较简单： 1）支持断点下传功能；这一点，也是网络蚂蚁和FlashGet当年最大的卖点，现在，Wget也可以使用此功能，那些网络不是太好的用户可以放心了； 2）同时支持FTP和HTTP下载方式；尽管现在大部分软件可以使用HTTP方式下载，但是，有些时候，仍然需要使用FTP方式下载软件； 3）支持代理服务器；对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能； 4）设置方便简单；可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标； 5）程序小，完全免费；程序小可以考虑不计，因为现在的硬盘实在太大了；完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的。 3．命令参数： 启动参数： -V, –version 显示wget的版本后退出 -h, –help 打印语法帮助 -b, –background 启动后转入后台执行 -e, –execute&#x3D;COMMAND 执行<code>.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc 记录和输入文件参数： -o, –output-file=FILE 把记录写到FILE文件中 -a, –append-output=FILE 把记录追加到FILE文件中 -d, –debug 打印调试输出 -q, –quiet 安静模式(没有输出) -v, –verbose 冗长模式(这是缺省设置) -nv, –non-verbose 关掉冗长模式，但不是安静模式 -i, –input-file=FILE 下载在FILE文件中出现的URLs -F, –force-html 把输入文件当作HTML格式文件对待 -B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀 –sslcertfile=FILE 可选客户端证书 –sslcertkey=KEYFILE 可选客户端证书的KEYFILE –egd-file=FILE 指定EGD socket的文件名 下载参数： –bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用) -t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制). -O –output-document=FILE 把文档写到FILE文件中 -nc, –no-clobber 不要覆盖存在的文件或使用.#前缀 -c, –continue 接着下载没下载完的文件 –progress=TYPE 设定进程条标记 -N, –timestamping 不要重新下载文件除非比本地文件新 -S, –server-response 打印服务器的回应 –spider 不下载任何东西 -T, –timeout=SECONDS 设定响应超时的秒数 -w, –wait=SECONDS 两次尝试之间间隔SECONDS秒 –waitretry=SECONDS 在重新链接之间等待1…SECONDS秒 –random-wait 在下载之间等待0…2*WAIT秒 -Y, –proxy=on/off 打开或关闭代理 -Q, –quota=NUMBER 设置下载的容量限制 –limit-rate=RATE 限定下载输率 目录参数： -nd –no-directories 不创建目录 -x, –force-directories 强制创建目录 -nH, –no-host-directories 不创建主机目录 -P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/… –cut-dirs=NUMBER 忽略 NUMBER层远程目录 HTTP 选项参数： –http-user=USER 设定HTTP用户名为 USER. –http-passwd=PASS 设定http密码为 PASS -C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许) -E, –html-extension 将所有text/html文档以.html扩展名保存 –ignore-length 忽略 \</code>Content-Length’头域 –header&#x3D;STRING 在headers中插入字符串 STRING –proxy-user&#x3D;USER 设定代理的用户名为 USER –proxy-passwd&#x3D;PASS 设定代理的密码为 PASS –referer&#x3D;URL 在HTTP请求中包含 `Referer: URL’头 -s, –save-headers 保存HTTP头到文件 -U, –user-agent&#x3D;AGENT 设定代理的名称为 AGENT而不是 Wget&#x2F;VERSION –no-http-keep-alive 关闭 HTTP活动链接 (永远链接) –cookies&#x3D;off 不使用 cookies –load-cookies&#x3D;FILE 在开始会话前从文件 FILE中加载cookie –save-cookies&#x3D;FILE 在会话结束后将 cookies保存到 FILE文件中 FTP 选项参数： -nr, –dont-remove-listing 不移走 <code>.listing’文件 -g, –glob=on/off 打开或关闭文件名的 globbing机制 –passive-ftp 使用被动传输模式 (缺省值). –active-ftp 使用主动传输模式 –retr-symlinks 在递归的时候，将链接指向文件(而不是目录) 递归下载参数： -r, –recursive 递归下载－－慎用! -l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷) –delete-after 在现在完毕后局部删除文件 -k, –convert-links 转换非相对链接为相对链接 -K, –backup-converted 在转换文件X之前，将之备份为 X.orig -m, –mirror 等价于 -r -N -l inf -nr -p, –page-requisites 下载显示HTML文件的所有图片 递归下载中的包含和不包含(accept/reject)： -A, –accept=LIST 分号分隔的被接受扩展名的列表 -R, –reject=LIST 分号分隔的不被接受的扩展名的列表 -D, –domains=LIST 分号分隔的被接受域的列表 –exclude-domains=LIST 分号分隔的不被接受的域的列表 –follow-ftp 跟踪HTML文档中的FTP链接 –follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表 -G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表 -H, –span-hosts 当递归时转到外部主机 -L, –relative 仅仅跟踪相对链接 -I, –include-directories=LIST 允许目录的列表 -X, –exclude-directories=LIST 不被包含目录的列表 -np, –no-parent 不要追溯到父目录 wget -S –spider url 不下载只显示过程 4．使用实例： 实例1：使用wget下载单个文件 命令： wget http://www.minjieren.com/wordpress-3.1-zh\_CN.zip 说明： 以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。 实例2：使用wget -O下载并以不同的文件名保存 命令： : wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080 说明： wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。 错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存 wget http://www.minjieren.com/download?id=1 即使下载的文件是zip格式，它仍然以download.php?id=1080命令。 正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名： wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080 实例3：使用wget –limit -rate限速下载 命令： wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh\_CN.zip 说明： 当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。 实例4：使用wget -c断点续传 命令： wget -c http://www.minjieren.com/wordpress-3.1-zh\_CN.zip 说明： 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 实例5：使用wget -b后台下载 命令： wget -b http://www.minjieren.com/wordpress-3.1-zh\_CN.zip 说明： 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。 wget -b http://www.minjieren.com/wordpress-3.1-zh\_CN.zip Continuing in background, pid 1840. Output will be written to </code>wget-log’. 你可以使用以下命令来察看下载进度： tail -f wget-log 实例6：伪装代理名称下载 命令： wget –user-agent&#x3D;”Mozilla&#x2F;5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit&#x2F;534.16 (KHTML, like Gecko) Chrome&#x2F;10.0.648.204 Safari&#x2F;534.16” <a target="_blank" rel="noopener" href="http://www.minjieren.com/wordpress-3.1-zh/_CN.zip">http://www.minjieren.com/wordpress-3.1-zh\_CN.zip</a> 说明： 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。 实例7：使用wget –spider测试下载链接 命令： wget –spider URL 说明： 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。 wget –spider URL 如果下载链接正确，将会显示 wget –spider URL Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response… 200 OK Length: unspecified [text&#x2F;html] Remote file exists and could contain further links, but recursion is disabled – not retrieving. 这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误 wget –spider url Spider mode enabled. Check if remote file exists. HTTP request sent, awaiting response… 404 Not Found Remote file does not exist – broken link!!! 你可以在以下几种情况下使用spider参数： 定时下载之前进行检查 间隔检测网站是否可用 检查网站页面的死链接 实例8：使用wget –tries增加重试次数 命令： wget –tries&#x3D;40 URL 说明： 如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。 实例9：使用wget -i下载多个文件 命令： wget -i filelist.txt 说明： 首先，保存一份下载链接文件 cat &gt; filelist.txt url1 url2 url3 url4 接着使用这个文件和参数-i下载 实例10：使用wget –mirror镜像网站 命令： wget –mirror -p –convert-links -P .&#x2F;LOCAL URL 说明： 下载整个网站到本地。 –miror:开户镜像下载 -p:下载所有为了html页面显示正常的文件 –convert-links:下载后，转换成本地的链接 -P .&#x2F;LOCAL：保存所有文件和目录到本地指定目录 实例11：使用wget –reject过滤指定格式下载 命令： wget –reject&#x3D;gif ur 说明： 下载一个网站，但你不希望下载图片，可以使用以下命令。 实例12：使用wget -o把下载信息存入日志文件 命令： wget -o download.log URL 说明： 不希望下载信息直接显示在终端而是在一个日志文件，可以使用 实例13：使用wget -Q限制总下载文件大小 命令： wget -Q5m -i filelist.txt 说明： 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 实例14：使用wget -r -A下载指定格式文件 命令： wget -r -A.pdf url 说明： 可以在以下情况使用该功能： 下载一个网站的所有图片 下载一个网站的所有视频 下载一个网站的所有PDF文件 实例15：使用wget FTP下载 命令： wget ftp-url wget –ftp-user&#x3D;USERNAME –ftp-password&#x3D;PASSWORD url 说明： 可以使用wget来完成ftp链接的下载。 使用wget匿名ftp下载： wget ftp-url 使用wget用户名和密码认证的ftp下载 wget –ftp-user&#x3D;USERNAME –ftp-password&#x3D;PASSWORD url 备注：编译安装 使用如下命令编译安装： # tar zxvf wget-1.9.1.tar.gz # cd wget-1.9.1 # .&#x2F;configure # make # make install</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/wordpress-article-with-picture-sync-to-sina-weibo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/wordpress-article-with-picture-sync-to-sina-weibo/" class="post-title-link" itemprop="url">wordpress文章带图片同步到新浪微博</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-08-18 14:13:59" itemprop="dateCreated datePublished" datetime="2014-08-18T14:13:59+08:00">2014-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/08/1392117921664.jpg"><img data-src="http://storage.veitor.net/uploads/2014/08/1392117921664.jpg" alt="1392117921664"></a> 今天终于能把个人博客上的文章及文中图片一起同步到新浪微博了，在此发文纪念一下，并带图同步到我的微博测试。并且与大家一起分享一下经验，想必也有很多朋友在同步到微博的时候，遇到了传图的问题。 此前我都是使用多说评论框的接口同步到微博的，但为了能拥有自己的微博来源小尾巴，就自己开发一个。 首先你当然得有微博开放平台的帐号，并申请通过了网站应用审核。其次就是调用API接口了。 新浪微博有个高级接口，能发布一条微博并指定上传图片的url，这个接口由于需要申请使用，比较麻烦，还不如自己用另一个接口来实现锻炼一下自己。这里我使用的是<a target="_blank" rel="noopener" href="https://upload.api.weibo.com/2/statuses/upload.json">https://upload.api.weibo.com/2/statuses/upload.json</a> 这个接口（<a target="_blank" rel="noopener" href="http://open.weibo.com/wiki/2/statuses/upload">详情见这</a>）</p>
<p>必选</p>
<p>类型及范围</p>
<p>说明</p>
<p>source</p>
<p>false</p>
<p>string</p>
<p>采用OAuth授权方式不需要此参数，其他授权方式为必填参数，数值为应用的AppKey。</p>
<p>access_token</p>
<p>false</p>
<p>string</p>
<p>采用OAuth授权方式为必填参数，其他授权方式不需要此参数，OAuth授权后获得。</p>
<p>status</p>
<p>true</p>
<p>string</p>
<p>要发布的微博文本内容，必须做URLencode，内容不超过140个汉字。</p>
<p>visible</p>
<p>false</p>
<p>int</p>
<p>微博的可见性，0：所有人能看，1：仅自己可见，2：密友可见，3：指定分组可见，默认为0。</p>
<p>list_id</p>
<p>false</p>
<p>string</p>
<p>微博的保护投递指定分组ID，只有当visible参数为3时生效且必选。</p>
<p>pic</p>
<p>true</p>
<p>binary</p>
<p>要上传的图片，仅支持JPEG、GIF、PNG格式，图片大小小于5M。</p>
<p>lat</p>
<p>false</p>
<p>float</p>
<p>纬度，有效范围：-90.0到+90.0，+表示北纬，默认为0.0。</p>
<p>long</p>
<p>false</p>
<p>float</p>
<p>经度，有效范围：-180.0到+180.0，+表示东经，默认为0.0。</p>
<p>annotations</p>
<p>false</p>
<p>string</p>
<p>元数据，主要是为了方便第三方应用记录一些适合于自己使用的信息，每条微博可以包含一个或者多个元数据，必须以json字串的形式提交，字串长度不超过512个字符，具体内容可以自定。</p>
<p>rip</p>
<p>false</p>
<p>string</p>
<p>开发者上报的操作用户真实IP，形如：211.156.0.1。</p>
<p>文档规定的参数有以上这些，我只用到了source、status和pic三个参数就行了，当然你可以获得access_token来代替source（本文使用source讲解）。 上传图片等流媒体文件需要使用<strong>multipart&#x2F;form-data</strong>编码方式，这和我们平常使用的表单上传文件类似。提交时会向服务器端发出这样的数据（如下代码，已经去除部分不相关的头信息）。</p>
<p>POST &#x2F; HTTP&#x2F;1.1<br>Content-Type:application&#x2F;x-www-form-urlencoded<br>Accept-Encoding: gzip, deflate<br>Host: weibo.com<br>Content-Length: 21<br>Connection: Keep-Alive<br>Cache-Control: no-cache<br>txt1&#x3D;hello&amp;txt2&#x3D;world</p>
<p>对于普通的HTML Form POST请求，它会在头信息里使用Content-Length注明内容长度。头信息每行一条，空行之后便是Body，即“内容”（entity）。它的Content-Type是application&#x2F;x-www-form-urlencoded，这意味着消息内容会经过URL编码，就像在GET请 求时URL里的QueryString那样。txt1&#x3D;hello&amp;txt2&#x3D;world 最早的HTTP POST是不支持文件上传的，给编程开发带来很多问题。但是在1995年，ietf出台了rfc1867,也就是《RFC 1867 -Form-based File Upload in HTML》，用以支持文件上传。所以Content-Type的类型扩充了multipart&#x2F;form-data用以支持向服务器发送二进制数据。因此发送post请求时候，表单 属性enctype共有二个值可选，这个属性管理的是表单的MIME编码： ①application&#x2F;x-www-form-urlencoded(默认值) ②multipart&#x2F;form-data 其实form表单在你不写enctype属性时，也默认为其添加了enctype属性值，默认值是enctype&#x3D;”application&#x2F;x- www-form-urlencoded”. 通过form表单提交文件操作如下：</p>
<form method="post"action="http://w.sohu.com/t2/upload.do" enctype=”multipart/form-data”>
<inputtype="text" name="desc">
<inputtype="file" name="pic">
</form>

<p>浏览器会发送以下数据：</p>
<p>POST &#x2F;t2&#x2F;upload.do HTTP&#x2F;1.1<br>User-Agent: SOHUWapRebot<br>Accept-Language: zh-cn,zh;q&#x3D;0.5<br>Accept-Charset: GBK,utf-8;q&#x3D;0.7,*;q&#x3D;0.7<br>Connection: keep-alive<br>Content-Length: 60408<br>Content-Type:multipart&#x2F;form-data; boundary&#x3D;ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Host: weibo.com<br>–ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition: form-data;name&#x3D;”desc”<br>Content-Type: text&#x2F;plain; charset&#x3D;UTF-8<br>Content-Transfer-Encoding: 8bit<br>–ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC<br>Content-Disposition: form-data;name&#x3D;”pic”; filename&#x3D;”photo.jpg”<br>Content-Type: application&#x2F;octet-stream<br>Content-Transfer-Encoding: binary<br>[图片二进制数据]<br>–ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC–</p>
<p>先分析一下上面的内容，<strong>然后我们来根据这内容来构造发送的数据。</strong> 第7行指定发送编码是multipart&#x2F;form-data，并且指定boundary值为“ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC”，这个值可以随机产生，不难理解，boundary就是来分隔数据的。并且每段分隔时boundary值前面需要加“–”，最后结尾处在boundary值的前后加”–”（看上面代码最后一行）。 每段boundary之内，先是数据描述，再是数据的主体。 <a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/08/QQ%E6%88%AA%E5%9B%BE20140818215404.jpg"><img data-src="http://storage.veitor.net/uploads/2014/08/QQ%E6%88%AA%E5%9B%BE20140818215404.jpg" alt="QQ截图20140818215404"></a>   <strong>现在放上我构造的代码，自己琢磨一下就明白了：</strong></p>
<p>function post_to_sina_weibo($post_ID) {<br>  if( wp_is_post_revision($post_ID) ) return;<br>    $get_post_info &#x3D; get_post($post_ID);<br>    &#x2F;&#x2F;发布的文章内容，带所有标签格式<br>    $get_post_centent &#x3D; get_post($post_ID)-&gt;post_content;<br>    &#x2F;&#x2F;用正则表达式抠图<br>    preg_match_all(‘&#x2F;&lt;img.*?(?: |\\t|\\r|\\n)?src&#x3D;[\‘“]?(.+?)[\‘“]?(?:(?: |\\t|\\r|\\n)+.*?)?&gt;&#x2F;sim’, $get_post_centent, $strResult, PREG_PATTERN_ORDER);<br>   if(count($strResult[1]) &gt; 0)<br>        $imgUrl &#x3D; $strResult[1][0];&#x2F;&#x2F;获得第一张图url地址<br>   else<br>        $imgUrl &#x3D; null;<br>    &#x2F;&#x2F;去掉文章内的html编码的空格、换行、tab等符号<br>    $get_post_centent &#x3D; str_replace(“\t”, “ “, str_replace(“\n”, “ “, str_replace(“&nbsp;”, “ “, $get_post_centent)));<br>    &#x2F;&#x2F;获取文章标题<br>    $get_post_title &#x3D; get_post($post_ID)-&gt;post_title;<br>    if ( $get_post_info-&gt;post_status &#x3D;&#x3D; ‘publish’ &amp;&amp; $_POST[‘original_post_status’] !&#x3D; ‘publish’ ) {<br>    &#x2F;&#x2F;使用wordpress内置request请求类，在wp_includes&#x2F;wp_http.php里<br>    $request &#x3D; new WP_Http;<br>    &#x2F;&#x2F;微博文字，格式为“【文章标题】文章摘要132字，全文地址：XXXX”<br>    $status &#x3D; ‘【’ . strip_tags( $get_post_title ) . ‘】 ‘ . mb_strimwidth(strip_tags( apply_filters(‘the_content’, $get_post_centent)),0, 132,’…’) . ‘ 全文地址:’ . get_permalink($post_ID) ;<br>    &#x2F;&#x2F;如果没图片则请求这个api<br>    $api_url &#x3D; ‘<a target="_blank" rel="noopener" href="https://api.weibo.com/2/statuses/update.json">https://api.weibo.com/2/statuses/update.json</a>‘;<br>    &#x2F;&#x2F;body内容，source参数为你的appkey，详情见wordpress的WP_http类<br>    $body &#x3D; array( ‘status’ &#x3D;&gt; $status, ‘source’&#x3D;&gt;’706960568’);<br>    &#x2F;&#x2F;请将xxxxxxxxx替换成你的，xxxxxxxxxx为“用户名：密码”的base64编码<br>    $headers &#x3D; array( ‘Authorization’ &#x3D;&gt; ‘Basic ‘ . ‘xxxxxxxxxxxxxxxx’ );<br>    &#x2F;&#x2F;重要步骤，如果文章有图片则构造发送数据包<br>    if($imgUrl!&#x3D;&#x3D;null)<br>    {<br>        $body[‘pic’] &#x3D; $imgUrl;<br>        uksort($body, ‘strcmp’);<br>        $str_b&#x3D;uniqid(‘——————‘);<br>        $str_m&#x3D;’–’.$str_b;<br>        $str_e&#x3D;$str_m. ‘–’;<br>        $tmpbody&#x3D;’’;<br>        &#x2F;&#x2F;对参数遍历，进行构造内容，仔细阅读，你会发现和上面讲的类似<br>        foreach($body as $k&#x3D;&gt;$v){<br>            if($k&#x3D;&#x3D;’pic’){<br>                $img_c&#x3D;file_get_contents($imgUrl);<br>                $url_a&#x3D;explode(‘?’, basename($imgUrl));<br>                $img_n&#x3D;$url_a[0];<br>                $tmpbody.&#x3D;$str_m.”\r\n”;<br>                $tmpbody.&#x3D;’Content-Disposition: form-data; name&#x3D;”‘.$k.’”; filename&#x3D;”‘.$img_n.’”‘.”\r\n”;<br>                $tmpbody.&#x3D;”Content-Type: image&#x2F;unknown\r\n\r\n”;<br>                $tmpbody.&#x3D;$img_c.”\r\n”;<br>            }else{<br>                $tmpbody.&#x3D;$str_m.”\r\n”;<br>                $tmpbody.&#x3D;’Content-Disposition: form-data; name&#x3D;”‘.$k.”\“\r\n\r\n”;<br>                $tmpbody.&#x3D;$v.”\r\n”;<br>            }<br>        }<br>        $tmpbody.&#x3D;$str_e;<br>        $body &#x3D; $tmpbody;<br>        &#x2F;&#x2F;图片处理结束，使用uploade API<br>        $api_url &#x3D; ‘<a target="_blank" rel="noopener" href="https://upload.api.weibo.com/2/statuses/upload.json">https://upload.api.weibo.com/2/statuses/upload.json</a>‘;<br>        &#x2F;&#x2F;设置Content-Type编码为multipart&#x2F;form-data<br>        $headers[‘Content-Type’] &#x3D; ‘multipart&#x2F;form-data; boundary&#x3D;’.$str_b;<br>    }<br>    &#x2F;&#x2F;请求接口发送数据，详见wordpress自带的WP_http类<br>    $result &#x3D; $request-&gt;post( $api_url , array( ‘body’ &#x3D;&gt; $body, ‘headers’ &#x3D;&gt; $headers ) );<br>}<br>&#x2F;&#x2F;最后将这个函数挂到pulish_post钩子上，发表文章后就会触发这个函数<br>add_action(‘publish_post’, ‘post_to_sina_weibo’, 0);</p>
<p>  这段代码理论上来说你可以拿去直接用了，只需按注释上说的修改几个参数为自己的就行了。 这也是我研究琢磨出来的，有任何疑问可以一起探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/take-big-data-with-mysql-unbuffered-query-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/take-big-data-with-mysql-unbuffered-query-function/" class="post-title-link" itemprop="url">用mysql_unbuffered_query函数取大数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-08-13 12:52:04" itemprop="dateCreated datePublished" datetime="2014-08-13T12:52:04+08:00">2014-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>昨天在做项目的时候，因为涉及到数据表结构的改动，需要进行大量数据的导入，那么如何高效的进行是我比较关注的。本文暂且从使用PHP脚本层面上来说，因为使用其他语言或其他方式也可以进行数据的重导。 在讨论这个问题的时候，前辈给我的意见就是单独做一个脚本，如果能拿python做更好，当然，python我还不是很会，所以拿php也能完成。既然这样，就采用最原生的方式来进行数据的重导。 整个过程中要先从一张表中取出全部数据，再进行数据的处理后导入到新的数据表中。而就我测试的那个数据库中的那张表里，数据量就已经上万了，如果直接全部取出必定会有性能上的问题。 他人给我的建议是，使用mysql_connect后用mysql_query执行sql（取大数据的情况如sele ct * from tbl）语句，理由是mysql_query不是返回的数据结果，因为后面用到mysql_fetch_assoc之类的函数，进行游标的移动来取得数据。并在sql执行前后分别使用了memory_get_usage来查看内存使用量。当然，执行后内存使用量比执行前大了，虽然使用了不多的内存，但对于只是测试数据库里的数据而言还行，当数据处理量很大的时候，php程序脚本可能会崩溃。为了确保重导真正线上数据库的数据万无一失，我还是查了一些相关资料。 最后了解到PHP中有个mysql_unbuffered_query这个函数，与mysql_query有点类似，手册上写了该函数不缓存的查询结果，它所带来的好处就是<strong>一不用缓存结果，二就是不必等待全部查询后进行操作，而是直接获取一条数据就可以操作</strong>。而mysql_query是查询出所有符合条件的结果并缓存后才能进行操作，这就让我怀疑之前建议的那个方法。 于是我同样用mysql_unbuffered_query查询同样一条sql语句，也同样对执行前后查看了内存使用量，结果前后内存使用量没有变，这就说明了内存并没有被拿来做查询数据缓存的相关事情。当然也可以使用以下方法来测试：</p>
<p>   $link &#x3D; mysql_con nect(‘localhost’,’root’,’root’);<br>   mysql_select_ db(‘phpcms’);<br>   $sql &#x3D; “SEL ECT * FROM `phpcms_content`“;<br>   &#x2F;&#x2F;$result &#x3D; mysql_unbuffered_query($sql,$link);<br>   $result &#x3D; mysql_query($sql,$link);<br>   while ($row &#x3D; mysql_fe tch_array($result, MYSQL_NUM)) {<br>      printf (“ID: %s Name: %s”, $row[0], $row[1]);<br>   }<br>   mysql_data_seek($result,0);<br>   echo “<br/>“;<br>   while ($row &#x3D; mysql_fetch_array($result, MYSQL_NUM)) {<br>      printf (“ID: %s Name: %s”, $row[0], $row[1]);<br>   }<br>    mysql_free_result($result);</p>
<p>你会发现使用mysql_query会输出两次，而mysql_unbuffered_query只输出一次，说明使用mysql_query查询结果必定被缓存了，而使用mysql_unbuffered_query则边进行查询边给出结果。 最后再说明，使用mysql_unbuffered_query的话，不能使用mysql_num_rows()和mysql_data_seek()这也正因为它的特性方式决定了这样。还有比较重要的一点，如果你只是单单获取大数据量使用这个函数可以，<strong>但是，如果你在取得大数据的时候，使用while($row &#x3D; mysql_fetch_assoc($result))方式进行执行新的sql语句的话，会出错。手册上也写明了，在执行一条心的sql之前，要提取所有未缓存的sql查询所产生的行。</strong>所以只使用mysql_unbuffered_query取数据可以，但期间还要执行其他sql就不行了。 以上只是我对这个函数的初步认识，如果理解有误，也希望能指正交流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/difference-among-PHP-SELF-SCRIPT-NAME-SCRIPT-FILENAME-PATH-INFO-REQUEST-URI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/difference-among-PHP-SELF-SCRIPT-NAME-SCRIPT-FILENAME-PATH-INFO-REQUEST-URI/" class="post-title-link" itemprop="url">PHP_SELF，SCRIPT_NAME，SCRIPT_FILENAME，PATH_INFO，REQUEST_URI的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-08-05 00:35:05" itemprop="dateCreated datePublished" datetime="2014-08-05T00:35:05+08:00">2014-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a target="_blank" rel="noopener" href="http://www.php.net/" title="PHP Hypertext Preprocessor">PHP</a>的<a target="_blank" rel="noopener" href="http://cn2.php.net/reserved.variables.server.php" title="$_SERVER">$_SERVER</a>数组中存在五个和路径相关的变量：<code>PHP_SELF</code>，<code>SCRIPT_NAME</code>， <code>SCRIPT_FILENAME</code>，<code>PATH_INFO</code>，<code>REQUEST_URI</code>，这五个变量经常会被混淆，做下区分。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>Nginx0.8.54 + FastCGI + PHP5.3.4 要先配置Nginx的<code>PATH_INFO</code>，在<code>nginx.conf</code>中加入如下配置：</p>
<pre><code>location ~ .* .php &#123;
    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    #从$fastcgi_script_name中分离出真正执行的脚本名称和PATH_INFO
    set $real_script_name $fastcgi_script_name;
    if ($fastcgi_script_name ~ &quot;^(.+?.php)(/.+)$&quot;) &#123;
        set $real_script_name $1;
        set $path_info $2;
     &#125;
    #重新设置SCRIPT_FILENAME
    fastcgi_param SCRIPT_FILENAME $document_root$real_script_name;
    fastcgi_param  QUERY_STRING       $query_string;
    fastcgi_param  REQUEST_METHOD     $request_method;
    fastcgi_param  CONTENT_TYPE       $content_type;
    fastcgi_param  CONTENT_LENGTH     $content_length;
    #重新设置SCRIPT_NAME
    fastcgi_param SCRIPT_NAME $real_script_name;
    fastcgi_param PATH_INFO $path_info;
    fastcgi_param  REQUEST_URI        $request_uri;
    fastcgi_param  DOCUMENT_URI       $document_uri;
    fastcgi_param  DOCUMENT_ROOT      $document_root;
    fastcgi_param  SERVER_PROTOCOL    $server_protocol;
    fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
    fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
    fastcgi_param  REMOTE_ADDR        $remote_addr;
    fastcgi_param  REMOTE_PORT        $remote_port;
    fastcgi_param  SERVER_ADDR        $server_addr;
    fastcgi_param  SERVER_PORT        $server_port;
    fastcgi_param  SERVER_NAME        $server_name;
    # PHP only, required if PHP was built with --enable-force-cgi-redirect
    fastcgi_param  REDIRECT_STATUS    200;
&#125;
</code></pre>
<p>我们的根目录为<code>/var/www</code>，测试域名为<code>example.com</code>（不过这个域名只能改<code>hosts</code>文件YY一下了），结构如下：</p>
<pre><code>var
 |---www
       |---test
             |---test.php
</code></pre>
<h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><p>使用如下脚本进行测试：</p>
<pre><code>&lt;?php
    echo &#39;SCRIPT_NAME=&#39; . $_SERVER[&#39;SCRIPT_NAME&#39;] . &#39;&lt;br /&gt;&#39;;
    echo &#39;SCRIPT_FILENAME=&#39; . $_SERVER[&#39;SCRIPT_FILENAME&#39;] . &#39;&lt;br /&gt;&#39;;
    echo &#39;PATH_INFO=&#39; . $_SERVER[&#39;PATH_INFO&#39;] . &#39;&lt;br /&gt;&#39;;
    echo &#39;REQUEST_URI=&#39; . $_SERVER[&#39;REQUEST_URI&#39;] . &#39;&lt;br /&gt;&#39;;
?&gt;
</code></pre>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul>
<li>PHP_SELF: 当前所执行的脚本的文件名，这个值是相对于根目录来说。 如果请求<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php?k=v">http://example.com/test/test.php?k=v</a></strong>，则<code>PHP_SELF</code>的值为 <strong>&#x2F;test&#x2F;test.php</strong>。</li>
<li>SCRIPT_NAME： 当前执行的脚本的路径。 如果请求<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php?k=v">http://example.com/test/test.php?k=v</a></strong>，则<code>SCRIPT_NAME</code>的值 为**&#x2F;test&#x2F;test.php**。这个变量是在<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc3875" title="CGI/1.1">CGI&#x2F;1.1</a>中定义的。</li>
<li>SCRIPT_FILENAME： 当前执行的脚本的绝对路径。 如果请求<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php?k=v">http://example.com/test/test.php?k=v</a></strong>，则<code>SCRIPT_FILENAME</code>的值 为**&#x2F;var&#x2F;www&#x2F;test&#x2F;test.php<strong>。 注意：如果一个脚本以相对路径，<a target="_blank" rel="noopener" href="http://php.net/manual/en/features.commandline.php" title="PHP CLI">CLI</a>方式来执行，例如</strong>..&#x2F;test&#x2F;test.php<strong>，那么 <code>$_SERVER[&#39;SCRIPT_FILENAME&#39;]</code>的值为相对路径，即</strong>..&#x2F;test&#x2F;test.php**。</li>
<li>PATH_INFO：客户端提供的路径信息，即在实际执行脚本后面尾随的内容，但是会去掉<strong>Query String</strong>。 如果请求<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php/a/b?k=v">http://example.com/test/test.php/a/b?k=v</a></strong>，则<code>PATH_INFO</code>的值为**&#x2F;a&#x2F;b**。 <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc3875" title="CGI/1.1">CGI1.1</a>标准中如下描述：”<strong>The PATH_INFO string is the trailing part of thecomponent of the script URI that follows the SCRIPT_NAME part of the path.</strong>“</li>
<li>REQUEST_URI：包含HTTP协议中定义的URI内容。 如果请求<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php?k=v">http://example.com/test/test.php?k=v</a></strong>，则<code>REQUEST_URI</code> 为**&#x2F;test&#x2F;test.php?k&#x3D;v**</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>PHP_SELF VS SCRIPT_NAME： <code>PHP_SELF</code>和<code>SCRIPT_NAME</code>的值在大部分情况下都是一样的，但是访问 <strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php/a/b?k=v">http://example.com/test/test.php/a/b?k=v</a></strong>这类URL时候，<code>PHP_SELF</code> 为**&#x2F;test&#x2F;test.php&#x2F;a&#x2F;b<strong>，<code>SCRIPT_NAME</code>为</strong>&#x2F;test&#x2F;test.php**，可以看出<code>PHP_SELF</code> 比<code>SCRIPT_NAME</code>多了<code>PATH_INFO</code>的内容。</p>
</li>
<li><p>REQUEST_URI VS SCRIPT_NAME： 在访问<strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php?k=v">http://example.com/test/test.php?k=v</a></strong>后，<code>REQUEST_URI</code> 为**&#x2F;test&#x2F;test.php?k&#x3D;v<strong>，<code>SCRIPT_NAME</code>为</strong>&#x2F;test&#x2F;test.php<strong>，可以看出<code>REQUEST_URI</code> 比<code>SCRIPT_NAME</code>多了</strong>Query String<strong>。 如果</strong><a target="_blank" rel="noopener" href="http://example.com/test/test.php**%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%81%9A%E4%BA%86**rewrite**%EF%BC%9A">http://example.com/test/test.php**在服务器端做了**rewrite**：</a></p>
<pre><code>  rewrite /test/test.php /test/test2.php;
</code></pre>
<p>那么<code>REQUEST_URI</code>为**&#x2F;test&#x2F;test.php<strong>，<code>SCRIPT_NAME</code>为</strong>&#x2F;test&#x2F;test2.php**。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/draft-robinson-www-interface-00">http://tools.ietf.org/html/draft-robinson-www-interface-00</a> <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri">http://stackoverflow.com/questions/279966/php-self-vs-path-info-vs-script-name-vs-request-uri</a> <a target="_blank" rel="noopener" href="http://ca.php.net/manual/en/reserved.variables.server.php">http://ca.php.net/manual/en/reserved.variables.server.php</a> (完)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/responsive-and-adaptive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/responsive-and-adaptive/" class="post-title-link" itemprop="url">两个宜于『统一Web』的方案：响应式与自适应</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-07-30 05:39:14" itemprop="dateCreated datePublished" datetime="2014-07-30T05:39:14+08:00">2014-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://storage.veitor.net/uploads/2014/07/1377683186626.jpg"><img data-src="http://storage.veitor.net/uploads/2014/07/1377683186626.jpg" alt="1377683186626"></a>你大概早就听别人说过我们正处在『后PC时代』。那么它对于Web开发者来说意味着什么呢？它意味着你那网站的30%到50%的流量如今已经来自移动设备。意味着很快，使用台式机和笔记本访问Web的人将逐渐减少。 （那么）我们该如何在用户行为上处理这种结构性转变？我们已经逾越了用M-dot或T-dot来hack的阶段，开始步入一个由响应式与自适应设计 技术统治的时代——即W3C联盟口中的统一化Web来临。W3C议案的关键部分在于『统一化Web意味着，在合理条件下，无论用户使用什么设备，要将相同 的信息与服务传达给他们。』 对于开发者来说，那就意味着统一化Web方案要确保你的站点不仅工作在今天的智能手机和平板电脑上，也要能应付未来那遥未可知的屏幕画面。 目前有三种流行性方案来开发网站：使用<a target="_blank" rel="noopener" href="http://www.webmonkey.com/2013/01/take-responsive-design-beyond-media-queries/">响应式设计</a>、 客户端自适应、服务器端自适应。 这三种方案难分高下，每种都有其自身的优缺点。明智的Web开发者会在实施下一个项目之前权衡各自的利弊。</p>
<h2 id="响应式Web设计"><a href="#响应式Web设计" class="headerlink" title="响应式Web设计"></a>响应式Web设计</h2><p>响应式Web设计是最常见的统一化Web方案。它使用<a target="_blank" rel="noopener" href="http://www.webmonkey.com/2012/01/building-a-responsive-future-friendly-web-for-everyone/">CSS Media Queries</a>根据设备显示器的规格来调整网站的呈现方式。从<a target="_blank" rel="noopener" href="http://www.webmonkey.com/2011/09/the-boston-globe-embraces-responsive-design/">波士顿环球报</a>到迪斯尼站点到Indochino西服网站，响应式站点的数量正在飞速增长。 这种方案的核心优势在于设计者可以为所有设备使用同一模板，仅用CSS来定制不同大小屏幕上内容的呈现方式即可。 然而，一个良好的响应式设计没什么捷径可言。要迈向响应式，团队通常需要进行完全的站点重建。 在设计和测试阶段会非常繁琐，保证为每种可能的设备或内容定制用户体验很困难。我们都见过那样一堆看起来一点儿都不吻合的碎片拼图站点。在移动用户优先考虑的开发过程中，响应式站点设计可以与设备结合得很融洽。对于平板和手提电脑来说，（响应式设计）则<a target="_blank" rel="noopener" href="http://www.webmonkey.com/2012/03/video-progressive-enhancement-2-0/">更有优势</a>。 对响应式站点来说，性能也很可怕。在Mobify公司，我们近期完成了一项对15个流行的响应式电子商务站点的分析。在这些站点中，主页平均加载87个资源、1.9MB的数据量。一些响应式页面可以大到15MB。 之所以数据量这么大是因为响应式方案需考虑到所有设备。你的用户只使用一种设备，但是不得不在使用前等待所有的页面元素和资源加载才行。简单来说，性能影响你的底线。在智能手机端，当用户不得不等上一秒时，转化率会<a target="_blank" rel="noopener" href="http://www.webperformancetoday.com/2011/11/23/case-study-slow-page-load-mobile-business-metrics/">额外降低3.5%</a>。若是达到3秒大关，<a target="_blank" rel="noopener" href="http://www.strangeloopnetworks.com/resources/infographics/web-performance-and-user-expectations/website-abandonment-happens-after-3-seconds/">57%的用户</a>会彻底离开你的站点。 当响应式设计迅速成为普遍的标准时，也为在线电商带来了新的挑战，包括怎样处理图片、怎样优化移动端性能，并且当采用移动优先的方案时，通常意味着网站必须推倒重建。</p>
<h2 id="客户端自适应"><a href="#客户端自适应" class="headerlink" title="客户端自适应"></a>客户端自适应</h2><p>客户端自适应秉承着『为定制的设备 内容传达响应式设计用户体验』的原则。它采用JavaScript丰富站点的功能和独特性。比如，自适应站点只为Retina显示器（比如新款iPad）提供Retina质量的图片，而标准精度显示器接收低质量图片。 自适应设计有两种方案：一种是在客户端生效，在用户的浏览器上；另一种是由Web服务器负荷来检测设备类型并加载正确模板。客户端自适应类型的网站 案例包括个性T恤Threadless和奢侈品闪购ideeli。自适应模板方案的优势在于其复用HTML和JavaScript的能力，简化了项目管理 和测试的更迭。 客户端响应方案意味着你不必完全重构网站。相反你可以基于已有内容布局移动响应。对于专家级开发者而言，这种方案也可以让你针对指定设备或屏幕分辨 率。例如，对Mobify的大多在线时尚零售客户而言，95%的移动端流量来自iPhone。客户端自适应意味着他们可以专门针对苹果智能手机进行优化。 与响应式设计不同，自适应模板确保客户端设备只加载所需资源。因为对设备和特性的检测已经转移到了移动设备自身，类似Akamai和Edgecast的内容分发网络可以在不影响用户体验的情况下使用他们大部分的缓存功能。 客户端自适应比起响应式设计而言有着更高的壁垒。开发者用这项技术需要熟练掌握JavaScript，也依托于网站现有的模板为基础。最后，因为客户端自适应作为现有底层代码上的覆盖物，你需要在网站迁移时让它们作为一个整体。</p>
<h2 id="服务器端自适应"><a href="#服务器端自适应" class="headerlink" title="服务器端自适应"></a>服务器端自适应</h2><p>依赖于服务器插件和自定义用户代理检测器我们也可以通过多种途径得到服务器端自适应方案。使用服务器端自适应的网站包括Etsy，One Kings Lane和OnlineShoes.com。 为什么要选择服务器端自适应？它通常针对每个设备提供独特的模板，允许更多的定制。并且这种方案把设备检测逻辑块放在服务器上，使得小型移动页面加载得更快。除此之外，对于像Magneto这种常见的CMS和电子商务系统来说，还有多种多样可用的服务器端插件。 这种方案不适用于小心脏——通常需要你大幅度改变后端系统，实施起来将会是冗长（和昂贵）的。管理多种模板需要有持续不断的维护成本。最后，当服务 器过载时这种方案还会带来性能问题。当服务器上加载移动用户代理检测器的时候，需要关掉许多部署在CDN上的缓存机制，像Akamai一样，这将导致移动 端和桌面访客的用户体验速率降低。 当然，许多公司仍然在跟响应的基本要领角力，显然还没有准备好面对重口味的自适应。然而，随着竞争的加剧和移动通信流量的上涨，越来越多的团队将在所有三个方法上浅尝辄止，（最终）择出一个最适合他们用户的方案。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备14016154号-1 </a>
  </div>
  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Veitor</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<!-- Giscus comment script with dynamic container insertion -->
<script>
  // 创建一个函数，用于动态插入giscus容器并加载脚本
  function loadGiscus() {
    // 查找.post元素
    const mainInner = document.querySelector('.post');
    
    if (mainInner) {
      // 创建.giscus容器元素
      const giscusContainer = document.createElement('div');
      giscusContainer.className = 'giscus';
      
      // 将容器插入到.post的最尾部
      mainInner.appendChild(giscusContainer);
      
      // 创建giscus脚本元素
      const giscusScript = document.createElement('script');
      giscusScript.src = 'https://giscus.app/client.js';
      giscusScript.setAttribute('data-repo', 'Veitor/veitor.github.io');
      giscusScript.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnkyMjQxOTk3OTU=');
      giscusScript.setAttribute('data-category', 'Article Discussions');
      giscusScript.setAttribute('data-category-id', 'DIC_kwDODV0Ec84CpCCm');
      giscusScript.setAttribute('data-mapping', 'title');
      giscusScript.setAttribute('data-strict', '1');
      giscusScript.setAttribute('data-reactions-enabled', '1');
      giscusScript.setAttribute('data-emit-metadata', '0');
      giscusScript.setAttribute('data-input-position', 'top');
      giscusScript.setAttribute('data-theme', 'preferred_color_scheme');
      giscusScript.setAttribute('data-lang', 'zh-CN');
      giscusScript.setAttribute('data-loading', 'lazy');
      giscusScript.setAttribute('crossorigin', 'anonymous');
      
      // 将脚本添加到页面
      document.body.appendChild(giscusScript);
    } else {
      // 如果.post元素不存在，在页面加载完成后再次尝试
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadGiscus);
      } else {
        // 使用setTimeout延迟重试
        setTimeout(loadGiscus, 100);
      }
    }
  }
  
  // 在DOM内容加载完成后执行
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadGiscus);
  } else {
    // 如果DOM已经加载完成，直接执行
    loadGiscus();
  }
</script>
</body>
</html>
