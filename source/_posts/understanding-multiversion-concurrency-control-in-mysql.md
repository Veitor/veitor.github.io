---
title: 了解mysql中多版本并发控制
tags:
  - mysql
  - 事务
url: 436.html
id: 436
categories:
  - Mysql
date: 2014-12-07 13:27:10
---

前面写的一篇《[了解mysql的并发控制](http://www.veitor.net/article/427.html "了解mysql的并发控制")》中了解了mysql的并发控制，主要是通过锁机制来控制并发的。控制严格的锁会影响性能，反之则影响数据安全性。而mysql的大多数事务性存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。 

**可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。** MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。

<!-- more -->

下面就通过InnoDB的简化版行为说明MVCC是如何工作的： InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（也叫删除时间）。当然存储的并不是实际的时间值，而是系统的版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号作为事务的版本号，用来和查询到的每行记录的版本号进行比较。


下面看一下在REPEATABLE READ（可重复读）隔离级别下，MVCC具体是如何操作的。

> SELECT

InnoDB会根据以下两个条件检查每行记录： a.InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务的读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

> INSERT

InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

> DELETE

InnoDB为删除的每一行保存保存当前系统版本号作为行删除标识。

> UPDATE

InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。   保存这两个额外系统版本号，使大多数读操作都都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都会需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。 MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容。因为READ UNCOMMITTED总是读取到最新的数据行（脏读），而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。（这段内容需要了解mysql隔离级别，请看[这篇文章](http://www.veitor.net/article/319.html "Mysql事务以及隔离级别")） 如果有疑问，欢迎留言探讨。