<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.veitor.net","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"codeblock":{"theme":{"light":"default","dark":"default"},"prism":{"light":"prism-tomorrow.min","dark":"prism-tomorrow.min"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":true,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="IOCInversion of Control（IoC）是一种设计原则，它将程序对象或部分程序的控制权转移到外部容器或框架中。  控制反转（IoC）是一种设计原则Principle（尽管一些人将其称为一种模式Pattern）。 顾名思义，在面向对象设计中，IoC被用于反转不同类型的控制权，以实现松耦合。这里的控制权指的是除了类本身主要职责以外的其他职责。 这些职责即所说的权力，包括： 对应用程序执">
<meta property="og:type" content="article">
<meta property="og:title" content="了解控制反转（IoC）和依赖注入（DI）">
<meta property="og:url" content="http://www.veitor.net/posts/inversion-of-control-ioc-dependency-injection-di/index.html">
<meta property="og:site_name" content="Veitor的技术博客">
<meta property="og:description" content="IOCInversion of Control（IoC）是一种设计原则，它将程序对象或部分程序的控制权转移到外部容器或框架中。  控制反转（IoC）是一种设计原则Principle（尽管一些人将其称为一种模式Pattern）。 顾名思义，在面向对象设计中，IoC被用于反转不同类型的控制权，以实现松耦合。这里的控制权指的是除了类本身主要职责以外的其他职责。 这些职责即所说的权力，包括： 对应用程序执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://storage.veitor.net/2025/12/ioc-patterns.webp">
<meta property="og:image" content="https://storage.veitor.net/2025/12/lossely-coupled-transformation-process.webp">
<meta property="article:published_time" content="2025-12-02T06:43:39.000Z">
<meta property="article:modified_time" content="2025-12-03T08:44:15.993Z">
<meta property="article:author" content="Veitor">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://storage.veitor.net/2025/12/ioc-patterns.webp">


<link rel="canonical" href="http://www.veitor.net/posts/inversion-of-control-ioc-dependency-injection-di/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.veitor.net/posts/inversion-of-control-ioc-dependency-injection-di/","path":"posts/inversion-of-control-ioc-dependency-injection-di/","title":"了解控制反转（IoC）和依赖注入（DI）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>了解控制反转（IoC）和依赖注入（DI） | Veitor的技术博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?c422d42123239fdefb0180ed522d050a"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/components/prism-core.min.js" integrity="sha256-bKrTFt2ZHyT4AE4LnBnAVctYKf9l6XP77kBvltgbjn4=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-AjM0J5XIbiB590BrznLEgZGLnOQWrt62s3BEq65Q/I0=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.30.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha256-9cmf7tcLdXpKsPi/2AWE93PbZpTp4M4tqzFk+lWomjU=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/7.2.0/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>




  <script src="/js/third-party/fancybox.js" defer></script>



  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Veitor的技术博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC"><span class="nav-number">1.</span> <span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%AE%9E%E7%B1%BB%E6%AF%94%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">现实类比：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E7%9A%84%E5%85%B7%E4%BD%93%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">IoC的具体模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dependency-Injection-DI"><span class="nav-number">2.1.</span> <span class="nav-text">Dependency Injection (DI)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method-Pattern%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">模板方法模式（Template Method Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">策略模式（Strategy Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Service-Locator-Pattern%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">服务定位器模式（Service Locator Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Event-Driven-Pattern%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">事件驱动模式（Event-Driven Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">工厂模式（Factory Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">观察者模式（Observer Pattern）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC-%E4%B8%8E-DI-%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">IoC 与 DI 的关键区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-IoC-%E5%92%8C-DI-%E6%A8%A1%E5%BC%8F%E5%B0%86%E9%AB%98%E8%80%A6%E5%90%88%E7%B1%BB%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%9D%BE%E8%80%A6%E5%90%88%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">使用 IoC 和 DI 模式将高耦合类转化为松耦合类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E9%AB%98%E8%80%A6%E5%90%88%E7%9A%84%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">步骤1：高耦合的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">步骤2：使用工厂模式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E9%80%9A%E8%BF%87%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E5%B1%82%E5%AE%9E%E7%8E%B0DIP"><span class="nav-number">4.3.</span> <span class="nav-text">步骤3：通过创建抽象层实现DIP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E4%BD%BF%E7%94%A8IoC%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0DI"><span class="nav-number">4.4.</span> <span class="nav-text">步骤4：使用IoC容器实现DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%EF%BC%9A%E6%9D%BE%E8%80%A6%E5%90%88%E7%9A%84%E7%B1%BB"><span class="nav-number">4.5.</span> <span class="nav-text">最终结果：松耦合的类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DIP-vs-IoC"><span class="nav-number">5.</span> <span class="nav-text">DIP vs IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88DIP%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">依赖倒置原则（DIP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">控制反转（IoC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">关键区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Veitor"
      src="/avatar.jpg">
  <p class="site-author-name" itemprop="name">Veitor</p>
  <div class="site-description" itemprop="description">关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/veitor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;veitor" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/veitor" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;veitor" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Veitor_424" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Veitor_424" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.veitor.net/posts/inversion-of-control-ioc-dependency-injection-di/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpg">
      <meta itemprop="name" content="Veitor">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Veitor的技术博客">
      <meta itemprop="description" content="关注互联网技术，对Java、Golang、Kubernetes、AI应用、云原生架构等感兴趣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="了解控制反转（IoC）和依赖注入（DI） | Veitor的技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          了解控制反转（IoC）和依赖注入（DI）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-02 14:43:39" itemprop="dateCreated datePublished" datetime="2025-12-02T14:43:39+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 16:44:15" itemprop="dateModified" datetime="2025-12-03T16:44:15+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>Inversion of Control（IoC）是一种设计原则，它将程序对象或部分程序的控制权转移到外部容器或框架中。</p>
<ul>
<li>控制反转（IoC）是一种设计原则<code>Principle</code>（尽管一些人将其称为一种模式<code>Pattern</code>）。</li>
<li>顾名思义，在面向对象设计中，IoC被用于反转不同类型的控制权，以实现松耦合。这里的<code>控制权</code>指的是除了类本身主要职责以外的其他职责。</li>
<li>这些职责即所说的权力，包括：<ul>
<li>对应用程序执行流的控制权</li>
<li>对对象创建、依赖的管理、生命周期的控制权</li>
</ul>
</li>
<li>IoC 是一种设计原则，它将程序执行流的控制权从程序自身转移到外部框架或容器中。不再是你的代码主动发起调用，而是你的代码被调用。</li>
<li>用通俗的话来解释：假设你平时自己开车去上班，这意味着你掌控着汽车。而 IoC 原则建议“反转”这种控制权——与其自己开车，不如叫一辆出租车，由司机来驾驶。于是，控制权就从你转移到了出租车司机身上。你无需亲自驾驶，可以把精力放在自己的主要工作上。</li>
<li>IoC 原则有助于设计松耦合的类，使它们更易测试、可维护和可扩展。</li>
</ul>
<span id="more"></span>

<h3 id="现实类比："><a href="#现实类比：" class="headerlink" title="现实类比："></a>现实类比：</h3><p>想象一下你在一家餐厅里：</p>
<ol>
<li>传统控制（无 IoC）：你亲自走进厨房，取来食材，自己做饭并端上桌。整个过程的每一步都由你掌控。</li>
<li>控制反转：你坐在餐桌旁点餐，餐厅负责一切。你把做饭的控制权交给了餐厅，只需通过菜单表达你想要什么，剩下的由餐厅处理。</li>
</ol>
<p>下面是一个没有使用 IoC 的简单技术示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class UserService &#123;
    private DatabaseConnection dbConnection;
    private EmailService emailService;
    
    public UserService() &#123;
        &#x2F;&#x2F; Class creates its own dependencies
        this.dbConnection &#x3D; new MySQLConnection();
        this.emailService &#x3D; new EmailService();
    &#125;
    
    public void registerUser(String username) &#123;
        dbConnection.save(username);
        emailService.sendWelcomeEmail(username);
    &#125;
&#125;</code></pre>
<p>在这示例中，<code>UserService</code>类负责创建和管理其依赖项（<code>DatabaseConnection</code>和<code>EmailService</code>）的生命周期。</p>
<p>使用了IoC后：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class UserService &#123;
    private DatabaseConnection dbConnection;
    private EmailService emailService;
    
    &#x2F;&#x2F; Dependencies are provided from outside
    public UserService(DatabaseConnection dbConnection, EmailService emailService) &#123;
        this.dbConnection &#x3D; dbConnection;
        this.emailService &#x3D; emailService;
    &#125;
    
    public void registerUser(String username) &#123;
        dbConnection.save(username);
        emailService.sendWelcomeEmail(username);
    &#125;
&#125;</code></pre>
<p>这样做的优势：</p>
<ul>
<li>将任务的执行与其具体实现解耦</li>
<li>在不同实现之间切换更加容易</li>
<li>提升程序的模块化程度</li>
<li>通过隔离组件或模拟其依赖，使程序测试更加便捷，同时让组件通过契约进行通信</li>
</ul>
<h2 id="IoC的具体模式"><a href="#IoC的具体模式" class="headerlink" title="IoC的具体模式"></a>IoC的具体模式</h2><p>接下来看一下控制反转（IoC）的主要模式。虽然依赖注入是最常被提及的，但还有其他几种重要的模式：</p>
<p><img data-src="https://storage.veitor.net/2025/12/ioc-patterns.webp" alt="ioc-patterns.webp"></p>
<h3 id="Dependency-Injection-DI"><a href="#Dependency-Injection-DI" class="headerlink" title="Dependency Injection (DI)"></a>Dependency Injection (DI)</h3><p>依赖注入（DI）是 IoC 的一种具体实现形式，它把依赖“注入”到类中，而不是由类自己创建。可以把它理解为：</p>
<ul>
<li>IoC 是<code>Principle</code>原则（“是什么”）</li>
<li>DI 是<code>Pattern</code>模式（“怎么做”）</li>
</ul>
<p>让我们再用一个现实类比来说明：</p>
<p><strong>传统方式（没有使用DI）：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Car &#123;
    private Engine engine;
    
    public Car() &#123;
        &#x2F;&#x2F; Car creates its own engine
        engine &#x3D; new Engine();
    &#125;
&#125;</code></pre>
<p>这就像一辆车自己制造发动机，耦合紧密且缺乏灵活性。</p>
<p><strong>使用了依赖注入：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class Car &#123;
    private Engine engine;
    
    &#x2F;&#x2F; Engine is injected from outside
    public Car(Engine engine) &#123;
        this.engine &#x3D; engine;
    &#125;
&#125;</code></pre>
<p>这就像汽车装配线，在组装过程中发动机由外部提供给汽车。</p>
<p><strong>真实世界中的设计模式示例</strong></p>
<p>让我们来看一个更完整的示例，使用 Spring Framework 的概念：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Interface defining a payment processor
interface PaymentProcessor &#123;
    void processPayment(double amount);
&#125;

&#x2F;&#x2F; Different implementations
class CreditCardProcessor implements PaymentProcessor &#123;
    public void processPayment(double amount) &#123;
        System.out.println(&quot;Processing &quot; + amount + &quot; via Credit Card&quot;);
    &#125;
&#125;

class PayPalProcessor implements PaymentProcessor &#123;
    public void processPayment(double amount) &#123;
        System.out.println(&quot;Processing &quot; + amount + &quot; via PayPal&quot;);
    &#125;
&#125;

&#x2F;&#x2F; Service using payment processor
class OrderService &#123;
    private PaymentProcessor paymentProcessor;
    
    &#x2F;&#x2F; Constructor injection
    public OrderService(PaymentProcessor paymentProcessor) &#123;
        this.paymentProcessor &#x3D; paymentProcessor;
    &#125;
    
    public void placeOrder(double amount) &#123;
        &#x2F;&#x2F; Business logic
        paymentProcessor.processPayment(amount);
    &#125;
&#125;

&#x2F;&#x2F; Using with Spring Framework
@Configuration
class AppConfig &#123;
    @Bean
    public PaymentProcessor paymentProcessor() &#123;
        return new CreditCardProcessor();
    &#125;
    
    @Bean
    public OrderService orderService(PaymentProcessor processor) &#123;
        return new OrderService(processor);
    &#125;
&#125;</code></pre>
<p>这种方式的好处：</p>
<ul>
<li>松耦合：<code>OrderService</code> 无需知道它使用的是哪种支付处理器，只需要知道支付处理器实现了 <code>PaymentProcessor</code> 接口。</li>
<li>可测试性：便于在测试时模拟依赖项，如 <code>PaymentProcessor</code>，以确保 <code>OrderService</code> 的行为符合预期。</li>
<li>灵活性：无需修改 <code>OrderService</code> 即可切换实现，例如从 <code>CreditCardProcessor</code> 切换到 <code>PayPalProcessor</code>。</li>
<li>可维护性：依赖关系显式且集中管理，使代码更易于理解和维护。</li>
</ul>
<h3 id="模板方法模式（Template-Method-Pattern）"><a href="#模板方法模式（Template-Method-Pattern）" class="headerlink" title="模板方法模式（Template Method Pattern）"></a>模板方法模式（Template Method Pattern）</h3><p>这是 IoC 最早的形式之一。程序逻辑的执行流不再由子类控制，而是由父类掌控。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Base template class
abstract class DataMiner &#123;
    &#x2F;&#x2F; Template method - controls the algorithm flow
    public final void mine() &#123;
        openFile();
        extractData();
        parseData();
        analyzeData();
        sendReport();
        closeFile();
    &#125;

    &#x2F;&#x2F; Some concrete methods
    private void openFile() &#123;
        System.out.println(&quot;Opening file...&quot;);
    &#125;
    
    &#x2F;&#x2F; Abstract methods to be implemented by subclasses
    abstract void extractData();
    abstract void parseData();
    
    &#x2F;&#x2F; More concrete methods
    private void analyzeData() &#123;
        System.out.println(&quot;Analyzing data...&quot;);
    &#125;
&#125;

&#x2F;&#x2F; Implementation class
class PDFDataMiner extends DataMiner &#123;
    void extractData() &#123;
        System.out.println(&quot;Extracting data from PDF...&quot;);
    &#125;
    
    void parseData() &#123;
        System.out.println(&quot;Parsing PDF data...&quot;);
    &#125;
&#125;</code></pre>

<h3 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h3><p>该模式允许在运行时通过传递不同的策略来切换行为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Strategy interface
interface SortStrategy &#123;
    void sort(int[] array);
&#125;

&#x2F;&#x2F; Concrete strategies
class QuickSort implements SortStrategy &#123;
    public void sort(int[] array) &#123;
        System.out.println(&quot;Sorting using QuickSort&quot;);
    &#125;
&#125;

class MergeSort implements SortStrategy &#123;
    public void sort(int[] array) &#123;
        System.out.println(&quot;Sorting using MergeSort&quot;);
    &#125;
&#125;

&#x2F;&#x2F; Context class using the strategy
class Sorter &#123;
    private SortStrategy strategy;
    
    public void setStrategy(SortStrategy strategy) &#123;
        this.strategy &#x3D; strategy;
    &#125;
    
    public void performSort(int[] array) &#123;
        strategy.sort(array);
    &#125;
&#125;</code></pre>

<h3 id="服务定位器模式（Service-Locator-Pattern）"><a href="#服务定位器模式（Service-Locator-Pattern）" class="headerlink" title="服务定位器模式（Service Locator Pattern）"></a>服务定位器模式（Service Locator Pattern）</h3><p>该模式提供了一个中央式的服务注册表：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class ServiceLocator &#123;
    private static Map&lt;String, Object&gt; services &#x3D; new HashMap&lt;&gt;();
    
    public static void register(String name, Object service) &#123;
        services.put(name, service);
    &#125;
    
    public static Object getService(String name) &#123;
        return services.get(name);
    &#125;
&#125;

&#x2F;&#x2F; Usage
class PaymentProcessor &#123;
    public void processPayment() &#123;
        &#x2F;&#x2F; Get logger service from locator instead of creating it
        Logger logger &#x3D; (Logger) ServiceLocator.getService(&quot;logger&quot;);
        logger.log(&quot;Processing payment...&quot;);
    &#125;
&#125;</code></pre>

<h3 id="事件驱动模式（Event-Driven-Pattern）"><a href="#事件驱动模式（Event-Driven-Pattern）" class="headerlink" title="事件驱动模式（Event-Driven Pattern）"></a>事件驱动模式（Event-Driven Pattern）</h3><p>通过事件处理器和监听器实现控制反转：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Event class
class UserEvent &#123;
    private String type;
    private User user;
    
    &#x2F;&#x2F; constructor and getters
&#125;

&#x2F;&#x2F; Event listener interface
interface UserEventListener &#123;
    void onUserEvent(UserEvent event);
&#125;

&#x2F;&#x2F; Event publisher
class UserManager &#123;
    private List&lt;UserEventListener&gt; listeners &#x3D; new ArrayList&lt;&gt;();
    
    public void addListener(UserEventListener listener) &#123;
        listeners.add(listener);
    &#125;
    
    public void createUser(User user) &#123;
        &#x2F;&#x2F; Business logic...
        
        &#x2F;&#x2F; Notify listeners
        UserEvent event &#x3D; new UserEvent(&quot;CREATE&quot;, user);
        listeners.forEach(listener -&gt; listener.onUserEvent(event));
    &#125;
&#125;</code></pre>

<h3 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h3><p>对象创建的控制权被反转给了工厂：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Animal &#123;
    void makeSound();
&#125;

class Dog implements Animal &#123;
    public void makeSound() &#123;
        System.out.println(&quot;Woof!&quot;);
    &#125;
&#125;

class Cat implements Animal &#123;
    public void makeSound() &#123;
        System.out.println(&quot;Meow!&quot;);
    &#125;
&#125;

class AnimalFactory &#123;
    public Animal createAnimal(String type) &#123;
        switch(type.toLowerCase()) &#123;
            case &quot;dog&quot;: return new Dog();
            case &quot;cat&quot;: return new Cat();
            default: throw new IllegalArgumentException(&quot;Unknown animal type&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h3><p>类似于事件驱动编程，但更关注状态变化：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Observer &#123;
    void update(String message);
&#125;

class NewsAgency &#123;
    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;&gt;();
    
    public void addObserver(Observer observer) &#123;
        observers.add(observer);
    &#125;
    
    public void notifyObservers(String news) &#123;
        observers.forEach(observer -&gt; observer.update(news));
    &#125;
&#125;

class NewsChannel implements Observer &#123;
    public void update(String news) &#123;
        System.out.println(&quot;Breaking News: &quot; + news);
    &#125;
&#125;</code></pre>

<p>这些IoC模式的不同之处：</p>
<ul>
<li><strong>控制反转的作用范围不同：</strong><ul>
<li><strong>DI</strong>反转了依赖的创建与绑定</li>
<li><strong>模板方法模式</strong>反转了程序流程的控制</li>
<li><strong>服务定位器模式</strong>反转了服务的发现</li>
<li><strong>事件驱动模式</strong>通过事件反转了流程控制</li>
<li><strong>工厂模式</strong>反转了对象的创建</li>
<li><strong>观察者模式</strong>反转了通知的流程</li>
</ul>
</li>
<li><strong>使用的时机不同：</strong><ul>
<li><strong>依赖注入（DI）</strong>：当你希望实现松耦合且更易于测试时</li>
<li><strong>模板方法模式</strong>：当你拥有一个不变算法但某些步骤可变时</li>
<li><strong>服务定位器模式</strong>：当你需要集中式服务管理时</li>
<li><strong>事件驱动模式</strong>：当你需要在事件生产者与消费者之间实现松耦合时</li>
<li><strong>工厂模式</strong>：当对象创建逻辑应集中管理时</li>
<li><strong>观察者模式</strong>：当你需要一对多的依赖关系时</li>
</ul>
</li>
</ul>
<p>每种模式都服务于不同的目的，并且可以在同一个应用程序中组合使用。具体选择取决于你的实际需求以及所要解决的问题。</p>
<h2 id="IoC-与-DI-的关键区别："><a href="#IoC-与-DI-的关键区别：" class="headerlink" title="IoC 与 DI 的关键区别："></a>IoC 与 DI 的关键区别：</h2><p><strong>作用范围:</strong></p>
<ul>
<li>IoC 是更广泛的原则  </li>
<li>DI 是 IoC 的一种具体实现方式</li>
</ul>
<p><strong>目的:</strong></p>
<ul>
<li>IoC 关注谁掌控程序流程</li>
<li>DI 关注依赖如何被提供</li>
</ul>
<p><strong>实现方式:</strong></p>
<ul>
<li>IoC 可以通过多种方式实现（依赖注入、服务定位器、事件驱动编程）</li>
<li>DI 专门关注对象如何接收其依赖</li>
</ul>
<h2 id="使用-IoC-和-DI-模式将高耦合类转化为松耦合类"><a href="#使用-IoC-和-DI-模式将高耦合类转化为松耦合类" class="headerlink" title="使用 IoC 和 DI 模式将高耦合类转化为松耦合类"></a>使用 IoC 和 DI 模式将高耦合类转化为松耦合类</h2><p><img data-src="https://storage.veitor.net/2025/12/lossely-coupled-transformation-process.webp" alt="lossely-coupled-transformation-process.webp"></p>
<p>图片展示了一个包含 4 个步骤的转换过程：</p>
<ol>
<li>从高耦合的类开始  </li>
<li>使用工厂模式实现 IoC  </li>
<li>通过创建抽象实现 DIP（依赖倒置原则）  </li>
<li>使用 IoC 容器实现 DI，结果：松耦合的类</li>
</ol>
<p>让我们用一个实际例子来实现它：</p>
<h3 id="步骤1：高耦合的类"><a href="#步骤1：高耦合的类" class="headerlink" title="步骤1：高耦合的类"></a>步骤1：高耦合的类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; This is the initial tightly coupled implementation
class EmailService &#123;
    public void sendEmail(String to, String message) &#123;
        &#x2F;&#x2F; Email sending logic
        System.out.println(&quot;Sending email to &quot; + to + &quot;: &quot; + message);
    &#125;
&#125;

class UserService &#123;
    &#x2F;&#x2F; Tightly coupled - UserService creates its own EmailService
    private EmailService emailService &#x3D; new EmailService();
    
    public void registerUser(String email) &#123;
        &#x2F;&#x2F; Registration logic
        emailService.sendEmail(email, &quot;Welcome to our service!&quot;);
    &#125;
&#125;</code></pre>

<h3 id="步骤2：使用工厂模式实现"><a href="#步骤2：使用工厂模式实现" class="headerlink" title="步骤2：使用工厂模式实现"></a>步骤2：使用工厂模式实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Create a factory to handle object creation
class ServiceFactory &#123;
    public static EmailService createEmailService() &#123;
        return new EmailService();
    &#125;
    
    public static UserService createUserService() &#123;
        EmailService emailService &#x3D; createEmailService();
        return new UserService(emailService);
    &#125;
&#125;

&#x2F;&#x2F; Modified UserService to accept EmailService
class UserService &#123;
    private EmailService emailService;
    
    public UserService(EmailService emailService) &#123;
        this.emailService &#x3D; emailService;
    &#125;
    
    public void registerUser(String email) &#123;
        &#x2F;&#x2F; Registration logic
        emailService.sendEmail(email, &quot;Welcome to our service!&quot;);
    &#125;
&#125;</code></pre>

<h3 id="步骤3：通过创建抽象层实现DIP"><a href="#步骤3：通过创建抽象层实现DIP" class="headerlink" title="步骤3：通过创建抽象层实现DIP"></a>步骤3：通过创建抽象层实现DIP</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Create interfaces (abstractions)
interface MessageService &#123;
    void sendMessage(String to, String message);
&#125;

interface UserManagement &#123;
    void registerUser(String email);
&#125;

&#x2F;&#x2F; Implement interfaces
class EmailService implements MessageService &#123;
    @Override
    public void sendMessage(String to, String message) &#123;
        System.out.println(&quot;Sending email to &quot; + to + &quot;: &quot; + message);
    &#125;
&#125;

class UserService implements UserManagement &#123;
    private final MessageService messageService;
    
    public UserService(MessageService messageService) &#123;
        this.messageService &#x3D; messageService;
    &#125;
    
    @Override
    public void registerUser(String email) &#123;
        &#x2F;&#x2F; Registration logic
        messageService.sendMessage(email, &quot;Welcome to our service!&quot;);
    &#125;
&#125;</code></pre>

<h3 id="步骤4：使用IoC容器实现DI"><a href="#步骤4：使用IoC容器实现DI" class="headerlink" title="步骤4：使用IoC容器实现DI"></a>步骤4：使用IoC容器实现DI</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Simple IoC Container
class IoCContainer &#123;
    private Map&lt;Class&lt;?&gt;, Object&gt; container &#x3D; new HashMap&lt;&gt;();
    
    public void register(Class&lt;?&gt; type, Object implementation) &#123;
        container.put(type, implementation);
    &#125;
    
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T resolve(Class&lt;T&gt; type) &#123;
        return (T) container.get(type);
    &#125;
&#125;

&#x2F;&#x2F; Configuration class to set up dependencies
class ApplicationConfig &#123;
    private IoCContainer container;
    
    public ApplicationConfig() &#123;
        container &#x3D; new IoCContainer();
        setupContainer();
    &#125;
    
    private void setupContainer() &#123;
        &#x2F;&#x2F; Register implementations
        container.register(MessageService.class, new EmailService());
        container.register(UserManagement.class, 
            new UserService(container.resolve(MessageService.class)));
    &#125;
    
    public IoCContainer getContainer() &#123;
        return container;
    &#125;
&#125;</code></pre>

<h3 id="最终结果：松耦合的类"><a href="#最终结果：松耦合的类" class="headerlink" title="最终结果：松耦合的类"></a>最终结果：松耦合的类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Application &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; Set up IoC container
        ApplicationConfig config &#x3D; new ApplicationConfig();
        IoCContainer container &#x3D; config.getContainer();
        
        &#x2F;&#x2F; Get service from container
        UserManagement userService &#x3D; container.resolve(UserManagement.class);
        
        &#x2F;&#x2F; Use service
        userService.registerUser(&quot;user@example.com&quot;);
    &#125;
&#125;</code></pre>

<p>这种实现展示了几个关键优势：</p>
<ol>
<li><strong>松耦合：</strong> 类依赖于抽象而不是具体实现</li>
<li><strong>灵活性：</strong> 易于切换实现（例如，从 EmailService 切换到 SMSService）</li>
<li><strong>可测试性：</strong> 便于在测试时模拟依赖项</li>
<li><strong>可维护性：</strong> 依赖关系明确且集中管理</li>
<li><strong>可扩展性：</strong> 无需修改现有代码即可轻松添加新的实现</li>
</ol>
<p>消息服务方式实现的一个示例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">class SMSService implements MessageService &#123;
    @Override
    public void sendMessage(String to, String message) &#123;
        System.out.println(&quot;Sending SMS to &quot; + to + &quot;: &quot; + message);
    &#125;
&#125;

&#x2F;&#x2F; To use SMS instead of email, just update the container registration:
container.register(MessageService.class, new SMSService());</code></pre>

<p>这一转换过程展示了如何按照图中所述步骤，利用 IoC 和 DI 模式将高耦合系统转变为松耦合系统。最终结果比原始实现更加灵活且易于维护。</p>
<h2 id="DIP-vs-IoC"><a href="#DIP-vs-IoC" class="headerlink" title="DIP vs IoC"></a>DIP vs IoC</h2><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><p>DIP是一种设计原则（SOLID中的D），其声明了：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖抽象。</li>
<li>抽象不应该依赖细节，细节应该依赖抽象。</li>
</ol>
<h3 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h3><p>IoC 是一种设计原则，它将程序的控制流程反转：不再由程序员控制流程，而是由框架来控制。</p>
<p>让我们通过一个示例来理解一下DIP：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Without DIP - Violating the principle
class PaymentProcessor &#123;
    &#x2F;&#x2F; Directly depends on concrete class
    private StripePaymentGateway paymentGateway &#x3D; new StripePaymentGateway();
    
    public void processPayment(double amount) &#123;
        paymentGateway.charge(amount);
    &#125;
&#125;

class StripePaymentGateway &#123;
    public void charge(double amount) &#123;
        &#x2F;&#x2F; Stripe specific implementation
    &#125;
&#125;</code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; With DIP - Following the principle
interface PaymentGateway &#123;
    void charge(double amount);
&#125;

class PaymentProcessor &#123;
    &#x2F;&#x2F; Depends on abstraction
    private PaymentGateway paymentGateway;
    
    public PaymentProcessor(PaymentGateway paymentGateway) &#123;
        this.paymentGateway &#x3D; paymentGateway;
    &#125;
    
    public void processPayment(double amount) &#123;
        paymentGateway.charge(amount);
    &#125;
&#125;

class StripePaymentGateway implements PaymentGateway &#123;
    @Override
    public void charge(double amount) &#123;
        &#x2F;&#x2F; Stripe specific implementation
    &#125;
&#125;

class PayPalPaymentGateway implements PaymentGateway &#123;
    @Override
    public void charge(double amount) &#123;
        &#x2F;&#x2F; PayPal specific implementation
    &#125;
&#125;</code></pre>
<p>再理解一下IoC：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Without IoC - Traditional control flow
class OrderService &#123;
    public void placeOrder() &#123;
        &#x2F;&#x2F; Service controls the flow
        validateOrder();
        processPayment();
        updateInventory();
        sendNotification();
    &#125;
    
    private void validateOrder() &#123; &#x2F;* ... *&#x2F; &#125;
    private void processPayment() &#123; &#x2F;* ... *&#x2F; &#125;
    private void updateInventory() &#123; &#x2F;* ... *&#x2F; &#125;
    private void sendNotification() &#123; &#x2F;* ... *&#x2F; &#125;
&#125;

&#x2F;&#x2F; With IoC (using Spring Framework)
@Service
class OrderService &#123;
    @Transactional
    public void placeOrder() &#123;
        &#x2F;&#x2F; Framework controls the flow
        &#x2F;&#x2F; - Transaction management
        &#x2F;&#x2F; - Exception handling
        &#x2F;&#x2F; - Logging
        &#x2F;&#x2F; - Security
        processOrder();
    &#125;
&#125;</code></pre>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><p><strong>目的：</strong></p>
<ul>
<li>DIP：专注于减少对具体实现的依赖</li>
<li>IoC：专注于谁控制程序流程</li>
</ul>
<p><strong>范围：</strong></p>
<ul>
<li>DIP：关于依赖关系的设计原则</li>
<li>IoC：关于流程控制的设计原则</li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>DIP：通过接口和抽象实现</li>
<li>IoC：通过框架和容器实现</li>
</ul>
<p><strong>现实世界类比：</strong></p>
<p><strong>DIP：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Without DIP (Like building your own car from scratch)
class Car &#123;
    private Engine engine &#x3D; new V8Engine();  &#x2F;&#x2F; Concrete dependency
&#125;

&#x2F;&#x2F; With DIP (Like getting a car with swappable engines)
interface Engine &#123; &#125;
class Car &#123;
    private Engine engine;  &#x2F;&#x2F; Abstract dependency
&#125;</code></pre>

<p><strong>IoC：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Without IoC (Like manually driving a car)
class Driver &#123;
    public void drive() &#123;
        startEngine();
        changeGear();
        pressAccelerator();
    &#125;
&#125;

&#x2F;&#x2F; With IoC (Like using a self-driving car)
@AutoDrive
class Car &#123;
    public void reachDestination() &#123;
        &#x2F;&#x2F; Framework handles driving operations
    &#125;
&#125;</code></pre>

<p><strong>常见用例：</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Combining DIP and IoC in Spring Framework
@Service
class OrderProcessor &#123;
    private final PaymentGateway paymentGateway;  &#x2F;&#x2F; DIP
    
    @Autowired  &#x2F;&#x2F; IoC
    public OrderProcessor(PaymentGateway paymentGateway) &#123;
        this.paymentGateway &#x3D; paymentGateway;
    &#125;
    
    @Transactional  &#x2F;&#x2F; IoC
    public void processOrder(Order order) &#123;
        paymentGateway.charge(order.getAmount());
    &#125;
&#125;</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>DIP 关注通过抽象来组织代码依赖</li>
<li>IoC 关注由谁掌控程序流程</li>
<li>二者常协同工作，但目的不同</li>
<li>DIP 是有效实现 IoC 的前提</li>
<li>Spring 等现代框架同时运用这两条原则</li>
</ul>
<p>主要的困惑往往源于两者都涉及“反转”，但它们反转的是软件设计中的不同方面：DIP 反转的是依赖关系，而 IoC 反转的是控制流。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"># 设计模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/comparing-sql-query-builders-and-orms/" rel="prev" title="原生SQL、Query Builder和ORM的区别">
                  <i class="fa fa-angle-left"></i> 原生SQL、Query Builder和ORM的区别
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备14016154号-1 </a>
  </div>
  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Veitor</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<!-- Giscus comment script with dynamic container insertion -->
<script>
  // 创建一个函数，用于动态插入giscus容器并加载脚本
  function loadGiscus() {
    // 查找.post元素
    const mainInner = document.querySelector('.post');
    
    if (mainInner) {
      // 创建.giscus容器元素
      const giscusContainer = document.createElement('div');
      giscusContainer.className = 'giscus';
      
      // 将容器插入到.post的最尾部
      mainInner.appendChild(giscusContainer);
      
      // 创建giscus脚本元素
      const giscusScript = document.createElement('script');
      giscusScript.src = 'https://giscus.app/client.js';
      giscusScript.setAttribute('data-repo', 'Veitor/veitor.github.io');
      giscusScript.setAttribute('data-repo-id', 'MDEwOlJlcG9zaXRvcnkyMjQxOTk3OTU=');
      giscusScript.setAttribute('data-category', 'Article Discussions');
      giscusScript.setAttribute('data-category-id', 'DIC_kwDODV0Ec84CpCCm');
      giscusScript.setAttribute('data-mapping', 'title');
      giscusScript.setAttribute('data-strict', '1');
      giscusScript.setAttribute('data-reactions-enabled', '1');
      giscusScript.setAttribute('data-emit-metadata', '0');
      giscusScript.setAttribute('data-input-position', 'top');
      giscusScript.setAttribute('data-theme', 'preferred_color_scheme');
      giscusScript.setAttribute('data-lang', 'zh-CN');
      giscusScript.setAttribute('data-loading', 'lazy');
      giscusScript.setAttribute('crossorigin', 'anonymous');
      
      // 将脚本添加到页面
      document.body.appendChild(giscusScript);
    } else {
      // 如果.post元素不存在，在页面加载完成后再次尝试
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadGiscus);
      } else {
        // 使用setTimeout延迟重试
        setTimeout(loadGiscus, 100);
      }
    }
  }
  
  // 在DOM内容加载完成后执行
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadGiscus);
  } else {
    // 如果DOM已经加载完成，直接执行
    loadGiscus();
  }
</script>
</body>
</html>
